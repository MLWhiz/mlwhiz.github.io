<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:content="http://purl.org/rss/1.0/modules/content" xmlns:media="http://search.yahoo.com/mrss/" >

  
  <channel>
    <title>Deep Learning on MLWhiz</title>
    <link>https://mlwhiz.com/tags/deep-learning/</link>
    <description>Recent content in Deep Learning on MLWhiz</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 24 Jun 2020 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://mlwhiz.com/tags/deep-learning/atom.xml" rel="self" type="application/rss+xml" />
    

    

    <item>
      <title>The Most Complete Guide to PyTorch for Data Scientists</title>
      <link>https://mlwhiz.com/blog/2020/09/09/pytorch_guide/</link>
      <pubDate>Tue, 08 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2020/09/09/pytorch_guide/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/pytorch_guide/main.png"></media:content>
      

      
      <description>PyTorch has sort of became one of the de facto standards for creating Neural Networks now, and I love its interface. Yet, it is somehow a little difficult for beginners to get a hold of.
I remember picking PyTorch up only after some extensive experimentation a couple of years back. To tell you the truth, it took me a lot of time to pick it up but am I glad that I moved from Keras to PyTorch.</description>

      <content:encoded>  
        
        <![CDATA[  PyTorch has sort of became one of the de facto standards for creating Neural Networks now, and I love its interface. Yet, it is somehow a little difficult for beginners to get a hold of.
I remember picking PyTorch up only after some extensive experimentation a couple of years back. To tell you the truth, it took me a lot of time to pick it up but am I glad that I moved from Keras to PyTorch. With its high customizability and pythonic syntax,PyTorch is just a joy to work with, and I would recommend it to anyone who wants to do some heavy lifting with Deep Learning.
So, in this PyTorch guide, I will try to ease some of the pain with PyTorch for starters and go through some of the most important classes and modules that you will require while creating any Neural Network with Pytorch.
But, that is not to say that this is aimed at beginners only as I will also talk about the high customizability PyTorch provides and will talk about custom Layers, Datasets, Dataloaders, and Loss functions.
So let’s get some coffee ☕ ️and start it up.
Tensors Tensors are the basic building blocks in PyTorch and put very simply, they are NumPy arrays but on GPU. In this part, I will list down some of the most used operations we can use while working with Tensors. This is by no means an exhaustive list of operations you can do with Tensors, but it is helpful to understand what tensors are before going towards the more exciting parts.
1. Create a Tensor We can create a PyTorch tensor in multiple ways. This includes converting to tensor from a NumPy array. Below is just a small gist with some examples to start with, but you can do a whole lot of more things with tensors just like you can do with NumPy arrays.
# Using torch.Tensor t = torch.Tensor([[1,2,3],[3,4,5]]) print(f&amp;#34;Created Tensor Using torch.Tensor:\n{t}&amp;#34;) # Using torch.randn t = torch.randn(3, 5) print(f&amp;#34;Created Tensor Using torch.randn:\n{t}&amp;#34;) # using torch.[ones|zeros](*size) t = torch.ones(3, 5) print(f&amp;#34;Created Tensor Using torch.ones:\n{t}&amp;#34;) t = torch.zeros(3, 5) print(f&amp;#34;Created Tensor Using torch.zeros:\n{t}&amp;#34;) # using torch.randint - a tensor of size 4,5 with entries between 0 and 10(excluded) t = torch.randint(low = 0,high = 10,size = (4,5)) print(f&amp;#34;Created Tensor Using torch.randint:\n{t}&amp;#34;) # Using from_numpy to convert from Numpy Array to Tensor a = np.array([[1,2,3],[3,4,5]]) t = torch.from_numpy(a) print(f&amp;#34;Convert to Tensor From Numpy Array:\n{t}&amp;#34;) # Using .numpy() to convert from Tensor to Numpy array t = t.numpy() print(f&amp;#34;Convert to Numpy Array From Tensor:\n{t}&amp;#34;) 2. Tensor Operations Again, there are a lot of operations you can do on these tensors. The full list of functions can be found here.
A = torch.randn(3,4) W = torch.randn(4,2) # Multiply Matrix A and W t = A.mm(W) print(f&amp;#34;Created Tensor t by Multiplying A and W:\n{t}&amp;#34;) # Transpose Tensor t t = t.t() print(f&amp;#34;Transpose of Tensor t:\n{t}&amp;#34;) # Square each element of t t = t**2 print(f&amp;#34;Square each element of Tensor t:\n{t}&amp;#34;) # return the size of a tensor print(f&amp;#34;Size of Tensor t using .size():\n{t.size()}&amp;#34;) Note: What are PyTorch Variables? In the previous versions of Pytorch, Tensor and Variables used to be different and provided different functionality, but now the Variable API is deprecated, and all methods for variables work with Tensors. So, if you don’t know about them, it’s fine as they re not needed, and if you know them, you can forget about them.
The nn.Module Here comes the fun part as we are now going to talk about some of the most used constructs in Pytorch while creating deep learning projects. nn.Module lets you create your Deep Learning models as a class. You can inherit from nn.Moduleto define any model as a class. Every model class necessarily contains an__init__ procedure block and a block for the forward pass.
 In the __init__ part, the user can define all the layers the network is going to have but doesn&amp;rsquo;t yet define how those layers would be connected to each other.
 In the forward pass block, the user defines how data flows from one layer to another inside the network.
  So, put simply, any network we define will look like:
class myNeuralNet(nn.Module): def __init__(self): super().__init__() # Define all Layers Here self.lin1 = nn.Linear(784, 30) self.lin2 = nn.Linear(30, 10) def forward(self, x): # Connect the layer Outputs here to define the forward pass x = self.lin1(x) x = self.lin2(x) return x Here we have defined a very simple Network that takes an input of size 784 and passes it through two linear layers in a sequential manner. But the thing to note is that we can define any sort of calculation while defining the forward pass, and that makes PyTorch highly customizable for research purposes. For example, in our crazy experimentation mode, we might have used the below network where we arbitrarily attach our layers. Here we send back the output from the second linear layer back again to the first one after adding the input to it(skip connection) back again(I honestly don’t know what that will do).
class myCrazyNeuralNet(nn.Module): def __init__(self): super().__init__() # Define all Layers Here self.lin1 = nn.Linear(784, 30) self.lin2 = nn.Linear(30, 784) self.lin3 = nn.Linear(30, 10) def forward(self, x): # Connect the layer Outputs here to define the forward pass x_lin1 = self.lin1(x) x_lin2 = x &#43; self.lin2(x_lin1) x_lin2 = self.lin1(x_lin2) x = self.lin3(x_lin2) return x We can also check if the neural network forward pass works. I usually do that by first creating some random input and just passing that through the network I have created.
x = torch.randn((100,784)) model = myCrazyNeuralNet() model(x).size() -------------------------- torch.Size([100, 10]) A word about Layers Pytorch is pretty powerful, and you can actually create any new experimental layer by yourself using nn.Module. For example, rather than using the predefined Linear Layer nn.Linear from Pytorch above, we could have created our custom linear layer.
class myCustomLinearLayer(nn.Module): def __init__(self,in_size,out_size): super().__init__() self.weights = nn.Parameter(torch.randn(in_size, out_size)) self.bias = nn.Parameter(torch.zeros(out_size)) def forward(self, x): return x.mm(self.weights) &#43; self.bias You can see how we wrap our weights tensor in nn.Parameter. This is done to make the tensor to be considered as a model parameter. From PyTorch docs:
 Parameters are *Tensor* subclasses, that have a very special property when used with Module - when they’re assigned as Module attributes they are automatically added to the list of its parameters, and will appear in parameters() iterator
 As you will later see, the model.parameters() iterator will be an input to the optimizer. But more on that later.
Right now, we can now use this custom layer in any PyTorch network, just like any other layer.
class myCustomNeuralNet(nn.Module): def __init__(self): super().__init__() # Define all Layers Here self.lin1 = myCustomLinearLayer(784,10) def forward(self, x): # Connect the layer Outputs here to define the forward pass x = self.lin1(x) return x x = torch.randn((100,784)) model = myCustomNeuralNet() model(x).size() ------------------------------------------ torch.Size([100, 10]) But then again, Pytorch would not be so widely used if it didn’t provide a lot of ready to made layers used very frequently in wide varieties of Neural Network architectures. Some examples are: nn.Linear, nn.Conv2d, nn.MaxPool2d, nn.ReLU, nn.BatchNorm2d, nn.Dropout, nn.Embedding, nn.GRU/nn.LSTM, nn.Softmax, nn.LogSoftmax, nn.MultiheadAttention, nn.TransformerEncoder, nn.TransformerDecoder
I have linked all the layers to their source where you could read all about them, but to show how I usually try to understand a layer and read the docs, I would try to look at a very simple convolutional layer here.
So, a Conv2d Layer needs as input an Image of height H and width W, with Cin channels. Now, for the first layer in a convnet, the number of in_channels would be 3(RGB), and the number of out_channels can be defined by the user. The kernel_size mostly used is 3x3, and the stride normally used is 1.
To check a new layer which I don’t know much about, I usually try to see the input as well as output for the layer like below where I would first initialize the layer:
conv_layer = nn.Conv2d(in_channels = 3, out_channels = 64, kernel_size = (3,3), stride = 1, padding=1) And then pass some random input through it. Here 100 is the batch size.
x = torch.randn((100,3,24,24)) conv_layer(x).size() -------------------------------- torch.Size([100, 64, 24, 24]) So, we get the output from the convolution operation as required, and I have sufficient information on how to use this layer in any Neural Network I design.
Datasets and DataLoaders How would we pass data to our Neural nets while training or while testing? We can definitely pass tensors as we have done above, but Pytorch also provides us with pre-built Datasets to make it easier for us to pass data to our neural nets. You can check out the complete list of datasets provided at torchvision.datasets and torchtext.datasets. But, to give a concrete example for datasets, let’s say we had to pass images to an Image Neural net using a folder which has images in this structure:
data train sailboat kayak . .  We can use torchvision.datasets.ImageFolder dataset to get an example image like below:
from torchvision import transforms from torchvision.datasets import ImageFolder traindir = &amp;#34;data/train/&amp;#34; t = transforms.Compose([ transforms.Resize(size=256), transforms.CenterCrop(size=224), transforms.ToTensor()]) train_dataset = ImageFolder(root=traindir,transform=t) print(&amp;#34;Num Images in Dataset:&amp;#34;, len(train_dataset)) print(&amp;#34;Example Image and Label:&amp;#34;, train_dataset[2]) This dataset has 847 images, and we can get an image and its label using an index. Now we can pass images one by one to any image neural network using a for loop:
for i in range(0,len(train_dataset)): image ,label = train_dataset[i] pred = model(image) But that is not optimal. We want to do batching. We can actually write some more code to append images and labels in a batch and then pass it to the Neural network. But Pytorch provides us with a utility iterator torch.utils.data.DataLoader to do precisely that. Now we can simply wrap our train_dataset in the Dataloader, and we will get batches instead of individual examples.
train_dataloader = DataLoader(train_dataset,batch_size = 64, shuffle=True, num_workers=10) We can simply iterate with batches using:
for image_batch, label_batch in train_dataloader: print(image_batch.size(),label_batch.size()) break ------------------------------------------------- torch.Size([64, 3, 224, 224]) torch.Size([64]) So actually, the whole process of using datasets and Dataloaders becomes:
t = transforms.Compose([ transforms.Resize(size=256), transforms.CenterCrop(size=224), transforms.ToTensor()]) train_dataset = torchvision.datasets.ImageFolder(root=traindir,transform=t) train_dataloader = DataLoader(train_dataset,batch_size = 64, shuffle=True, num_workers=10) for image_batch, label_batch in train_dataloader: pred = myImageNeuralNet(image_batch) You can look at this particular example in action in my previous blogpost on Image classification using Deep Learning here.
This is great, and Pytorch does provide a lot of functionality out of the box. But the main power of Pytorch comes with its immense customization. We can also create our own custom datasets if the datasets provided by PyTorch don’t fit our use case.
Understanding Custom Datasets To write our custom datasets, we can make use of the abstract class torch.utils.data.Dataset provided by Pytorch. We need to inherit this Dataset class and need to define two methods to create a custom Dataset.
 __len__ : a function that returns the size of the dataset. This one is pretty simple to write in most cases.
 __getitem__: a function that takes as input an index i and returns the sample at index i.
  For example, we can create a simple custom dataset that returns an image and a label from a folder. See that most of the tasks are happening in __init__ part where we use glob.glob to get image names and do some general preprocessing.
from glob import glob from PIL import Image from torch.utils.data import Dataset class customImageFolderDataset(Dataset): &amp;#34;&amp;#34;&amp;#34;Custom Image Loader dataset.&amp;#34;&amp;#34;&amp;#34; def __init__(self, root, transform=None): &amp;#34;&amp;#34;&amp;#34; Args: root (string): Path to the images organized in a particular folder structure. transform: Any Pytorch transform to be applied &amp;#34;&amp;#34;&amp;#34; # Get all image paths from a directory self.image_paths = glob(f&amp;#34;{root}/*/*&amp;#34;) # Get the labels from the image paths self.labels = [x.split(&amp;#34;/&amp;#34;)[-2] for x in self.image_paths] # Create a dictionary mapping each label to a index from 0 to len(classes). self.label_to_idx = {x:i for i,x in enumerate(set(self.labels))} self.transform = transform def __len__(self): # return length of dataset return len(self.image_paths) def __getitem__(self, idx): # open and send one image and label img_name = self.image_paths[idx] label = self.labels[idx] image = Image.open(img_name) if self.transform: image = self.transform(image) return image,self.label_to_idx[label] Also, note that we open our images one at a time in the __getitem__ method and not while initializing. This is not done in __init__ because we don&amp;rsquo;t want to load all our images in the memory and just need to load the required ones.
We can now use this dataset with the utility Dataloader just like before. It works just like the previous dataset provided by PyTorch but without some utility functions.
t = transforms.Compose([ transforms.Resize(size=256), transforms.CenterCrop(size=224), transforms.ToTensor()]) train_dataset = customImageFolderDataset(root=traindir,transform=t) train_dataloader = DataLoader(train_dataset,batch_size = 64, shuffle=True, num_workers=10) for image_batch, label_batch in train_dataloader: pred = myImageNeuralNet(image_batch) Understanding Custom DataLoaders This particular section is a little advanced and can be skipped going through this post as it will not be needed in a lot of situations. But I am adding it for completeness here.
So let’s say you are looking to provide batches to a network that processes text input, and the network could take sequences with any sequence size as long as the size remains constant in the batch. For example, we can have a BiLSTM network that can process sequences of any length. It’s alright if you don’t understand the layers used in it right now; just know that it can process sequences with variable sizes.
class BiLSTM(nn.Module): def __init__(self): super().__init__() self.hidden_size = 64 drp = 0.1 max_features, embed_size = 10000,300 self.embedding = nn.Embedding(max_features, embed_size) self.lstm = nn.LSTM(embed_size, self.hidden_size, bidirectional=True, batch_first=True) self.linear = nn.Linear(self.hidden_size*4 , 64) self.relu = nn.ReLU() self.dropout = nn.Dropout(drp) self.out = nn.Linear(64, 1) def forward(self, x): h_embedding = self.embedding(x) h_embedding = torch.squeeze(torch.unsqueeze(h_embedding, 0)) h_lstm, _ = self.lstm(h_embedding) avg_pool = torch.mean(h_lstm, 1) max_pool, _ = torch.max(h_lstm, 1) conc = torch.cat(( avg_pool, max_pool), 1) conc = self.relu(self.linear(conc)) conc = self.dropout(conc) out = self.out(conc) return out This network expects its input to be of shape (batch_size, seq_length) and works with any seq_length. We can check this by passing our model two random batches with different sequence lengths(10 and 25).
model = BiLSTM() input_batch_1 = torch.randint(low = 0,high = 10000, size = (100,**10**)) input_batch_2 = torch.randint(low = 0,high = 10000, size = (100,**25**)) print(model(input_batch_1).size()) print(model(input_batch_2).size()) ------------------------------------------------------------------ torch.Size([100, 1]) torch.Size([100, 1]) Now, we want to provide tight batches to this model, such that each batch has the same sequence length based on the max sequence length in the batch to minimize padding. This has an added benefit of making the neural net run faster. It was, in fact, one of the methods used in the winning submission of the Quora Insincere challenge in Kaggle, where running time was of utmost importance.
So, how do we do this? Let’s write a very simple custom dataset class first.
class CustomTextDataset(Dataset): &amp;#39;&amp;#39;&amp;#39; Simple Dataset initializes with X and y vectors We start by sorting our X and y vectors by sequence lengths &amp;#39;&amp;#39;&amp;#39; def __init__(self,X,y=None): self.data = list(zip(X,y)) # Sort by length of first element in tuple self.data = sorted(self.data, key=lambda x: len(x[0])) def __len__(self): return len(self.data) def __getitem__(self, idx): return self.data[idx] Also, let’s generate some random data which we will use with this custom Dataset.
import numpy as np train_data_size = 1024 sizes = np.random.randint(low=50,high=300,size=(train_data_size,)) X = [np.random.randint(0,10000, (sizes[i])) for i in range(train_data_size)] y = np.random.rand(train_data_size).round() #checking one example in dataset print((X[0],y[0])) Example of one random sequence and label. Each integer in the sequence corresponds to a word in the sentence.
We can use the custom dataset now using:
train_dataset = CustomTextDataset(X,y) If we now try to use the Dataloader on this dataset with batch_size&amp;gt;1, we will get an error. Why is that?
train_dataloader = DataLoader(train_dataset,batch_size = 64, shuffle=False, num_workers=10) for xb,yb in train_dataloader: print(xb.size(),yb.size()) This happens because the sequences have different lengths, and our data loader expects our sequences of the same length. Remember that in the previous image example, we resized all images to size 224 using the transforms, so we didn’t face this error.
So, how do we iterate through this dataset so that each batch has sequences with the same length, but different batches may have different sequence lengths?
We can use collate_fn parameter in the DataLoader that lets us define how to stack sequences in a particular batch. To use this, we need to define a function that takes as input a batch and returns (x_batch, y_batch ) with padded sequence lengths based on max_sequence_length in the batch. The functions I have used in the below function are simple NumPy operations. Also, the function is properly commented so you can understand what is happening.
def collate_text(batch): # get text sequences in batch data = [item[0] for item in batch] # get labels in batch target = [item[1] for item in batch] # get max_seq_length in batch max_seq_len = max([len(x) for x in data]) # pad text sequences based on max_seq_len data = [np.pad(p, (0, max_seq_len - len(p)), &amp;#39;constant&amp;#39;) for p in data] # convert data and target to tensor data = torch.LongTensor(data) target = torch.LongTensor(target) return [data, target] We can now use this collate_fn with our Dataloader as:
train_dataloader = DataLoader(train_dataset,batch_size = 64, shuffle=False, num_workers=10,collate_fn = collate_text) for xb,yb in train_dataloader: print(xb.size(),yb.size()) It will work this time as we have provided a custom collate_fn. And see that the batches have different sequence lengths now. Thus we would be able to train our BiLSTM using variable input sizes just like we wanted.
Training a Neural Network We know how to create a neural network using nn.Module. But how to train it? Any neural network that has to be trained will have a training loop that will look something similar to below:
num_epochs = 5 for epoch in range(num_epochs): # Set model to train mode model.train() for x_batch,y_batch in train_dataloader: # Clear gradients optimizer.zero_grad() # Forward pass - Predicted outputs pred = model(x_batch) # Find Loss and backpropagation of gradients loss = loss_criterion(pred, y_batch) loss.backward() # Update the parameters optimizer.step() model.eval() for x_batch,y_batch in valid_dataloader: pred = model(x_batch) val_loss = loss_criterion(pred, y_batch) In the above code, we are running five epochs and in each epoch:
 We iterate through the dataset using a data loader.
 In each iteration, we do a forward pass using model(x_batch)
 We calculate the Loss using a loss_criterion
 We back-propagate that loss using loss.backward() call. We don&amp;rsquo;t have to worry about the calculation of the gradients at all, as this simple call does it all for us.
 Take an optimizer step to change the weights in the whole network using optimizer.step(). This is where weights of the network get modified using the gradients calculated in loss.backward() call.
 We go through the validation data loader to check the validation score/metrics. Before doing validation, we set the model to eval mode using model.eval().Please note we don&amp;rsquo;t back-propagate losses in eval mode.
  Till now, we have talked about how to use nn.Module to create networks and how to use Custom Datasets and Dataloaders with Pytorch. So let&amp;rsquo;s talk about the various options available for Loss Functions and Optimizers.
Loss functions Pytorch provides us with a variety of loss functions for our most common tasks, like Classification and Regression. Some most used examples are nn.CrossEntropyLoss , nn.NLLLoss , nn.KLDivLoss and nn.MSELoss. You can read the documentation of each loss function, but to explain how to use these loss functions, I will go through the example of nn.NLLLoss
The documentation for NLLLoss is pretty succinct. As in, this loss function is used for Multiclass classification, and based on the documentation:
 the input expected needs to be of size (batch_size x Num_Classes ) — These are the predictions from the Neural Network we have created.
 We need to have the log-probabilities of each class in the input — To get log-probabilities from a Neural Network, we can add a LogSoftmax Layer as the last layer of our network.
 The target needs to be a tensor of classes with class numbers in the range(0, C-1) where C is the number of classes.
  So, we can try to use this Loss function for a simple classification network. Please note the LogSoftmax layer after the final linear layer. If you don&amp;rsquo;t want to use this LogSoftmax layer, you could have just used nn.CrossEntropyLoss
class myClassificationNet(nn.Module): def __init__(self): super().__init__() # Define all Layers Here self.lin = nn.Linear(784, 10) self.logsoftmax = nn.LogSoftmax(dim=1) def forward(self, x): # Connect the layer Outputs here to define the forward pass x = self.lin(x) x = self.logsoftmax(x) return x Let’s define a random input to pass to our network to test it:
# some random input: X = torch.randn(100,784) y = torch.randint(low = 0,high = 10,size = (100,)) And pass it through the model to get predictions:
model = myClassificationNet() preds = model(X) We can now get the loss as:
criterion = nn.NLLLoss() loss = criterion(preds,y) loss ------------------------------------------ tensor(2.4852, grad_fn=&amp;lt;NllLossBackward&amp;gt;) Custom Loss Function Defining your custom loss functions is again a piece of cake, and you should be okay as long as you use tensor operations in your loss function. For example, here is the customMseLoss
def customMseLoss(output,target): loss = torch.mean((output - target)**2) return loss You can use this custom loss just like before. But note that we don’t instantiate the loss using criterion this time as we have defined it as a function.
output = model(x) loss = customMseLoss(output, target) loss.backward() If we wanted, we could have also written it as a class using nn.Module , and then we would have been able to use it as an object. Here is an NLLLoss custom example:
class CustomNLLLoss(nn.Module): def __init__(self): super().__init__() def forward(self, x, y): # x should be output from LogSoftmax Layer log_prob = -1.0 * x # Get log_prob based on y class_index as loss=-mean(ylogp) loss = log_prob.gather(1, y.unsqueeze(1)) loss = loss.mean() return loss criterion = CustomNLLLoss() loss = criterion(preds,y) Optimizers Once we get gradients using the loss.backward() call, we need to take an optimizer step to change the weights in the whole network. Pytorch provides a variety of different ready to use optimizers using the torch.optim module. For example: torch.optim.Adadelta , torch.optim.Adagrad , torch.optim.RMSprop and the most widely used torch.optim.Adam.
To use the most used Adam optimizer from PyTorch, we can simply instantiate it with:
optimizer = torch.optim.Adam(model.parameters(), lr=0.01, betas=(0.9, 0.999)) And then use optimizer.zero_grad() and optimizer.step() while training the model.
I am not discussing how to write custom optimizers as it is an infrequent use case, but if you want to have more optimizers, do check out the pytorch-optimizer library, which provides a lot of other optimizers used in research papers. Also, if you anyhow want to create your own optimizers, you can take inspiration using the source code of implemented optimizers in PyTorch or pytorch-optimizers.
Other optimizers from pytorch-optimizer library
Using GPU/Multiple GPUs Till now, whatever we have done is on the CPU. If you want to use a GPU, you can put your model to GPU using model.to(&#39;cuda&#39;). Or if you want to use multiple GPUs, you can use nn.DataParallel. Here is a utility function that checks the number of GPUs in the machine and sets up parallel training automatically using DataParallel if needed.
# Whether to train on a gpu train_on_gpu = torch.cuda.is_available() print(f&amp;#39;Train on gpu: {train_on_gpu}&amp;#39;)# Number of gpus if train_on_gpu: gpu_count = torch.cuda.device_count() print(f&amp;#39;{gpu_count} gpus detected.&amp;#39;) if gpu_count &amp;gt; 1: multi_gpu = True else: multi_gpu = False if train_on_gpu: model = model.to(&amp;#39;cuda&amp;#39;) if multi_gpu: model = nn.DataParallel(model) The only thing that we will need to change is that we will load our data to GPU while training if we have GPUs. It’s as simple as adding a few lines of code to our training loop.
num_epochs = 5 for epoch in range(num_epochs): model.train() for x_batch,y_batch in train_dataloader: if train_on_gpu: x_batch,y_batch = x_batch.cuda(), y_batch.cuda() optimizer.zero_grad() pred = model(x_batch) loss = loss_criterion(pred, y_batch) loss.backward() optimizer.step() model.eval() for x_batch,y_batch in valid_dataloader: if train_on_gpu: x_batch,y_batch = x_batch.cuda(), y_batch.cuda() pred = model(x_batch) val_loss = loss_criterion(pred, y_batch) Conclusion Pytorch provides a lot of customizability with minimal code. While at first, it might be hard to understand how the whole ecosystem is structured with classes, in the end, it is simple Python. In this post, I have tried to break down most of the parts you might need while using Pytorch, and I hope it makes a little more sense for you after reading this.
You can find the code for this post here on my GitHub repo, where I keep codes for all my blogs.
If you want to learn more about Pytorch using a course based structure, take a look at the Deep Neural Networks with PyTorch course by IBM on Coursera. Also, if you want to know more about Deep Learning, I would like to recommend this excellent course on Deep Learning in Computer Vision in the Advanced machine learning specialization.
Thanks for the read. I am going to be writing more beginner-friendly posts in the future too. Follow me up at Medium or Subscribe to my blog
Also, a small disclaimer — There might be some affiliate links in this post to relevant resources, as sharing knowledge is never a bad idea.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>A Layman’s Introduction to GANs for Data Scientists using PyTorch</title>
      <link>https://mlwhiz.com/blog/2020/08/27/pyt_gan/</link>
      <pubDate>Thu, 27 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2020/08/27/pyt_gan/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/pyt_gan/main.png"></media:content>
      

      
      <description>Most of us in data science has seen a lot of AI-generated people in recent times, whether it be in papers, blogs, or videos. We’ve reached a stage where it’s becoming increasingly difficult to distinguish between actual human faces and faces generated by artificial intelligence. However, with the currently available machine learning toolkits, creating these images yourself is not as difficult as you might think.
In my view, GANs will change the way we generate video games and special effects.</description>

      <content:encoded>  
        
        <![CDATA[  Most of us in data science has seen a lot of AI-generated people in recent times, whether it be in papers, blogs, or videos. We’ve reached a stage where it’s becoming increasingly difficult to distinguish between actual human faces and faces generated by artificial intelligence. However, with the currently available machine learning toolkits, creating these images yourself is not as difficult as you might think.
In my view, GANs will change the way we generate video games and special effects. Using this approach, we could create realistic textures or characters on demand.
So in this post, we’re going to look at the generative adversarial networks behind AI-generated images, and help you to understand how to create and build your similar application with PyTorch. We’ll try to keep the post as intuitive as possible for those of you just starting out, but we’ll try not to dumb it down too much.
At the end of this article, you’ll have a solid understanding of how General Adversarial Networks (GANs) work, and how to build your own.
Task Overview In this post, we will create unique anime characters using the Anime Face Dataset. It is a dataset consisting of 63,632 high-quality anime faces in a number of styles. It’s a good starter dataset because it’s perfect for our goal.
We will be using Deep Convolutional Generative Adversarial Networks (DC-GANs) for our project. Though we’ll be using it to generate the faces of new anime characters, DC-GANs can also be used to create modern fashion styles, general content creation, and sometimes for data augmentation as well.
But before we get into the coding, let’s take a quick look at how GANs work.
INTUITION: Brief Intro to GANs for Generating Fake Images GANs typically employ two dueling neural networks to train a computer to learn the nature of a dataset well enough to generate convincing fakes. One of these Neural Networks generates fakes (the generator), and the other tries to classify which images are fake (the discriminator). These networks improve over time by competing against each other.
Perhaps imagine the generator as a robber and the discriminator as a police officer. The more the robber steals, the better he gets at stealing things. But at the same time, the police officer also gets better at catching the thief. Well, in an ideal world, anyway.
The losses in these neural networks are primarily a function of how the other network performs:
 Discriminator network loss is a function of generator network quality: Loss is high for the discriminator if it gets fooled by the generator’s fake images.
 Generator network loss is a function of discriminator network quality: Loss is high if the generator is not able to fool the discriminator.
  In the training phase, we train our discriminator and generator networks sequentially, intending to improve performance for both. The end goal is to end up with weights that help the generator to create realistic-looking images. In the end, we’ll use the generator neural network to generate high-quality fake images from random noise.
The Generator architecture One of the main problems we face when working with GANs is that the training is not very stable. So we have to come up with a generator architecture that solves our problem and also results in stable training. The diagram below is taken from the paper Unsupervised Representation Learning with Deep Convolutional Generative Adversarial Networks, which explains the DC-GAN generator architecture.
Though it might look a little bit confusing, essentially you can think of a generator neural network as a black box which takes as input a 100 dimension normally generated vector of numbers and gives us an image:
So how do we create such an architecture? Below, we use a dense layer of size 4x4x1024 to create a dense vector out of the 100-d vector. We then reshape the dense vector in the shape of an image of 4×4 with 1024 filters, as shown in the following figure:
Note that we don’t have to worry about any weights right now as the network itself will learn those during training.
Once we have the 1024 4×4 maps, we do upsampling using a series of transposed convolutions, which after each operation doubles the size of the image and halves the number of maps. In the last step, however, we don’t halve the number of maps. We reduce the maps to 3 for each RGB channel since we need three channels for the output image.
Now, What are Transpose convolutions? Put simply, transposing convolutions provides us with a way to upsample images. In a convolution operation, we try to go from a 4×4 image to a 2×2 image. But when we transpose convolutions, we convolve from 2×2 to 4×4 as shown in the following figure:
Some of you may already know that unpooling is commonly used for upsampling input feature maps in convolutional neural networks (CNN). So why don’t we use unpooling here?
The reason comes down to the fact that unpooling does not involve any learning. However, transposed convolution is learnable, so it’s preferred. Later in the article, we’ll see how the parameters can be learned by the generator.
The Discriminator architecture Now that we’ve covered the generator architecture, let’s look at the discriminator as a black box. In practice, it contains a series of convolutional layers with a dense layer at the end to predict if an image is fake or not. You can see an example in the figure below:
Every image convolutional neural network works by taking an image as input, and predicting if it is real or fake using a sequence of convolutional layers.
Data preprocessing and visualization Before going any further with our training, we preprocess our images to a standard size of 64x64x3. We will also need to normalize the image pixels before we train our GAN. You can see the process in the code below, which I’ve commented on for clarity.
# Root directory for dataset dataroot = &amp;#34;anime_images/&amp;#34; # Number of workers for dataloader workers = 2 # Batch size during training batch_size = 128 # Spatial size of training images. All images will be resized to this size using a transformer. image_size = 64 # Number of channels in the training images. For color images this is 3 nc = 3 # We can use an image folder dataset the way we have it setup. # Create the dataset dataset = datasets.ImageFolder(root=dataroot, transform=transforms.Compose([ transforms.Resize(image_size), transforms.CenterCrop(image_size), transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)), ])) # Create the dataloader dataloader = torch.utils.data.DataLoader(dataset, batch_size=batch_size, shuffle=True, num_workers=workers) # Decide which device we want to run on device = torch.device(&amp;#34;cuda:0&amp;#34; if (torch.cuda.is_available() and ngpu &amp;gt; 0) else &amp;#34;cpu&amp;#34;) # Plot some training images real_batch = next(iter(dataloader)) plt.figure(figsize=(8,8)) plt.axis(&amp;#34;off&amp;#34;) plt.title(&amp;#34;Training Images&amp;#34;) plt.imshow(np.transpose(vutils.make_grid(real_batch[0].to(device)[:64], padding=2, normalize=True).cpu(),(1,2,0))) The resultant output of the code is as follows:
So Many different Characters — Can our Generator understand the patterns?
Implementation of DCGAN This is the part where we define our DCGAN. We will be defining our noise generator function, Generator architecture, and Discriminator architecture.
Generating noise vector for Generator We need to generate the noise which we want to convert to an image using our generator architecture.
We use a normal distribution
to generate the noise vector:
nz = 100 noise = torch.randn(64, nz, 1, 1, device=device)  Generator architecture The generator is the most crucial part of the GAN. Here, we’ll create a generator by adding some transposed convolution layers to upsample the noise vector to an image. You’ll notice that this generator architecture is not the same as the one given in the DC-GAN paper I linked above.
In order to make it a better fit for our data, I had to make some architectural changes. I added a convolution layer in the middle and removed all dense layers from the generator architecture to make it fully convolutional.
I also used a lot of Batchnorm layers and leaky ReLU activation. The following code block is the function I will use to create the generator:
# Size of feature maps in generator ngf = 64 # Number of channels in the training images. For color images this is 3 nc = 3 # Size of z latent vector (i.e. size of generator input noise) nz = 100 class Generator(nn.Module): def __init__(self, ngpu): super(Generator, self).__init__() self.ngpu = ngpu self.main = nn.Sequential( # input is noise, going into a convolution # Transpose 2D conv layer 1. nn.ConvTranspose2d( nz, ngf * 8, 4, 1, 0, bias=False), nn.BatchNorm2d(ngf * 8), nn.ReLU(True), # Resulting state size - (ngf*8) x 4 x 4 i.e. if ngf= 64 the size is 512 maps of 4x4 # Transpose 2D conv layer 2. nn.ConvTranspose2d(ngf * 8, ngf * 4, 4, 2, 1, bias=False), nn.BatchNorm2d(ngf * 4), nn.ReLU(True), # Resulting state size -(ngf*4) x 8 x 8 i.e 8x8 maps # Transpose 2D conv layer 3. nn.ConvTranspose2d( ngf * 4, ngf * 2, 4, 2, 1, bias=False), nn.BatchNorm2d(ngf * 2), nn.ReLU(True), # Resulting state size. (ngf*2) x 16 x 16 # Transpose 2D conv layer 4. nn.ConvTranspose2d( ngf * 2, ngf, 4, 2, 1, bias=False), nn.BatchNorm2d(ngf), nn.ReLU(True), # Resulting state size. (ngf) x 32 x 32 # Final Transpose 2D conv layer 5 to generate final image. # nc is number of channels - 3 for 3 image channel nn.ConvTranspose2d( ngf, nc, 4, 2, 1, bias=False), # Tanh activation to get final normalized image nn.Tanh() # Resulting state size. (nc) x 64 x 64 ) def forward(self, input): &amp;#39;&amp;#39;&amp;#39; This function takes as input the noise vector&amp;#39;&amp;#39;&amp;#39; return self.main(input) Now we can instantiate the model using the generator class. We are keeping the default weight initializer for PyTorch even though the paper says to initialize the weights using a mean of 0 and std dev of 0.2. The default weights initializer from Pytorch is more than good enough for our project.
# Create the generator netG = Generator(ngpu).to(device) # Handle multi-gpu if desired if (device.type == &#39;cuda&#39;) and (ngpu &amp;gt; 1): netG = nn.DataParallel(netG, list(range(ngpu))) # Print the model print(netG)  We can see the final generator model:
The Discriminator architecture Here is the discriminator architecture where I use a series of convolutional layers and a dense layer at the end to predict if an image is fake or not.
# Number of channels in the training images. For color images this is 3 nc = 3 # Size of feature maps in discriminator ndf = 64 class Discriminator(nn.Module): def __init__(self, ngpu): super(Discriminator, self).__init__() self.ngpu = ngpu self.main = nn.Sequential( # input is (nc) x 64 x 64 nn.Conv2d(nc, ndf, 4, 2, 1, bias=False), nn.LeakyReLU(0.2, inplace=True), # state size. (ndf) x 32 x 32 nn.Conv2d(ndf, ndf * 2, 4, 2, 1, bias=False), nn.BatchNorm2d(ndf * 2), nn.LeakyReLU(0.2, inplace=True), # state size. (ndf*2) x 16 x 16 nn.Conv2d(ndf * 2, ndf * 4, 4, 2, 1, bias=False), nn.BatchNorm2d(ndf * 4), nn.LeakyReLU(0.2, inplace=True), # state size. (ndf*4) x 8 x 8 nn.Conv2d(ndf * 4, ndf * 8, 4, 2, 1, bias=False), nn.BatchNorm2d(ndf * 8), nn.LeakyReLU(0.2, inplace=True), # state size. (ndf*8) x 4 x 4 nn.Conv2d(ndf * 8, 1, 4, 1, 0, bias=False), nn.Sigmoid() ) def forward(self, input): return self.main(input) Now we can instantiate the discriminator exactly as we did the generator.
# Create the Discriminator netD = Discriminator(ngpu).to(device) # Handle multi-gpu if desired if (device.type == &#39;cuda&#39;) and (ngpu &amp;gt; 1): netD = nn.DataParallel(netD, list(range(ngpu))) # Print the model print(netD)  Here is the architecture of the discriminator:
Training Understanding how the training works in GAN is essential. It’s interesting, too; we can see how training the generator and discriminator together improves them both at the same time.
Now that we have our discriminator and generator models, next we need to initialize separate optimizers for them.
# Initialize BCELoss function criterion = nn.BCELoss() # Create batch of latent vectors that we will use to visualize # the progression of the generator fixed_noise = torch.randn(64, nz, 1, 1, device=device) # Establish convention for real and fake labels during training real_label = 1. fake_label = 0. # Setup Adam optimizers for both G and D # Learning rate for optimizers lr = 0.0002 # Beta1 hyperparam for Adam optimizers beta1 = 0.5 optimizerD = optim.Adam(netD.parameters(), lr=lr, betas=(beta1, 0.999)) optimizerG = optim.Adam(netG.parameters(), lr=lr, betas=(beta1, 0.999)) The Training Loop This is the main area where we need to understand how the blocks we’ve created will assemble and work together.
# Lists to keep track of progress/Losses img_list = [] G_losses = [] D_losses = [] iters = 0 # Number of training epochs num_epochs = 50 # Batch size during training batch_size = 128 print(&amp;#34;Starting Training Loop...&amp;#34;) # For each epoch for epoch in range(num_epochs): # For each batch in the dataloader for i, data in enumerate(dataloader, 0): ############################ # (1) Update D network: maximize log(D(x)) &#43; log(1 - D(G(z))) # Here we: # A. train the discriminator on real data # B. Create some fake images from Generator using Noise # C. train the discriminator on fake data ########################### # Training Discriminator on real data netD.zero_grad() # Format batch real_cpu = data[0].to(device) b_size = real_cpu.size(0) label = torch.full((b_size,), real_label, device=device) # Forward pass real batch through D output = netD(real_cpu).view(-1) # Calculate loss on real batch errD_real = criterion(output, label) # Calculate gradients for D in backward pass errD_real.backward() D_x = output.mean().item() ## Create a batch of fake images using generator # Generate noise to send as input to the generator noise = torch.randn(b_size, nz, 1, 1, device=device) # Generate fake image batch with G fake = netG(noise) label.fill_(fake_label) # Classify fake batch with D output = netD(fake.detach()).view(-1) # Calculate D&amp;#39;s loss on the fake batch errD_fake = criterion(output, label) # Calculate the gradients for this batch errD_fake.backward() D_G_z1 = output.mean().item() # Add the gradients from the all-real and all-fake batches errD = errD_real &#43; errD_fake # Update D optimizerD.step() ############################ # (2) Update G network: maximize log(D(G(z))) # Here we: # A. Find the discriminator output on Fake images # B. Calculate Generators loss based on this output. Note that the label is 1 for generator. # C. Update Generator ########################### netG.zero_grad() label.fill_(real_label) # fake labels are real for generator cost # Since we just updated D, perform another forward pass of all-fake batch through D output = netD(fake).view(-1) # Calculate G&amp;#39;s loss based on this output errG = criterion(output, label) # Calculate gradients for G errG.backward() D_G_z2 = output.mean().item() # Update G optimizerG.step() # Output training stats every 50th Iteration in an epoch if i % 1000 == 0: print(&amp;#39;[%d/%d][%d/%d]\tLoss_D: %.4f\tLoss_G: %.4f\tD(x): %.4f\tD(G(z)): %.4f/ %.4f&amp;#39; % (epoch, num_epochs, i, len(dataloader), errD.item(), errG.item(), D_x, D_G_z1, D_G_z2)) # Save Losses for plotting later G_losses.append(errG.item()) D_losses.append(errD.item()) # Check how the generator is doing by saving G&amp;#39;s output on a fixed_noise vector if (iters % 250 == 0) or ((epoch == num_epochs-1) and (i == len(dataloader)-1)): #print(iters) with torch.no_grad(): fake = netG(fixed_noise).detach().cpu() img_list.append(vutils.make_grid(fake, padding=2, normalize=True)) iters &#43;= 1 It may seem complicated, but I’ll break down the code above step by step in this section. The main steps in every training iteration are:
Step 1: Sample a batch of normalized images from the dataset
for i, data in enumerate(dataloader, 0):  Step 2: Train discriminator using generator images(Fake images) and real normalized images(Real Images) and their labels.
 # Training Discriminator on real data netD.zero_grad() # Format batch real_cpu = data[0].to(device) b_size = real_cpu.size(0) label = torch.full((b_size,), real_label, device=device) # Forward pass real batch through D output = netD(real_cpu).view(-1) # Calculate loss on real batch errD_real = criterion(output, label) # Calculate gradients for D in backward pass errD_real.backward() D_x = output.mean().item() ## Create a batch of fake images # Generate noise to send as input to the generator noise = torch.randn(b_size, nz, 1, 1, device=device) # Generate fake image batch with G fake = netG(noise) label.fill_(fake_label) # Classify fake batch with D output = netD(fake.detach()).view(-1) # Calculate D&#39;s loss on the fake batch errD_fake = criterion(output, label) # Calculate the gradients for this batch errD_fake.backward() D_G_z1 = output.mean().item() # Add the gradients from the all-real and all-fake batches errD = errD_real &#43; errD_fake # Update D optimizerD.step()  Step 3: Backpropagate the errors through the generator by computing the loss gathered from discriminator output on fake images as the input and 1’s as the target while keeping the discriminator as untrainable — This ensures that the loss is higher when the generator is not able to fool the discriminator. You can check it yourself like so: if the discriminator gives 0 on the fake image, the loss will be high i.e., BCELoss(0,1).
 netG.zero_grad() label.fill_(real_label) # fake labels are real for generator cost output = netD(fake).view(-1) # Calculate G&#39;s loss based on this output errG = criterion(output, label) # Calculate gradients for G errG.backward() D_G_z2 = output.mean().item() # Update G optimizerG.step()  We repeat the steps using the for loop to end up with a good discriminator and generator.
Results The final output of our generator can be seen below. The GAN generates pretty good images for our content editor friends to work with.
The images might be a little crude, but still, this project was a starter for our GAN journey. The field is constantly advancing with better and more complex GAN architectures, so we’ll likely see further increases in image quality from these architectures. Also, keep in mind that these images are generated from a noise vector only: this means the input is some noise, and the output is an image. It’s quite incredible.
ALL THESE IMAGES ARE FAKE
1. Loss over the training period Here is the graph generated for the losses. We can see that the GAN Loss is decreasing on average, and the variance is also decreasing as we do more steps. It’s possible that training for even more iterations would give us even better results.
plt.figure(figsize=(10,5)) plt.title(&amp;quot;Generator and Discriminator Loss During Training&amp;quot;) plt.plot(G_losses,label=&amp;quot;G&amp;quot;) plt.plot(D_losses,label=&amp;quot;D&amp;quot;) plt.xlabel(&amp;quot;iterations&amp;quot;) plt.ylabel(&amp;quot;Loss&amp;quot;) plt.legend() plt.show()  2. Image Animation at every 250th Iteration in Jupyter Notebook We can choose to see the output as an animation using the below code:
#%%capture fig = plt.figure(figsize=(8,8)) plt.axis(&amp;quot;off&amp;quot;) ims = [[plt.imshow(np.transpose(i,(1,2,0)), animated=True)] for i in img_list] ani = animation.ArtistAnimation(fig, ims, interval=1000, repeat_delay=1000, blit=True)HTML(ani.to_jshtml())  You can choose to save an animation object as a gif as well if you want to send them to some friends.
ani.save(&#39;animation.gif&#39;, writer=&#39;imagemagick&#39;,fps=5) Image(url=&#39;animation.gif&#39;)  3. Image generated at every 200 Iter Given below is the code to generate some images at different training steps. As we can see, as the number of steps increases, the images are getting better.
# create a list of 16 images to show every_nth_image = np.ceil(len(img_list)/16) ims = [np.transpose(img,(1,2,0)) for i,img in enumerate(img_list)if i%every_nth_image==0] print(&amp;quot;Displaying generated images&amp;quot;) # You might need to change grid size and figure size here according to num images. plt.figure(figsize=(20,20)) gs1 = gridspec.GridSpec(4, 4) gs1.update(wspace=0, hspace=0) step = 0 for i,image in enumerate(ims): ax1 = plt.subplot(gs1[i]) ax1.set_aspect(&#39;equal&#39;) fig = plt.imshow(image) # you might need to change some params here fig = plt.text(7,30,&amp;quot;Step: &amp;quot;&#43;str(step),bbox=dict(facecolor=&#39;red&#39;, alpha=0.5),fontsize=12) plt.axis(&#39;off&#39;) fig.axes.get_xaxis().set_visible(False) fig.axes.get_yaxis().set_visible(False) step&#43;=int(250*every_nth_image) #plt.tight_layout() plt.savefig(&amp;quot;GENERATEDimage.png&amp;quot;,bbox_inches=&#39;tight&#39;,pad_inches=0) plt.show()  Given below is the result of the GAN at different time steps:
Conclusion In this post, we covered the basics of GANs for creating fairly believable fake images. We hope you now have an understanding of generator and discriminator architecture for DC-GANs, and how to build a simple DC-GAN to generate anime images from scratch.
Though this model is not the most perfect anime face generator, using it as a base helps us to understand the basics of generative adversarial networks, which in turn can be used as a stepping stone to more exciting and complex GANs as we move forward.
Look at it this way, as long as we have the training data at hand, we now have the ability to conjure up realistic textures or characters on demand. That is no small feat.
For a closer look at the code for this post, please visit my GitHub repository where you can find the code for this post as well as all my posts.
If you want to know more about deep learning applications and use cases, take a look at the Sequence Models course in the Deep Learning Specialization by Andrew Ng. Andrew is a great instructor, and this course is excellent too.
I am going to be writing more of such posts in the future too. Let me know what you think about the series. Follow me up at Medium or Subscribe to my blog.
Also, a small disclaimer — There might be some affiliate links in this post to relevant resources, as sharing knowledge is never a bad idea.
This post was first published here
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Creating my First Deep Learning &#43; Data Science Workstation</title>
      <link>https://mlwhiz.com/blog/2020/08/09/owndlrig/</link>
      <pubDate>Sun, 09 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2020/08/09/owndlrig/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/owndlrig/main.png"></media:content>
      

      
      <description>Creating my workstation has been a dream for me, if nothing else.
I knew the process involved, yet I somehow never got to it. It might have been time or money. Mostly Money.
But this time I just had to do it. I was just fed up with setting up a server on AWS for any small personal project and fiddling with all the installations. Or I had to work on Google Collab notebooks, which have a lot of limitations on running times and network connections.</description>

      <content:encoded>  
        
        <![CDATA[  Creating my workstation has been a dream for me, if nothing else.
I knew the process involved, yet I somehow never got to it. It might have been time or money. Mostly Money.
But this time I just had to do it. I was just fed up with setting up a server on AWS for any small personal project and fiddling with all the installations. Or I had to work on Google Collab notebooks, which have a lot of limitations on running times and network connections. So, I found out some time to create a Deep Learning Rig with some assistance from NVIDIA folks.
The whole process involved a lot of reading up and watching a lot of Youtube videos from Linus Tech Tips. And as it was the first time I was assembling a computer from scratch, it was sort of special too.
Building the DL rig as per your requirements takes up a lot of research. I researched on individual parts, their performance, reviews, and even the aesthetics.
Now, most of the workstation builds I researched were focussed on gaming, so I thought of putting down a Deep Learning Rig Spec as well.
I will try to put all the components I used along with the reasons why I went with those particular parts as well.
***Also, if you want to see how I set up the Deep Learning libraries after setting up the system to use Ubuntu 18.04, you can view ***this definitive guide for Setting up a Deep Learning Workstation.
So why the need for a workstation? The very first answer that comes to my mind is, why not?
I work a lot on deep learning and machine learning applications, and it always has been such a massive headache to churn up a new server and installing all the dependencies every time I start to work on a new project.
Also, it looks great, sits on your desk, is available all the time, and is open to significant customization as per your requirements.
Adding to this the financial aspects of using the GCP or AWS, and I was pretty much sold on the idea of building my rig.
My Build It took me a couple of weeks to come up with the final build.
I knew from the start that I want to have a lot of computing power and also something that would be upgradable in the coming years. Currently, my main priorities were to get a system that could support two NVIDIA RTX Titan cards with NVLink. That would allow me to have 48GB GPU memory at my disposal. Simply awesome.
PS:* The below build might not be the best build, and there may be cheaper alternatives present, but I know for sure that it is the build with the minimal future headache. So I went with it. I also contacted Nvidia to get a lot of suggestions about this particular build and only went forward after they approved of it.
1. Intel i9 9920x 3.5 GHz 12 core Processor Yes, I went with an Intel processor and not an AMD one. My reason for this (though people may differ with me on this) is because Intel has more compatible and related software like Intel’s MKL, which benefits most of the Python libraries I use.
Another and maybe a more important reason, at least for me, was that it was suggested by the people at NVIDIA to go for i9 if I wanted to have a dual RTX Titan configuration. Again zero headaches in the future.
So why this particular one from the Intel range?
I started with 9820X with its ten cores and 9980XE with 18 cores, but the latter stretched my budget a lot. I found that i9–9920X, with its 12 cores and 3.5 GHz processor, fit my budget just fine, and as it is always better to go for the mid-range solution, I went with it.
Now a CPU is the component that decides a lot of other components you are going to end up using.
For example, if you choose an i9 9900X range of CPU, you will have to select an X299 motherboard, or if you are going to use an AMD Threadripper CPU, you will need an X399 Motherboard. So be mindful of choosing the right CPU and motherboard.
2. MSI X299 SLI PLUS ATX LGA2066 Motherboard This was a particularly difficult choice. There are just too many options here. I wanted a Motherboard that could support at least 96GB RAM (again as per the specifications by the NVIDIA Folks for supporting 2 Titans). That meant that I had to have at least six slots if I were to use 16GB RAM Modules as 16x6=96. I got 8 in this one, so it is expandable till 128 GB RAM.
I also wanted to be able to have 2 TB NVMe SSD in my system(in the future), and that meant I needed 2 M.2 ports, which this board has. Or else I would have to go for a much expensive 2TB Single NVMe SSD.
I looked into a lot of options, and based on the ATX Form factor, 4 PCI-E x16 slots, and the reasonable pricing of the board, I ended up choosing this one.
3. Noctua NH-D15 chromax.BLACK 82.52 CFM CPU Cooler Liquid cooling is in rage right now. And initially, I also wanted to go for an AIO cooler, i.e., liquid cooling.
But after talking to a couple of people at NVIDIA as well as scrouging through the internet forums on the pro and cons of both options, I realized that Air cooling is better suited to my needs. So I went for the Noctua NH-D15, which is one of the best Air coolers in the market. So, I went with the best air cooling instead of a mediocre water cooling. And this cooler is SILENT. More on this later.
4. Phanteks Enthoo Pro Tempered Glass Case The next thing to think was a case that is going to be big enough to handle all these components and also be able to provide the required cooling. It was where I spent most of my time while researching.
I mean, we are going to keep 2 Titan RTX, 9920x CPU, 128 GB RAM. It’s going to be a hellish lot of heat in there.
Add to that the space requirements for the Noctua air cooler and the capability to add a lot of fans, and I was left with two options based on my poor aesthetic sense as well as the availability in my country. The options were — Corsair Air 540 ATX and the Phanteks Enthoo Pro Tempered Glass PH-ES614PTG_SWT.
Both of them are exceptional cases, but I went through with the Enthoo Pro as it is a more recently launched case and has a bigger form factor(Full Tower) offers options for more customizable build in the future too.
5. Dual Titan RTX with 3 Slot NVLink These 2 Titan RTX are by far the most important and expensive part of the whole build. These alone take up 80% of the cost, but aren’t they awesome?
I wanted to have a high-performance GPU in my build, and the good folks at NVIDIA were generous enough to send me two of these to test out.
I just love them. The design. The way they look in the build and the fact that they can be combined using a 3 Slot NVLink to provide 48 GB of GPU RAM effectively. Just awesome. If money is an issue, 2 x RTX 2080 Ti would also work fine as well. Only a problem will be that you might need smaller batch sizes training on RTX 2080 Ti, and in some cases, you might not be able to train large models as RTX2080Ti has 11GB RAM only. Also, you won’t be able to use NVLink, which combines the VRAM of multiple GPUs in Titans.
6. Samsung 970 Evo Plus 1 TB NVME Solid State Drive What about storage? NVMe SSD, of course, and the Samsung Evo Plus is the unanimous and most popular winner in this SSD race.
I bought 1 of them till now, but as I have 2 M.2 ports in my motherboard, I will get total storage of 2TB SSD in the future.
You can also get a couple of 2.5&amp;rdquo; SSD for more storage space.
7. Corsair Vengeance LPX 128GB (8x16GB) DDR4 3200 MHz I wanted to have a minimum of 96GB RAM, as suggested by the NVIDIA team. So I said what the heck and went with the full 128 GB RAM without cheaping out.
As you can see, these RAM sticks are not RGB lit, and that is a conscious decision as the Noctua Air Cooler doesn’t provide a lot of clearance for RAM Slots and the RGB ones had a slightly higher height. So keep that in mind. Also, I was never trying to go for an RGB Build anyway as I want to focus on those lit up Titans in my build.
8. Corsair 1200W Power Supply A 1200W power supply is a pretty big one, but that is needed realizing that the estimated wattage of our components at full wattage is going to be ~965W.
I had a couple of options for the power supply from other manufacturers also but went with this one because of Corsair’s name. I would have gone with HX1200i, but it was not available, and AX1200i was much more expensive than this one at my location. But both of them are excellent options apart from this one.
9. Even More Fans The Phanteks case comes up with three fans, but I was recommended to upgrade the intake, and exhaust fans of the case to BeQuiet BL071 PWM Fans as Dual Titans can put out a lot of heat. I have noticed that the temperature of my room is almost 2–3 degrees higher than the outside temperature, as I generally keep the machine on.
To get the best possible airflow, I bought 5 of these. I have put two at the top of the case along with a Phanteks case fan, 2 of them in the front, and one fan at the back of the case.
10. Peripherals The Essentials — A cup of tea and those speakers
This section is not necessary but wanted to put it in for completion.
Given all the power we have got, I didn’t want to cheap out on the peripherals. So I got myself an LG 27UK650 4k monitor for content creation, BenQ EX2780Q 1440p 144hz Gaming Monitor for a little bit of gaming, a Mechanical Cherry MX Red Corsair K68 Keyboard and a Corsair M65 Pro Mouse.
And my build is complete.
Pricing 💰💰💰 I will put the price as per the PCPartPicker site as I have gotten my components from different countries and sources. You can also check the part list at the PCPartPicker site: https://pcpartpicker.com/list/zLVjZf
As you can see, this is pretty expensive by any means (even after getting the GPUs from NVIDIA), but that is the price you pay for certain afflictions, I guess.
Finally In this post, I talked about all the parts you are going to need to assemble your deep learning rig and my reasons for getting these in particular.
You might try to look out for better components or a different design, but this one has been working pretty well for me for quite some time now, and is it fast.
If you want to see how I set up the Deep Learning libraries after setting up the system with these components, you can view this definitive guide for Setting up a Deep Learning Workstation with Ubuntu 18.04
Let me know what you think in the comments.
Thanks for the read. I am going to be writing more beginner-friendly posts in the future too. Follow me up at Medium or Subscribe to my blog
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>How to Create an End to End Object Detector using Yolov5</title>
      <link>https://mlwhiz.com/blog/2020/08/08/yolov5/</link>
      <pubDate>Tue, 04 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2020/08/08/yolov5/</guid>
      
      
      <media:content type="image/jpeg" medium="image" width="700" height="400"
      url="https://mlwhiz.comhttps://miro.medium.com/max/595/1*QvCHyXdY36jpwoz-2_n9yQ.gif"></media:content>
      

      
      <description>Ultralytics recently launched YOLOv5 amid controversy surrounding its name. For context, the first three versions of YOLO (You Only Look Once) were created by Joseph Redmon. Following this, Alexey Bochkovskiy created YOLOv4 on darknet, which boasted higher Average Precision (AP) and faster results than previous iterations.
Now, Ultralytics has released YOLOv5, with comparable AP and faster inference times than YOLOv4. This has left many asking: is a new version warranted given similar accuracy to YOLOv4?</description>

      <content:encoded>  
        
        <![CDATA[  Ultralytics recently launched YOLOv5 amid controversy surrounding its name. For context, the first three versions of YOLO (You Only Look Once) were created by Joseph Redmon. Following this, Alexey Bochkovskiy created YOLOv4 on darknet, which boasted higher Average Precision (AP) and faster results than previous iterations.
Now, Ultralytics has released YOLOv5, with comparable AP and faster inference times than YOLOv4. This has left many asking: is a new version warranted given similar accuracy to YOLOv4? Whatever the answer may be, it’s definitely a sign of how quickly the detection community is evolving.
Since they first ported YOLOv3, Ultralytics has made it very simple to create and deploy models using Pytorch, so I was eager to try out YOLOv5. As it turns out, Ultralytics has further simplified the process, and the results speak for themselves.
In this article, we’ll create a detection model using YOLOv5, from creating our dataset and annotating it to training and inferencing using their remarkable library. This post focuses on the implementation of YOLOv5, including:
 Creating a toy dataset
 Annotating the image data
 Creating the project structure
 Training YOLOv5
  Creating Custom Dataset You can forgo the first step if you have your image Dataset. Since I don’t have images, I am downloading data from the Open Image Dataset(OID), which is an excellent resource for getting annotated image data that can be used for classification as well as detection. Note that we won’t be using the provided annotations from OID and create our own for the sake of learning.
1. OIDv4 Download Images: To download images from the Open Image dataset, we start by cloning the OIDv4_ToolKit and installing all requirements.
git clone [https://github.com/EscVM/OIDv4_ToolKit](https://github.com/EscVM/OIDv4_ToolKit) cd [OIDv4_ToolKit](https://github.com/EscVM/OIDv4_ToolKit) pip install -r requirements.txt  We can now use the main.py script within this folder to download images as well as labels for multiple classes.
Below I am downloading the data for Cricketball and Football to create our Custom Dataset. That is, we will be creating a dataset with footballs and cricket balls, and the learning task is to detect these balls.
python3 main.py downloader --classes Cricket_ball Football --type_csv all -y --limit 500  The below command creates a directory named “OID” with the following structure:
OID directory structure. We will take only the image files(.jpgs) from here and not the labels as we will annotate manually to create our Custom Dataset, though we can use them if required for a different project.
Before we continue, we will need to copy all the images in the same folder to start our labeling exercise from Scratch. You can choose to do this manually, but this can also be quickly done programmatically using recursive glob function:
import os from glob import glob os.system(&amp;quot;mkdir Images&amp;quot;) images = glob(r&#39;OID/**/*.jpg&#39;, recursive=True) for img in images: os.system(f&amp;quot;cp {img} Images/&amp;quot;)  2. Label Images with HyperLabel We will use a tool called Hyperlabel to label our images. In the past, I have used many tools to create annotations like labelimg, labelbox, etc. but never came across a tool so straightforward and that too open source. The only downside is that you cannot get this tool for Linux and only for Mac and Windows, but I guess that is fine for most of us.
    The best part of this tool is the variety of output formats it provides. Since we want to get the data for Yolo, we will close Yolo Format and export it after being done with our annotations. But you can choose to use this tool if you want to get annotations in JSON format(COCO) or XML format(Pascal VOC) too.
Exporting in Yolo format essentially creates a .txt file for each of our images, which contains the class_id, x_center, y_center, width, and the height of the image. It also creates a file named obj.names , which helps map the class_id to the class name. For example:
       Notice that the coordinates are scaled from 0 to 1 in the annotation file. Also, note that the class_id is 0 for Cricketball and 1 for football as per obj.names file, which starts from 0. There are a few other files we create using this, but we won’t be using them in this example.
Once we have done this, we are mostly set up with our custom dataset and would only need to rearrange some of these files for subsequent training and validation splits later when we train our model. The dataset currently will be a single folder like below containing both the images as well as annotations:
dataset - 0027773a6d54b960.jpg - 0027773a6d54b960.txt - 2bded1f9cb587843.jpg - 2bded1f9cb587843.txt -- --  Setting up the project To train our custom object detector, we will be using Yolov5 from Ultralytics. We start by cloning the repository and installing the dependencies:
# clone repo git clone [https://github.com/ultralytics/yolov5](https://github.com/ultralytics/yolov5) cd yolov5 pip install -U -r requirements.txt  We then start with creating our own folder named training in which we will keep our custom dataset.
!mkdir training  We start by copying our custom dataset folder in this folder and creating the train validation folders using the simple train_val_folder_split.ipynb notebook. This code below just creates some train and validation folders and populates them with images.
import glob, os import random # put your own path here dataset_path = &#39;dataset&#39; # Percentage of images to be used for the validation set percentage_test = 20 !mkdir data !mkdir data/images !mkdir data/labels !mkdir data/images/train !mkdir data/images/valid !mkdir data/labels/train !mkdir data/labels/valid # Populate the folders p = percentage_test/100 for pathAndFilename in glob.iglob(os.path.join(dataset_path, &amp;quot;*.jpg&amp;quot;)): title, ext = os.path.splitext(os.path.basename(pathAndFilename)) if random.random() &amp;lt;=p : os.system(f&amp;quot;cp {dataset_path}/{title}.jpg data/images/valid&amp;quot;) os.system(f&amp;quot;cp {dataset_path}/{title}.txt data/labels/valid&amp;quot;) else: os.system(f&amp;quot;cp {dataset_path}/{title}.jpg data/images/train&amp;quot;) os.system(f&amp;quot;cp {dataset_path}/{title}.txt data/labels/train&amp;quot;)  After running this, your data folder structure should look like below. It should have two directories images and labels.
We now have to add two configuration files to training folder:
1. Dataset.yaml: We create a file “dataset.yaml” that contains the path of training and validation images and also the classes.
# train and val datasets (image directory or *.txt file with image paths) train: training/data/images/train/ val: training/data/images/valid/ # number of classes nc: 2 # class names names: [&#39;Cricketball&#39;, &#39;Football&#39;]  2. Model.yaml: We can use multiple models ranging from small to large while creating our network. For example, yolov5s.yaml file in the yolov5/models directory is the small Yolo model with 7M parameters, while the yolov5x.yaml is the largest Yolo model with 96M Params. For this project, I will use the yolov5l.yaml which has 50M params. We start by copying the file from yolov5/models/yolov5l.yaml to the training folder and changing nc , which is the number of classes to 2 as per our project requirements.
# parameters nc: 2 # change number of classes depth_multiple: 1.0 # model depth multiple width_multiple: 1.0 # layer channel multiple  Train At this point our training folder looks like:
Once we are done with the above steps, we can start training our model. This is as simple as running the below command, where we provide the locations of our config files and various other params. You can check out the different other options in train.py file, but these are the ones I found noteworthy.
# Train yolov5l on custom dataset for 300 epochs $ python train.py --img 640 --batch 16 --epochs 300--data training/dataset.yaml --cfg training/yolov5l.yaml --weights &#39;&#39;  Sometimes you might get an error with PyTorch version 1.5 in that case run on a single GPU using:
# Train yolov5l on custom dataset for 300 epochs $ python train.py --img 640 --batch 16 --epochs 300--data training/dataset.yaml --cfg training/yolov5l.yaml --weights &#39;&#39; --device 0  Once you start the training, you can check whether the training has been set up by checking the automatically created filetrain_batch0.jpg , which contains the training labels for the first batch and test_batch0_gt.jpg which includes the ground truth for test images. This is how they look for me.
      Left: train_batch0.jpg, Right: test_batch0_gt.jpg
Results To see the results for the training at localhost:6006 in your browser using tensorboard, run this command in another terminal tab
tensorboard --logdir=runs  Here are the various validation metrics. These metrics also get saved in a file results.png at the end of the training run.
Predict Ultralytics Yolov5 provides a lot of different ways to check the results on new data.
To detect some images you can simply put them in the folder named inference/images and run the inference using the best weights as per validation AP:
python detect.py --weights weights/best.pt  You can also detect in a video using the detect.py file:
python detect.py --weights weights/best.pt --source inference/videos/messi.mp4 --view-img --output inference/output  Here I specify that I want to see the output using the — view-img flag, and we store the output at the location inference/output. This will create a .mp4 file in this location. It&amp;rsquo;s impressive that the network can see the ball, the speed at which inference is made here, and also the mindblowing accuracy on never observed data.
You can also use the webcam as a source by specifying the &amp;ndash;source as 0. You can check out the various other options in detect.py file.
Conclusion In this post, I talked about how to create a Yolov5 object detection model using a Custom Dataset. I love the way Ultralytics has made it so easy to create an object detection model.
Additionally, the various ways that they have provided to see the model results make it a complete package I have seen in a long time.
If you would like to experiment with the custom dataset yourself, you can download the annotated data on Kaggle and the code at Github.
If you want to know more about various Object Detection techniques, motion estimation, object tracking in video, etc., I would like to recommend this excellent course on Deep Learning in Computer Vision in the Advanced machine learning specialization. If you wish to know more about how the object detection field has evolved over the years, you can also take a look at my last post on Object detection.
Thanks for the read. I am going to be writing more beginner-friendly posts in the future too. Follow me up at Medium or Subscribe to my blog
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>A definitive guide for Setting up a Deep Learning Workstation with Ubuntu</title>
      <link>https://mlwhiz.com/blog/2020/06/06/dlrig/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2020/06/06/dlrig/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/dlrig/main.png"></media:content>
      

      
      <description>Creating my own workstation has been a dream for me if nothing else. I knew the process involved, yet I somehow never got to it.
But this time I just had to do it. So, I found out some free time to create a Deep Learning Rig with a lot of assistance from NVIDIA folks who were pretty helpful. On that note special thanks to Josh Patterson and Michael Cooper.</description>

      <content:encoded>  
        
        <![CDATA[  Creating my own workstation has been a dream for me if nothing else. I knew the process involved, yet I somehow never got to it.
But this time I just had to do it. So, I found out some free time to create a Deep Learning Rig with a lot of assistance from NVIDIA folks who were pretty helpful. On that note special thanks to Josh Patterson and Michael Cooper.
Now, every time I create the whole deep learning setup from an installation viewpoint, I end up facing similar challenges. It’s like running around in circles with all these various dependencies and errors. This time also I had to try many things before the whole configuration came to life without errors.
So this time, I made it a point to document everything while installing all the requirements and their dependencies in my own system.
This post is about setting up your own Linux Ubuntu 18.04 system for deep learning with everything you might need.
If a pre-built deep learning system is preferred, I can recommend Exxact’s line of workstations and servers.
I assume that you have a fresh Ubuntu 18.04 installation. I am taking inspiration from Slav Ivanov’s excellent post in 2017 on creating a Deep Learning box. You can call it the 2020 version for the same post from a setup perspective, but a lot of the things have changed from then, and there are a lot of caveats with specific CUDA versions not supported by Tensorflow and Pytorch.
Starting up Before we do anything with our installation, we need to update our Linux system to the latest packages. We can do this simply by using:
sudo apt-get update sudo apt-get --assume-yes upgrade sudo apt-get --assume-yes install tmux build-essential gcc g&#43;&#43; make binutils sudo apt-get --assume-yes install software-properties-common sudo apt-get --assume-yes install git  The Process So now we have everything set up we want to install the following four things:
 GPU Drivers: Why is your PC not supporting high graphic resolutions? Or how would your graphics cards talk to your python interfaces?
 CUDA: A layer to provide access to the GPU’s instruction set and parallel computation units. In simple words, it allows us a way to write code for GPUs
 CuDNN: a library that provides Primitives for Deep Learning Network
 Pytorch, Tensorflow, and Rapids: higher-level APIs to code Deep Neural Networks
  1. GPU Drivers The first step is to add the latest NVIDIA drivers. You can choose the GPU product type, Linux 64 bit, and download Type as “Linux Long-Lived” for the 18.04 version.
Clicking on search will take you to a downloads page:
From where you can download the driver file NVIDIA-Linux-x86_64–440.44.run and run it using:
chmod &#43;x NVIDIA-Linux-x86_64–440.44.run sudo sh NVIDIA-Linux-x86_64–440.44.run  For you, the file may be named differently, depending on the latest version.
2. CUDA We will now need to install the CUDA toolkit. Somehow the CUDA toolkit 10.2 is still not supported by Pytorch and Tensorflow, so we will go with CUDA Toolkit 10.1, which is supported by both.
Also, the commands on the product page for CUDA 10.1 didn’t work for me and the commands I ended up using are:
sudo apt-key adv --fetch-keys [http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/7fa2af80.pub](http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/7fa2af80.pub) &amp;amp;&amp;amp; echo &amp;quot;deb [https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64](https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64) /&amp;quot; | sudo tee /etc/apt/sources.list.d/cuda.list sudo apt-get update &amp;amp;&amp;amp; sudo apt-get -o Dpkg::Options::=&amp;quot;--force-overwrite&amp;quot; install cuda-10-1 cuda-drivers  The next step is to create the LD_LIBRARY_PATH and append to the PATH variable the path where CUDA got installed. Just run this below command on your terminal.
echo &#39;export PATH=/usr/local/cuda-10.1/bin${PATH:&#43;:${PATH}}&#39; &amp;gt;&amp;gt; ~/.bashrc &amp;amp;&amp;amp; echo &#39;export LD_LIBRARY_PATH=/usr/local/cuda-10.1/lib64${LD_LIBRARY_PATH:&#43;:${LD_LIBRARY_PATH}}&#39; &amp;gt;&amp;gt; ~/.bashrc &amp;amp;&amp;amp; source ~/.bashrc &amp;amp;&amp;amp; sudo ldconfig  After this, one can check if CUDA is installed correctly by using:
nvcc --version  As you can see, the CUDA Version is 10.1 as we wanted. Also, check if you can use the command:
nvidia-smi  For me, it showed an error when I used it the first time, but a simple reboot solved the issue. And both my NVIDIA graphic cards show up in all their awesome glory. Don’t worry that the display says the CUDA version supported is 10.2. I was also confused, but it is just the maximum CUDA version supported by the graphics driver that is shown in nvidia-smi.
3.CuDNN What is the use of all these libraries if we are not going to train neural nets? CuDNN provides various primitives for Deep Learning, which are later used by PyTorch/TensorFlow.
But we first need to get a developer account first to install CuDNN. Once you fill-up the signup form, you will see the screen below. Select the cuDNN version that applies to your CUDA version. For me, the CUDA version is 10.1, so I select the second one.
Once you select the appropriate CuDNN version the screen expands:
For my use case, I needed to download three files for Ubuntu 18.04:
[cuDNN Runtime Library for Ubuntu18.04 (Deb)](https://developer.nvidia.com/compute/machine-learning/cudnn/secure/7.6.5.32/Production/10.1_20191031/Ubuntu18_04-x64/libcudnn7_7.6.5.32-1%2Bcuda10.1_amd64.deb) [cuDNN Developer Library for Ubuntu18.04 (Deb)](https://developer.nvidia.com/compute/machine-learning/cudnn/secure/7.6.5.32/Production/10.1_20191031/Ubuntu18_04-x64/libcudnn7-dev_7.6.5.32-1%2Bcuda10.1_amd64.deb) [cuDNN Code Samples and User Guide for Ubuntu18.04 (Deb)](https://developer.nvidia.com/compute/machine-learning/cudnn/secure/7.6.5.32/Production/10.1_20191031/Ubuntu18_04-x64/libcudnn7-doc_7.6.5.32-1%2Bcuda10.1_amd64.deb)  After downloading these files, you can install using these commands. You can also see the exact commands if anything changes in the future:
# Install the runtime library: sudo dpkg -i libcudnn7_7.6.5.32-1&#43;cuda10.1_amd64.deb #Install the developer library: sudo dpkg -i libcudnn7-dev_7.6.5.32-1&#43;cuda10.1_amd64.deb #Install the code samples and cuDNN User Guide(Optional): sudo dpkg -i libcudnn7-doc_7.6.5.32-1&#43;cuda10.1_amd64.deb  4. Anaconda, Pytorch, Tensorflow, and Rapids And finally, we reach the crux. We will install the software which we will interface with most of the times.
We need to install Python with virtual environments. I have downloaded python3 as it is the most stable version as of now, and it is time to say goodbye to Python 2.7. It was great while it lasted. And we will also install Pytorch and Tensorflow. I prefer them both for specific tasks as applicable.
You can go to the anaconda distribution page and download the package.
Once downloaded you can simply run the shell script:
sudo sh Anaconda3-2019.10-Linux-x86_64.sh  You will also need to run these commands on your shell to add some commands to your ~/.bashrc file, and update the conda distribution with the latest libraries versions.
cat &amp;gt;&amp;gt; ~/.bashrc &amp;lt;&amp;lt; &#39;EOF&#39; export PATH=$HOME/anaconda3/bin:${PATH} EOF source .bashrc conda upgrade -y --all  The next step is creating a new environment for your deep learning pursuits or using an existing one. I created a new Conda environment using:
conda create --name py37  Here py37 is the name we provide to this new conda environment. You can activate this conda environment using:
conda activate py37  You should now be able to see something like:
Notice the py37 at the start of command in terminal
We can now add all our required packages to this environment using pip or conda. The latest version 1.3, as seen from the pytorch site, is not yet available for CUDA 10.2, as I already mentioned, so we are in luck with CUDA 10.1. Also, we will need to specify the version of TensorFlow as 2.1.0, as this version was built using 10.1 CUDA.
I also install RAPIDS, which is a library to get your various data science workloads to GPUs. Why use GPUs only for deep learning and not for Data processing? You can get the command to install rapids from the rapids release selector:
sudo apt install python3-pip conda install -c rapidsai -c nvidia -c conda-forge -c defaults rapids=0.11 python=3.7 cudatoolkit=10.1 pip install torchvision  Since PyTorch installation interfered with TensorFlow, I installed TensorFlow in another environment.
conda create --name tf conda activate tf pip install --upgrade tensorflow  Now we can check if the TF and Pytorch installations are correctly done by using the below commands in their own environments:
# Should print True python3 -c &amp;quot;import tensorflow as tf; print(tf.test.is_gpu_available())&amp;quot; # should print cuda python3 -c &amp;quot;import torch; print(torch.device(&#39;cuda&#39; if torch.cuda.is_available() else &#39;cpu&#39;))&amp;quot;  If the install is showing some errors for TensorFlow or the GPU test is failing, you might want to add these two additional lines at the end of your bashrc file and restart the terminal:
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/extras/CUPTI/lib64:/usr/local/cuda/lib64 export CUDA_HOME=/usr/local/cuda  You might also want to install jupyter lab or jupyter notebook. Thanks to the developers, the process is as easy as just running jupyter labor jupyter notebook in your terminal, whichever you do prefer. I personally like notebook better without all the unnecessary clutter.
Conclusion In this post, I talked about all the software you are going to need to install in your deep learning rig without hassle.
You might still need some help and face some problems for which my best advice would be to check out the different NVIDIA and Stack Overflow forums.
So we have got our deep learning rig setup, and its time for some tests now. In the next few posts, I am going to do some benchmarking on the GPUs and will try to write more on various deep Learning libraries one can include in their workflow. So stay tuned.
Continue Learning If you want to learn more about Deep Learning, here is an excellent course. You can start for free with the 7-day Free Trial.
Thanks for the read. I am going to be writing more beginner-friendly posts in the future too. Follow me up at Medium or Subscribe to my blog
Also, a small disclaimer — There might be some affiliate links in this post to relevant resources, as sharing knowledge is never a bad idea.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>End to End Pipeline for setting up Multiclass Image Classification for Data Scientists</title>
      <link>https://mlwhiz.com/blog/2020/06/06/multiclass_image_classification_pytorch/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2020/06/06/multiclass_image_classification_pytorch/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/multiclass_image_classification_pytorch/main.png"></media:content>
      

      
      <description>Have you ever wondered how Facebook takes care of the abusive and inappropriate images shared by some of its users? Or how Facebook’s tagging feature works? Or how Google Lens recognizes products through images?
All of the above are examples of image classification in different settings. Multiclass image classification is a common task in computer vision, where we categorize an image into three or more classes.
In the past, I always used Keras for computer vision projects.</description>

      <content:encoded>  
        
        <![CDATA[  Have you ever wondered how Facebook takes care of the abusive and inappropriate images shared by some of its users? Or how Facebook’s tagging feature works? Or how Google Lens recognizes products through images?
All of the above are examples of image classification in different settings. Multiclass image classification is a common task in computer vision, where we categorize an image into three or more classes.
In the past, I always used Keras for computer vision projects. However, recently when the opportunity to work on multiclass image classification presented itself, I decided to use PyTorch. I have already moved from Keras to PyTorch for all NLP tasks, so why not vision, too?
 PyTorch is powerful, and I also like its more pythonic structure.
 In this post, we’ll create an end to end pipeline for image multiclass classification using Pytorch.This will include training the model, putting the model’s results in a form that can be shown to business partners, and functions to help deploy the model easily. As an added feature we will look at Test Time Augmentation using Pytorch also.
But before we learn how to do image classification, let’s first look at transfer learning, the most common method for dealing with such problems.
What is Transfer Learning? Transfer learning is the process of repurposing knowledge from one task to another. From a modelling perspective, this means using a model trained on one dataset and fine-tuning it for use with another. But why does it work?
Let’s start with some background. Every year the visual recognition community comes together for a very particular challenge: The Imagenet Challenge. The task in this challenge is to classify 1,000,000 images into 1,000 categories.
This challenge has already resulted in researchers training big convolutional deep learning models. The results have included great models like Resnet50 and Inception.
But, what does it mean to train a neural model? Essentially, it means the researchers have learned the weights for a neural network after training the model on a million images.
So, what if we could get those weights? We could then use them and load them into our own neural networks model to predict on the test dataset, right? Actually, we can go even further than that; we can add an extra layer on top of the neural network these researchers have prepared to classify our own dataset.
 While the exact workings of these complex models is still a mystery, we do know that the lower convolutional layers capture low-level image features like edges and gradients. In comparison, higher convolutional layers capture more and more intricate details, such as body parts, faces, and other compositional features.
 Source: Visualizing and Understanding Convolutional Networks. You can see how the first few layers capture basic shapes, and the shapes become more and more complex in the later layers.
In the example above from ZFNet (a variant of Alexnet), one of the first convolutional neural networks to achieve success on the Imagenet task, you can see how the lower layers capture lines and edges, and the later layers capture more complex features. The final fully-connected layers are generally assumed to capture information that is relevant for solving the respective task, e.g. ZFNet’s fully-connected layers indicate which features are relevant for classifying an image into one of 1,000 object categories.
For a new vision task, it is possible for us to simply use the off-the-shelf features of a state-of-the-art CNN pre-trained on ImageNet, and train a new model on these extracted features.
The intuition behind this idea is that a model trained to recognize animals might also be used to recognize cats vs dogs. In our case, &amp;gt; # a model that has been trained on 1000 different categories has seen a lot of real-world information, and we can use this information to create our own custom classifier.
So that’s the theory and intuition. How do we get it to actually work? Let’s look at some code. You can find the complete code for this post on Github.
Data Exploration We will start with the Boat Dataset from Kaggle to understand the multiclass image classification problem. This dataset contains about 1,500 pictures of boats of different types: buoys, cruise ships, ferry boats, freight boats, gondolas, inflatable boats, kayaks, paper boats, and sailboats. Our goal is to create a model that looks at a boat image and classifies it into the correct category.
Here’s a sample of images from the dataset:
And here are the category counts:
Since the categories “freight boats”, “inflatable boats” , and “boats” don’t have a lot of images; we will be removing these categories when we train our model.
Creating the required Directory Structure Before we can go through with training our deep learning models, we need to create the required directory structure for our images. Right now, our data directory structure looks like:
images sailboat kayak . .  We need our images to be contained in 3 folders train, val and test. We will then train on the images in train dataset, validate on the ones in the val dataset and finally test them on images in the test dataset.
data train sailboat kayak . . val sailboat kayak . . test sailboat kayak . .  You might have your data in a different format, but I have found that apart from the usual libraries, the glob.glob and os.system functions are very helpful. Here you can find the complete data preparation code. Now let’s take a quick look at some of the not-so-used libraries that I found useful while doing data prep.
What is glob.glob? Simply, glob lets you get names of files or folders in a directory using a regex. For example, you can do something like:
from glob import glob categories = glob(“images/*”) print(categories) ------------------------------------------------------------------ [&#39;images/kayak&#39;, &#39;images/boats&#39;, &#39;images/gondola&#39;, &#39;images/sailboat&#39;, &#39;images/inflatable boat&#39;, &#39;images/paper boat&#39;, &#39;images/buoy&#39;, &#39;images/cruise ship&#39;, &#39;images/freight boat&#39;, &#39;images/ferry boat&#39;]  What is os.system? os.system is a function in os library which lets you run any command-line function in python itself. I generally use it to run Linux functions, but it can also be used to run R scripts within python as shown here. For example, I use it in my data preparation to copy files from one directory to another after getting the information from a pandas data frame. I also use f string formatting.
import os for i,row in fulldf.iterrows(): # Boat category cat = row[&#39;category&#39;] # section is train,val or test section = row[&#39;type&#39;] # input filepath to copy ipath = row[&#39;filepath&#39;] # output filepath to paste opath = ipath.replace(f&amp;quot;images/&amp;quot;,f&amp;quot;data/{section}/&amp;quot;) # running the cp command os.system(f&amp;quot;cp &#39;{ipath}&#39; &#39;{opath}&#39;&amp;quot;)  Now since we have our data in the required folder structure, we can move on to more exciting parts.
Data Preprocessing Transforms: 1. Imagenet Preprocessing
In order to use our images with a network trained on the Imagenet dataset, we need to preprocess our images in the same way as the Imagenet network. For that, we need to rescale the images to 224×224 and normalize them as per Imagenet standards. We can use the torchvision transforms library to do that. Here we take a CenterCrop of 224×224 and normalize as per Imagenet standards. The operations defined below happen sequentially. You can find a list of all transforms provided by PyTorch here.
transforms.Compose([ transforms.CenterCrop(size=224), transforms.ToTensor(), transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]) ])  2. Data Augmentations
We can do a lot more preprocessing for data augmentations. Neural networks work better with a lot of data. Data augmentation is a strategy which we use at training time to increase the amount of data we have.
For example, we can flip the image of a boat horizontally, and it will still be a boat. Or we can randomly crop images or add color jitters. Here is the image transforms dictionary I have used that applies to both the Imagenet preprocessing as well as augmentations. This dictionary contains the various transforms we have for the train, test and validation data as used in this great post. As you’d expect, we don’t apply the horizontal flips or other data augmentation transforms to the test data and validation data because we don’t want to get predictions on an augmented image.
# Image transformations image_transforms = { # Train uses data augmentation &#39;train&#39;: transforms.Compose([ transforms.RandomResizedCrop(size=256, scale=(0.8, 1.0)), transforms.RandomRotation(degrees=15), transforms.ColorJitter(), transforms.RandomHorizontalFlip(), transforms.CenterCrop(size=224), # Image net standards transforms.ToTensor(), transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]) # Imagenet standards ]), # Validation does not use augmentation &#39;valid&#39;: transforms.Compose([ transforms.Resize(size=256), transforms.CenterCrop(size=224), transforms.ToTensor(), transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]) ]), # Test does not use augmentation &#39;test&#39;: transforms.Compose([ transforms.Resize(size=256), transforms.CenterCrop(size=224), transforms.ToTensor(), transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]) ]), }  Here is an example of the train transforms applied to an image in the training dataset. Not only do we get a lot of different images from a single image, but it also helps our network become invariant to the object orientation.
ex_img = Image.open(&#39;/home/rahul/projects/compvisblog/data/train/cruise ship/cruise-ship-oasis-of-the-seas-boat-water-482183.jpg&#39;) t = image_transforms[&#39;train&#39;] plt.figure(figsize=(24, 24)) for i in range(16): ax = plt.subplot(4, 4, i &#43; 1) _ = imshow_tensor(t(ex_img), ax=ax) plt.tight_layout()  DataLoaders The next step is to provide the training, validation, and test dataset locations to PyTorch. We can do this by using the PyTorch datasets and DataLoader class. This part of the code will mostly remain the same if we have our data in the required directory structures.
# Datasets from folders traindir = &amp;quot;data/train&amp;quot; validdir = &amp;quot;data/val&amp;quot; testdir = &amp;quot;data/test&amp;quot; data = { &#39;train&#39;: datasets.ImageFolder(root=traindir, transform=image_transforms[&#39;train&#39;]), &#39;valid&#39;: datasets.ImageFolder(root=validdir, transform=image_transforms[&#39;valid&#39;]), &#39;test&#39;: datasets.ImageFolder(root=testdir, transform=image_transforms[&#39;test&#39;]) } # Dataloader iterators, make sure to shuffle dataloaders = { &#39;train&#39;: DataLoader(data[&#39;train&#39;], batch_size=batch_size, shuffle=True,num_workers=10), &#39;val&#39;: DataLoader(data[&#39;valid&#39;], batch_size=batch_size, shuffle=True,num_workers=10), &#39;test&#39;: DataLoader(data[&#39;test&#39;], batch_size=batch_size, shuffle=True,num_workers=10) }  These dataloaders help us to iterate through the dataset. For example, we will use the dataloader below in our model training. The data variable will contain data in the form (batch_size, color_channels, height, width) while the target is of shape (batch_size) and hold the label information.
train_loader = dataloaders[&#39;train&#39;] for ii, (data, target) in enumerate(train_loader):  Modeling 1. Create the model using a pre-trained model Right now these following pre-trained models are available to use in the torchvision library:
 AlexNet
 VGG
 ResNet
 SqueezeNet
 DenseNet
 Inception v3
 GoogLeNet
 ShuffleNet v2
 MobileNet v2
 ResNeXt
 Wide ResNet
 MNASNet
  Here I will be using resnet50 on our dataset, but you can effectively use any other model too as per your choice.
from torchvision import models model = models.resnet50(pretrained=True)  We start by freezing our model weights since we don’t want to change the weights for the renet50 models.
# Freeze model weights for param in model.parameters(): param.requires_grad = False  The next thing we need to do is to replace the linear classification layer in the model by our custom classifier. I have found that to do this, it is better first to see the model structure to determine what is the final linear layer. We can do this simply by printing the model object:
print(model) ------------------------------------------------------------------ ResNet( (conv1): Conv2d(3, 64, kernel_size=(7, 7), stride=(2, 2), padding=(3, 3), bias=False) (bn1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace=True) . . . . (conv3): Conv2d(512, 2048, kernel_size=(1, 1), stride=(1, 1), bias=False) (bn3): BatchNorm2d(2048, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (relu): ReLU(inplace=True) ) ) (avgpool): AdaptiveAvgPool2d(output_size=(1, 1)) **(fc): Linear(in_features=2048, out_features=1000, bias=True)** )  Here we find that the final linear layer that takes the input from the convolutional layers is named fc
We can now simply replace the fc layer using our custom neural network. This neural network takes input from the previous layer to fc and gives the log softmax output of shape (batch_size x n_classes).
n_inputs = model.fc.in_features model.fc = nn.Sequential( nn.Linear(n_inputs, 256), nn.ReLU(), nn.Dropout(0.4), nn.Linear(256, n_classes), nn.LogSoftmax(dim=1))  Please note that the new layers added now are fully trainable by default.
2. Load the model on GPU We can use a single GPU or multiple GPU(if we have them) using DataParallel from PyTorch. Here is what we can use to detect the GPU as well as the number of GPUs to load the model on GPU. Right now I am training my models on dual NVIDIA Titan RTX GPUs.
# Whether to train on a gpu train_on_gpu = cuda.is_available() print(f&#39;Train on gpu: {train_on_gpu}&#39;) # Number of gpus if train_on_gpu: gpu_count = cuda.device_count() print(f&#39;{gpu_count} gpus detected.&#39;) if gpu_count &amp;gt; 1: multi_gpu = True else: multi_gpu = False if train_on_gpu: model = model.to(&#39;cuda&#39;) if multi_gpu: model = nn.DataParallel(model)  3. Define criterion and optimizers One of the most important things to notice when you are training any model is the choice of loss-function and the optimizer used. Here we want to use categorical cross-entropy as we have got a multiclass classification problem and the Adam optimizer, which is the most commonly used optimizer. But since we are applying a LogSoftmax operation on the output of our model, we will be using the NLL loss.
from torch import optim criteration = nn.NLLLoss() optimizer = optim.Adam(model.parameters())  4. Training the model Given below is the full code used to train the model. It might look pretty big on its own, but essentially what we are doing is as follows:
 Start running epochs. In each epoch-
 Set the model mode to train using model.train().
 Loop through the data using the train dataloader.
 Load your data to the GPU using the data, target = data.cuda(), target.cuda() command
 Set the existing gradients in the optimizer to zero using optimizer.zero_grad()
 Run the forward pass through the batch using output = model(data)
 Compute loss using loss = criterion(output, target)
 Backpropagate the losses through the network using loss.backward()
 Take an optimizer step to change the weights in the whole network using optimizer.step()
 All the other steps in the training loop are just to maintain the history and calculate accuracy.
 Set the model mode to eval using model.eval().
 Get predictions for the validation data using valid_loader and calculate valid_loss and valid_acc
 Print the validation loss and validation accuracy results every print_every epoch.
 Save the best model based on validation loss.
 Early Stopping: If the cross-validation loss doesn’t improve for max_epochs_stop stop the training and load the best available model with the minimum validation loss.
  def train(model, criterion, optimizer, train_loader, valid_loader, save_file_name, max_epochs_stop=3, n_epochs=20, print_every=1): &amp;#34;&amp;#34;&amp;#34;Train a PyTorch Model Params -------- model (PyTorch model): cnn to train criterion (PyTorch loss): objective to minimize optimizer (PyTorch optimizier): optimizer to compute gradients of model parameters train_loader (PyTorch dataloader): training dataloader to iterate through valid_loader (PyTorch dataloader): validation dataloader used for early stopping save_file_name (str ending in &amp;#39;.pt&amp;#39;): file path to save the model state dict max_epochs_stop (int): maximum number of epochs with no improvement in validation loss for early stopping n_epochs (int): maximum number of training epochs print_every (int): frequency of epochs to print training stats Returns -------- model (PyTorch model): trained cnn with best weights history (DataFrame): history of train and validation loss and accuracy &amp;#34;&amp;#34;&amp;#34; # Early stopping intialization epochs_no_improve = 0 valid_loss_min = np.Inf valid_max_acc = 0 history = [] # Number of epochs already trained (if using loaded in model weights) try: print(f&amp;#39;Model has been trained for: {model.epochs} epochs.\n&amp;#39;) except: model.epochs = 0 print(f&amp;#39;Starting Training from Scratch.\n&amp;#39;) overall_start = timer() # Main loop for epoch in range(n_epochs): # keep track of training and validation loss each epoch train_loss = 0.0 valid_loss = 0.0 train_acc = 0 valid_acc = 0 # Set to training model.train() start = timer() # Training loop for ii, (data, target) in enumerate(train_loader): # Tensors to gpu if train_on_gpu: data, target = data.cuda(), target.cuda() # Clear gradients optimizer.zero_grad() # Predicted outputs are log probabilities output = model(data) # Loss and backpropagation of gradients loss = criterion(output, target) loss.backward() # Update the parameters optimizer.step() # Track train loss by multiplying average loss by number of examples in batch train_loss &#43;= loss.item() * data.size(0) # Calculate accuracy by finding max log probability _, pred = torch.max(output, dim=1) correct_tensor = pred.eq(target.data.view_as(pred)) # Need to convert correct tensor from int to float to average accuracy = torch.mean(correct_tensor.type(torch.FloatTensor)) # Multiply average accuracy times the number of examples in batch train_acc &#43;= accuracy.item() * data.size(0) # Track training progress print( f&amp;#39;Epoch: {epoch}\t{100 * (ii &#43; 1) / len(train_loader):.2f}% complete. {timer() - start:.2f} seconds elapsed in epoch.&amp;#39;, end=&amp;#39;\r&amp;#39;) # After training loops ends, start validation else: model.epochs &#43;= 1 # Don&amp;#39;t need to keep track of gradients with torch.no_grad(): # Set to evaluation mode model.eval() # Validation loop for data, target in valid_loader: # Tensors to gpu if train_on_gpu: data, target = data.cuda(), target.cuda() # Forward pass output = model(data) # Validation loss loss = criterion(output, target) # Multiply average loss times the number of examples in batch valid_loss &#43;= loss.item() * data.size(0) # Calculate validation accuracy _, pred = torch.max(output, dim=1) correct_tensor = pred.eq(target.data.view_as(pred)) accuracy = torch.mean( correct_tensor.type(torch.FloatTensor)) # Multiply average accuracy times the number of examples valid_acc &#43;= accuracy.item() * data.size(0) # Calculate average losses train_loss = train_loss / len(train_loader.dataset) valid_loss = valid_loss / len(valid_loader.dataset) # Calculate average accuracy train_acc = train_acc / len(train_loader.dataset) valid_acc = valid_acc / len(valid_loader.dataset) history.append([train_loss, valid_loss, train_acc, valid_acc]) # Print training and validation results if (epoch &#43; 1) % print_every == 0: print( f&amp;#39;\nEpoch: {epoch} \tTraining Loss: {train_loss:.4f} \tValidation Loss: {valid_loss:.4f}&amp;#39; ) print( f&amp;#39;\t\tTraining Accuracy: {100 * train_acc:.2f}%\tValidation Accuracy: {100 * valid_acc:.2f}%&amp;#39; ) # Save the model if validation loss decreases if valid_loss &amp;lt; valid_loss_min: # Save model torch.save(model.state_dict(), save_file_name) # Track improvement epochs_no_improve = 0 valid_loss_min = valid_loss valid_best_acc = valid_acc best_epoch = epoch # Otherwise increment count of epochs with no improvement else: epochs_no_improve &#43;= 1 # Trigger early stopping if epochs_no_improve &amp;gt;= max_epochs_stop: print( f&amp;#39;\nEarly Stopping! Total epochs: {epoch}. Best epoch: {best_epoch} with loss: {valid_loss_min:.2f} and acc: {100 * valid_acc:.2f}%&amp;#39; ) total_time = timer() - overall_start print( f&amp;#39;{total_time:.2f} total seconds elapsed. {total_time / (epoch&#43;1):.2f} seconds per epoch.&amp;#39; ) # Load the best state dict model.load_state_dict(torch.load(save_file_name)) # Attach the optimizer model.optimizer = optimizer # Format history history = pd.DataFrame( history, columns=[ &amp;#39;train_loss&amp;#39;, &amp;#39;valid_loss&amp;#39;, &amp;#39;train_acc&amp;#39;, &amp;#39;valid_acc&amp;#39; ]) return model, history # Attach the optimizer model.optimizer = optimizer # Record overall time and print out stats total_time = timer() - overall_start print( f&amp;#39;\nBest epoch: {best_epoch} with loss: {valid_loss_min:.2f} and acc: {100 * valid_acc:.2f}%&amp;#39; ) print( f&amp;#39;{total_time:.2f} total seconds elapsed. {total_time / (epoch):.2f} seconds per epoch.&amp;#39; ) # Format history history = pd.DataFrame( history, columns=[&amp;#39;train_loss&amp;#39;, &amp;#39;valid_loss&amp;#39;, &amp;#39;train_acc&amp;#39;, &amp;#39;valid_acc&amp;#39;]) return model, history # Running the model model, history = train( model, criterion, optimizer, dataloaders[&amp;#39;train&amp;#39;], dataloaders[&amp;#39;val&amp;#39;], save_file_name=save_file_name, max_epochs_stop=3, n_epochs=100, print_every=1) Here is the output from running the above code. Just showing the last few epochs. The validation accuracy started at ~55% in the first epoch, and we ended up with a validation accuracy of ~90%.
And here are the training curves showing the loss and accuracy metrics:
Inference and Model Results We want our results in different ways to use our model. For one, we require test accuracies and confusion matrices. All of the code for creating these results is in the code notebook.
1. Test Results The overall accuracy of the test model is:
Overall Accuracy: 88.65 %  Here is the confusion matrix for results on the test dataset.
We can also look at the category wise accuracies. I have also added the train counts to see the results from a new perspective.
2. Visualizing Predictions for Single Image For deployment purposes, it helps to be able to get predictions for a single image. You can get the code from the notebook.
3. Visualizing Predictions for a Category We can also see the category wise results for debugging purposes and presentations.
4. Test results with Test Time Augmentation We can also do test time augmentation to increase our test accuracy. Here I am using a new test data loader and transforms:
# Image transformations tta_random_image_transforms = transforms.Compose([ transforms.RandomResizedCrop(size=256, scale=(0.8, 1.0)), transforms.RandomRotation(degrees=15), transforms.ColorJitter(), transforms.RandomHorizontalFlip(), transforms.CenterCrop(size=224), # Image net standards transforms.ToTensor(), transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]) # Imagenet standards ]) # Datasets from folders ttadata = { &#39;test&#39;: datasets.ImageFolder(root=testdir, transform=tta_random_image_transforms) } # Dataloader iterators ttadataloader = { &#39;test&#39;: DataLoader(ttadata[&#39;test&#39;], batch_size=512, shuffle=False,num_workers=10) }  We can then get the predictions on the test set using the below function:
def tta_preds_n_averaged(model, test_loader,n=5): &amp;#34;&amp;#34;&amp;#34;Returns the TTA preds from a trained PyTorch model Params -------- model (PyTorch model): trained cnn for inference test_loader (PyTorch DataLoader): test dataloader Returns -------- results (array): results for each category &amp;#34;&amp;#34;&amp;#34; # Hold results results = np.zeros((len(test_loader.dataset), n_classes)) bs = test_loader.batch_size model.eval() with torch.no_grad(): #aug loop: for _ in range(n): # Testing loop tmp_pred = np.zeros((len(test_loader.dataset), n_classes)) for i,(data, targets) in enumerate(tqdm.tqdm(test_loader)): # Tensors to gpu if train_on_gpu: data, targets = data.to(&amp;#39;cuda&amp;#39;), targets.to(&amp;#39;cuda&amp;#39;) # Raw model output out = model(data) tmp_pred[i*bs:(i&#43;1)*bs] = np.array(out.cpu()) results&#43;=tmp_pred return results/n In the function above, I am applying the tta_random_image_transforms to each image 5 times before getting its prediction. The final prediction is the average of all five predictions. When we use TTA over the whole test dataset, we noticed that the accuracy increased by around 1%
TTA Accuracy: 89.71%  Also, here is the results for TTA compared to normal results category wise:
In this small dataset, the TTA might not seem to add much value, but I have noticed that it adds value with big datasets.
Conclusion In this post, I talked about the end to end pipeline for working on a multiclass image classification project using PyTorch. We worked on creating some readymade code to train a model using transfer learning, visualize the results, use Test time augmentation, and got predictions for a single image so that we can deploy our model when needed using any tool like Streamlit.
You can find the complete code for this post on Github.
If you would like to learn more about Image Classification and Convolutional Neural Networks take a look at the Deep Learning Specialization from Andrew Ng. Also, to learn more about PyTorch and start from the basics, you can take a look at the Deep Neural Networks with PyTorch course offered by IBM.
Thanks for the read. I am going to be writing more beginner-friendly posts in the future too. Follow me up at Medium or Subscribe to my blog.
Also, a small disclaimer — There might be some affiliate links in this post to relevant resources, as sharing knowledge is never a bad idea.
This post was first published here.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>How to run your ML model Predictions 50 times faster?</title>
      <link>https://mlwhiz.com/blog/2020/06/06/hummingbird_faster_ml_preds/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2020/06/06/hummingbird_faster_ml_preds/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/hummingbird_faster_ml_preds/main.png"></media:content>
      

      
      <description>With the advent of so many computing and serving frameworks, it is getting stressful day by day for the developers to put a model into production. If the question of what model performs best on my data was not enough, now the question is what framework to choose for serving a model trained with Sklearn or LightGBM or PyTorch. And new frameworks are being added as each day passes.</description>

      <content:encoded>  
        
        <![CDATA[  With the advent of so many computing and serving frameworks, it is getting stressful day by day for the developers to put a model into production. If the question of what model performs best on my data was not enough, now the question is what framework to choose for serving a model trained with Sklearn or LightGBM or PyTorch. And new frameworks are being added as each day passes.
So is it imperative for a Data Scientist to learn a different framework because a Data Engineer is comfortable with that, or conversely, does a Data Engineer need to learn a new platform that the Data Scientist favors?
Add to that the factor of speed and performance that these various frameworks offer, and the question suddenly becomes even more complicated.
So, I was pleasantly surprised when I came across the Hummingbird project on Github recently, which aims to answer this question or at least takes a positive step in the right direction.
So, What is HummingBird? As per their documentation:
 Hummingbird is a library for compiling trained traditional ML models into tensor computations. Hummingbird allows users to seamlessly leverage neural network frameworks (such as PyTorch) to accelerate traditional ML models. Thanks to Hummingbird, users can benefit from:
(1) all the current and future optimizations implemented in neural network frameworks;
(2) native hardware acceleration;
(3) having a unique platform to support both traditional and neural network models, and have all of this
(4) without having to re-engineer their models.
 Put even more simply; you can now convert your models written in Scikit-learn or Xgboost or LightGBM into PyTorch models and gain the performance benefits of Pytorch while inferencing.
As of right now, Here is the list of operators Hummingbird supports with more on the way.
A Simple Example We can start by installing Hummingbird, which is as simple as:
pip install hummingbird-ml  To use hummingbird, I will begin with a minimal example on a small random classification Dataset. We start by creating a sample dataset with 100,000 rows and using a RandomForestClassifier on top of that.
import numpy as np from sklearn.ensemble import RandomForestClassifier from hummingbird.ml import convert # Create some random data for binary classification from sklearn import datasets X, y = datasets.make_classification(n_samples=100000, n_features=28) # Create and train a model (scikit-learn RandomForestClassifier in this case) skl_model = RandomForestClassifier(n_estimators=1000, max_depth=10) skl_model.fit(X, y)  What hummingbird helps us with is to convert this sklearn model into a PyTorch model by just using the simple command:
# Using Hummingbird to convert the model to PyTorch model = convert(skl_model, &#39;pytorch&#39;) print(type(model)) -------------------------------------------------------- hummingbird.ml._container.PyTorchBackendModel  We can now load our new Pytorch model to GPU using:
model.to(&#39;cuda&#39;)  This is great. So, we can convert from sklearn model to a PyTorch model, which should run faster on a GPU. But by how much?
Let us see a simple performance comparison.
Comparison 1. Batch Mode We will start by using the sklearn model to predict the whole train dataset and check out the time it takes.
We can do the same with our new PyTorch model:
That is a speedup of 9580&amp;frasl;195 ~ 50x.
2. Single Example Prediction We predict a single example here to see how the model would perform in a real-time setting. The sklearn model:
vs. Pytorch model
That is again a speedup of 79.6&amp;frasl;1.6 ~50x.
Small Caveat A small caveat I experienced is that the predictions from the sklearn model and the hummingbird PyTorch model were not exactly the same.
For example, here are the predictions I got from both models:
Yes, sometimes, they differ in the 7th digit, which might be a function of the conversion process. I think that it won’t change the final 1 or 0 predictions much. We can also check that:
scikit_1_0 = scikit_preds[:,1]&amp;gt;0.5 hb_1_0 = hb_preds[:,1]&amp;gt;0.5 print(len(scikit_1_0) == sum(scikit_1_0==hb_1_0)) ------------------------------------------------------------ True  So, for this case, both the models exactly gave the same 1 or 0 predictions for the whole dataset of 100,000 rows.
So I guess it is okay.
Conclusion The developers at Microsoft are still working on adding many more operators which range from models to feature engineering like MinMaxScaler or LabelEncoder to the code, and I am hopeful that they will further develop and improve this project. Here is the roadmap to development if you are interested.
Although Hummingbird is not perfect yet, it is the first system able to run classical ML inference DNN frameworks and proves them mature enough to be used as generic compilers. I will try to include it in my development workflow when it comes to making predictions at high throughput or latency.
You can find the code for this post as well as all my posts at my GitHub repository.
Continue Learning If you want to learn more about building and putting a Machine Learning model in production, this course on AWS for implementing Machine Learning applications promises just that.
Thanks for the read. I am going to be writing more beginner-friendly posts in the future too. Follow me up at Medium or Subscribe to my blog
Also, a small disclaimer — There might be some affiliate links in this post to relevant resources, as sharing knowledge is never a bad idea.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Stop Worrying and Create your Deep Learning Server in 30 minutes</title>
      <link>https://mlwhiz.com/blog/2020/05/25/dls/</link>
      <pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2020/05/25/dls/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/dls/main.png"></media:content>
      

      
      <description>I have found myself creating a Deep Learning Machine time and time again whenever I start a new project.
You start with installing Anaconda and end up creating different environments for Pytorch and Tensorflow, so they don’t interfere. And in the middle of it, you inevitably end up messing up and starting from scratch. And this often happens multiple times.
It is not just a massive waste of time; it is also mighty(trying to avoid profanity here) irritating.</description>

      <content:encoded>  
        
        <![CDATA[  I have found myself creating a Deep Learning Machine time and time again whenever I start a new project.
You start with installing Anaconda and end up creating different environments for Pytorch and Tensorflow, so they don’t interfere. And in the middle of it, you inevitably end up messing up and starting from scratch. And this often happens multiple times.
It is not just a massive waste of time; it is also mighty(trying to avoid profanity here) irritating. Going through all those Stack Overflow threads. Often wondering what has gone wrong.
So is there a way to do this more efficiently?
It turns out there is. In this blog, I will try to set up a deep learning server on EC2 with minimal effort so that I could focus on more important things.
This blog consists explicitly of two parts:
 Setting up an Amazon EC2 Machine with preinstalled deep learning libraries.
 Setting Up Jupyter Notebook using TMUX and SSH tunneling.
  Don’t worry; it’s not as difficult as it sounds. Just follow the steps and click Next.
Setting up Amazon EC2 Machine I am assuming that you have an AWS account, and you have access to the AWS Console. If not, you might need to sign up for an Amazon AWS account.
 First of all, we need to go to the Services tab to access the EC2 dashboard.   On the EC2 Dashboard, you can start by creating your instance.   Amazon provides Community AMIs(Amazon Machine Image) with Deep Learning software preinstalled. To access these AMIs, you need to look in the community AMIs and search for “Ubuntu Deep Learning” in the Search Tab. You can choose any other Linux flavor, but I have found Ubuntu to be most useful for my Deep Learning needs. In the present setup, I will use The Deep Learning AMI (Ubuntu 18.04) Version 27.0   Once you select an AMI, you can select the Instance Type. It is here you specify the number of CPUs, Memory, and GPUs you will require in your system. Amazon provides a lot of options to choose from based on one’s individual needs. You can filter for GPU instances using the “Filter by” filter.  In this tutorial, I have gone with p2.xlarge instance, which provides NVIDIA K80 GPU with 2,496 parallel processing cores and 12GiB of GPU memory. To know about different instance types, you can look at the documentation here and the pricing here.
 You can change the storage that is attached to the machine in the 4th step. It is okay if you don’t add storage upfront, as you can also do this later. I change the storage from 90 GB to 500 GB as most of the deep learning needs will require proper storage.   That’s all, and you can Launch the Instance after going to the Final Review instance settings Screen. Once you click on Launch, you will see this screen. Just type in any key name in the Key Pair Name and click on “Download key pair”. Your key will be downloaded to your machine by the name you provided. For me, it got saved as “aws_key.pem”. Once you do that, you can click on “Launch Instances”.  Keep this key pair safe as this will be required whenever you want to login to your instance.
 You can now click on “View Instances” on the next page to see your instance. This is how your instance will look like:   To connect to your instance, Just open a terminal window in your Local machine and browse to the folder where you have kept your key pair file and modify some permissions.
chmod 400 aws_key.pem
  Once you do that, you will be able to connect to your instance by SSHing. The SSH command will be of the form:
ssh -i &amp;quot;aws_key.pem&amp;quot; ubuntu@&amp;lt;Your PublicDNS(IPv4)&amp;gt;  For me, the command was:
ssh -i &amp;quot;aws_key.pem&amp;quot; ubuntu@ec2-54-202-223-197.us-west-2.compute.amazonaws.com  Also, keep in mind that the Public DNS might change once you shut down your instance.
 You have already got your machine up and ready. This machine contains different environments that have various libraries you might need. This particular machine has MXNet, Tensorflow, and Pytorch with different versions of python. And the best thing is that we get all this preinstalled, so it just works out of the box.  Setting Up Jupyter Notebook But there are still a few things you will require to use your machine fully. One of them being Jupyter Notebooks. To set up Jupyter Notebooks with your Machine, I recommend using TMUX and tunneling. Let us go through setting up the Jupyter notebook step by step.
1. Using TMUX to run Jupyter Notebook We will first use TMUX to run the Jupyter notebook on our instance. We mainly use this so that our notebook still runs even if the terminal connection gets lost.
To do this, you will need to create a new TMUX session using:
tmux new -s StreamSession  Once you do that, you will see a new screen with a green border at the bottom. You can start your Jupyter Notebook in this machine using the usual jupyter notebook command. You will see something like:
It will be beneficial to copy the login URL so that we will be able to get the token later when we try to login to our jupyter notebook later. In my case, it is:
[http://localhost:8888/?token=5ccd01f60971d9fc97fd79f64a5bb4ce79f4d96823ab7872](http://localhost:8888/?token=5ccd01f60971d9fc97fd79f64a5bb4ce79f4d96823ab7872&amp;amp;token=5ccd01f60971d9fc97fd79f64a5bb4ce79f4d96823ab7872)  The next step is to detach our TMUX session so that it continues running in the background even when you leave the SSH shell. To do this just press Ctrl&#43;B and then D (Don’t press Ctrl when pressing D)You will come back to the initial screen with the message that you have detached from your TMUX session.
If you want, you can reattach to the session again using:
tmux attach -t StreamSession  2. SSH Tunneling to access the notebook on your Local Browser The second step is to tunnel into the Amazon instance to be able to get the Jupyter notebook on your Local Browser. As we can see, the Jupyter Notebook is actually running on the localhost on the Cloud instance. How do we access it? We use SSH tunneling. Worry not, it is straightforward fill in the blanks. Just use this command on your local machine terminal window:
ssh -i &amp;quot;aws_key.pem&amp;quot; -L &amp;lt;Local Machine Port&amp;gt;:localhost:8888 [ubuntu@](mailto:ubuntu@ec2-34-212-131-240.us-west-2.compute.amazonaws.com)&amp;lt;Your PublicDNS(IPv4)&amp;gt;  For this case, I have used:
ssh -i &amp;quot;aws_key.pem&amp;quot; -L 8001:localhost:8888 [ubuntu@](mailto:ubuntu@ec2-34-212-131-240.us-west-2.compute.amazonaws.com)ec2-54-202-223-197.us-west-2.compute.amazonaws.com  This means that I will be able to use the Jupyter Notebook If I open the localhost:8001 in my local machine browser. And I surely can. We can now just input the token that we already have saved in one of our previous steps to access the notebook. For me the token is 5ccd01f60971d9fc97fd79f64a5bb4ce79f4d96823ab7872
You can just login using your token and voila we get the notebook in all its glory.
You can now choose to work on a new project by selecting any of the different environments you want. You can come from Tensorflow or Pytorch or might be willing to get the best of both worlds. This notebook will not disappoint you.
Troubleshooting It might happen that once the machine is restarted, you face some problems with the NVIDIA graphics card. Specifically, in my case, the nvidia-smi command stopped working. If you encounter this problem, the solution is to download the graphics driver from the NVIDIA website.
Above are the settings for the particular AMI I selected. Once you click on Search you will be able to see the next page:
Just copy the download link by right-clicking and copying the link address. And run the following commands on your machine. You might need to change the link address and the file name in this.
# When nvidia-smi doesnt work: wget [https://www.nvidia.in/content/DriverDownload-March2009/confirmation.php?url=/tesla/410.129/NVIDIA-Linux-x86_64-410.129-diagnostic.run&amp;amp;lang=in&amp;amp;type=Tesla](https://www.nvidia.in/content/DriverDownload-March2009/confirmation.php?url=/tesla/410.129/NVIDIA-Linux-x86_64-410.129-diagnostic.run&amp;amp;lang=in&amp;amp;type=Tesla) sudo sh NVIDIA-Linux-x86_64-410.129-diagnostic.run --no-drm --disable-nouveau --dkms --silent --install-libglvnd modinfo nvidia | head -7 sudo modprobe nvidia  Stop Your Instance And that’s it. You have got and up and running Deep Learning machine at your disposal, and you can work with it as much as you want. Just keep in mind to stop the instance whenever you stop working, so you won’t need to pay Amazon when you are not working on your instance. You can do it on the instances page by right-clicking on your instance. Just note that when you need to log in again to this machine, you will need to get the Public DNS (IPv4) address from the instance page back as it might have changed.
Conclusion I have always found it a big chore to set up a deep learning environment.
In this blog, we set up a new Deep Learning server on EC2 in minimal time by using Deep Learning Community AMI, TMUX, and Tunneling for the Jupyter Notebooks. This server comes preinstalled with all the deep learning libraries you might need at your work, and it just works out of the box.
So what are you waiting for? Just get started with Deep Learning with your own server.
If you want to learn more about AWS and how to use it in production settings and deploying models, I would like to call out an excellent course on AWS. Do check it out.
Thanks for the read. I am going to be writing more beginner-friendly posts in the future too. Follow me up at Medium or Subscribe to my blog
Also, a small disclaimer — There might be some affiliate links in this post to relevant resources, as sharing knowledge is never a bad idea.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Using Deep Learning for End to End Multiclass Text Classification</title>
      <link>https://mlwhiz.com/blog/2020/05/24/multitextclass/</link>
      <pubDate>Sun, 24 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2020/05/24/multitextclass/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/multitextclass/main.png"></media:content>
      

      
      <description>Have you ever thought about how toxic comments get flagged automatically on platforms like Quora or Reddit? Or how mail gets marked as spam? Or what decides which online ads are shown to you?
All of the above are examples of how text classification is used in different areas. Text classification is a common task in natural language processing (NLP) which transforms a sequence of a text of indefinite length into a single category.</description>

      <content:encoded>  
        
        <![CDATA[  Have you ever thought about how toxic comments get flagged automatically on platforms like Quora or Reddit? Or how mail gets marked as spam? Or what decides which online ads are shown to you?
All of the above are examples of how text classification is used in different areas. Text classification is a common task in natural language processing (NLP) which transforms a sequence of a text of indefinite length into a single category.
One theme that emerges from the above examples is that all have a binary target class. For example, either the comment is toxic or not toxic, or the review is fake or not fake. In short, there are only two target classes, hence the term binary.
But this is not always the case, and some problems might have more than two target classes. These problems are conveniently termed multiclass classifications, and it is these problems we’ll focus on in this post. Some examples of multiclass classification include:
 The sentiment of a review: positive, negative or neutral (three classes)
 News Categorization by genre: Entertainment, education, politics, etc.
  In this post, we will go through a multiclass text classification problem using various Deep Learning Methods.
Dataset / Problem Description For this post, I am using the UCI ML Drug Review dataset from Kaggle. It contains over 200,000 patient drug reviews, along with related conditions. The dataset has many columns, but we will be using just two of them for our NLP Task.
So, our dataset mostly looks like this:
Task: We want to classify the top disease conditions based on the drug review.
A Primer on word2vec embeddings: Before we go any further into text classification, we need a way to represent words numerically in a vocabulary. Why? Because most of our ML models require numbers, not text.
One way to achieve this goal is by using the one-hot encoding of word vectors, but this is not the right choice. Given a vast vocabulary, this representation would take a lot of space, and it cannot accurately express the similarity between different words, such as if we want to find the cosine similarity between numerical words x and y:
Given the structure of one-hot encoded vectors, the similarity is always going to be 0 between different words.
Word2Vec overcomes the above difficulties by providing us with a fixed-length (usually much smaller than the vocabulary size) vector representation of words. It also captures the similarity and analogous relationships between different words.
Word2vec vectors of words are learned in such a way that they allow us to learn different analogies. This enables us to do algebraic manipulations on words that were not possible previously.
For example: What is king — man &#43; woman? The result is Queen.
Word2Vec vectors also help us to find the similarity between words. If we look for similar words to “good”, we will find awesome, great, etc. It is this property of word2vec that makes it invaluable for text classification. With this, our deep learning network understands that “good” and “great” are words with similar meanings.
In simple terms, word2vec creates fixed-length vectors for words, giving us a d dimensional vector for every word (and common bigrams) in a dictionary.
These word vectors are usually pre-trained, and provided by others after training on large corpora of texts like Wikipedia, Twitter, etc. The most commonly used pre-trained word vectors are Glove and Fast text with 300-dimensional word vectors. In this post, we will use the Glove word vectors.
Data Preprocessing In most cases, text data is not entirely clean. Data coming from different sources have different characteristics, and this makes text preprocessing one of the most critical steps in the classification pipeline. For example, Text data from Twitter is different from the text data found on Quora or other news/blogging platforms, and each needs to be treated differently. However, the techniques we’ll cover in this post are generic enough for almost any kind of data you might encounter in the jungles of NLP.
a) Cleaning Special Characters and Removing Punctuation Our preprocessing pipeline depends heavily on the word2vec embeddings we are going to use for our classification task. In principle, our preprocessing should match the preprocessing used before training the word embedding. Since most of the embeddings don’t provide vector values for punctuation and other special characters, the first thing we want to do is get rid of the special characters in our text data.
# Some preprocesssing that will be common to all the text classification methods you will see. import re def clean_text(x): pattern = r&#39;[^a-zA-z0-9\s]&#39; text = re.sub(pattern, &#39;&#39;, x) return x  b) Cleaning Numbers Why do we want to replace numbers with #s? Because most embeddings, including Glove, have preprocessed their text in this way.
Small Python Trick: We use an if statement in the code below to check beforehand if a number exists in a text because an if is always faster than a re.sub command, and most of our text doesn’t contain numbers.
def clean_numbers(x): if bool(re.search(r&#39;\d&#39;, x)): x = re.sub(&#39;[0-9]{5,}&#39;, &#39;#####&#39;, x) x = re.sub(&#39;[0-9]**{4}**&#39;, &#39;####&#39;, x) x = re.sub(&#39;[0-9]**{3}**&#39;, &#39;###&#39;, x) x = re.sub(&#39;[0-9]**{2}**&#39;, &#39;##&#39;, x) return x  c) Removing Contractions Contractions are words that we write with an apostrophe. Examples of contractions are words like “ain’t” or “aren’t”. Since we want to standardize our text, it makes sense to expand these contractions. Below we have done this using contraction mapping and regex functions.
contraction_dict = {&amp;quot;ain&#39;t&amp;quot;: &amp;quot;is not&amp;quot;, &amp;quot;aren&#39;t&amp;quot;: &amp;quot;are not&amp;quot;,&amp;quot;can&#39;t&amp;quot;: &amp;quot;cannot&amp;quot;, &amp;quot;&#39;cause&amp;quot;: &amp;quot;because&amp;quot;, &amp;quot;could&#39;ve&amp;quot;: &amp;quot;could have&amp;quot;} def _get_contractions(contraction_dict): contraction_re = re.compile(&#39;(**%s**)&#39; % &#39;|&#39;.join(contraction_dict.keys())) return contraction_dict, contraction_re contractions, contractions_re = _get_contractions(contraction_dict) def replace_contractions(text): def replace(match): return contractions[match.group(0)] return contractions_re.sub(replace, text) # Usage replace_contractions(&amp;quot;this&#39;s a text with contraction&amp;quot;)  Apart from the above techniques, you may want to do spell correction, too. But since our post is already quite long, we’ll leave that for now.
Data Representation: Sequence Creation One thing that has made deep learning a go-to choice for NLP is the fact that we don’t have to hand-engineer features from our text data; deep learning algorithms take as input a sequence of text to learn its structure just like humans do. Since machines cannot understand words, they expect their data in numerical form. So we need to represent our text data as a series of numbers.
To understand how this is done, we need to understand a little about the Keras Tokenizer function. Other tokenizers are also viable, but the Keras Tokenizer is a good choice for me.
a) Tokenizer Put simply, a tokenizer is a utility function that splits a sentence into words. keras.preprocessing.text.Tokenizer tokenizes (splits) a text into tokens (words) while keeping only the words that occur the most in the text corpus.
#Signature: Tokenizer(num_words=None, filters=&#39;!&amp;quot;#$%&amp;amp;()*&#43;,-./:;&amp;lt;=&amp;gt;?@[\\]^_`{|}~\t\n&#39;, lower=True, split=&#39; &#39;, char_level=False, oov_token=None, document_count=0, **kwargs)  The num_words parameter keeps only a pre-specified number of words in the text. This is helpful because we don’t want our model to get a lot of noise by considering words that occur infrequently. In real-world data, most of the words we leave using the num_words parameter are normally misspelled words. The tokenizer also filters some non-wanted tokens by default and converts the text into lowercase.
Once fitted to the data, the tokenizer also keeps an index of words (a dictionary we can use to assign unique numbers to words), which can be accessed by tokenizer.word_index. The words in the indexed dictionary are ranked in order of frequency.
So the whole code to use the tokenizer is as follows:
from keras.preprocessing.text import Tokenizer ## Tokenize the sentences tokenizer = Tokenizer(num_words=max_features) tokenizer.fit_on_texts(list(train_X)&#43;list(test_X)) train_X = tokenizer.texts_to_sequences(train_X) test_X = tokenizer.texts_to_sequences(test_X)  where train_X and test_X are lists of documents in the corpus.
b) Pad Sequence Normally our model expects that each text sequence (each training example) will be of the same length (the same number of words/tokens). We can control this using the maxlen parameter.
For example:
train_X = pad_sequences(train_X, maxlen=maxlen) test_X = pad_sequences(test_X, maxlen=maxlen)  Now our training data contains a list of numbers. Each list has the same length. And we also have the word_index which is a dictionary of the words that occur most in the text corpus.
c) Label Encoding the Target Variable The Pytorch model expects the target variable as a number and not a string. We can use Label encoder from sklearn to convert our target variable.
from sklearn.preprocessing import LabelEncoder le = LabelEncoder() train_y = le.fit_transform(train_y.values) test_y = le.transform(test_y.values)  Load Embedding First, we need to load the required Glove embeddings.
def load_glove(word_index): EMBEDDING_FILE = &#39;../input/glove840b300dtxt/glove.840B.300d.txt&#39; def get_coefs(word,*arr): return word, np.asarray(arr, dtype=&#39;float32&#39;)[:300] embeddings_index = dict(get_coefs(*o.split(&amp;quot; &amp;quot;)) for o in open(EMBEDDING_FILE)) all_embs = np.stack(embeddings_index.values()) emb_mean,emb_std = -0.005838499,0.48782197 embed_size = all_embs.shape[1] nb_words = min(max_features, len(word_index)&#43;1) embedding_matrix = np.random.normal(emb_mean, emb_std, (nb_words, embed_size)) for word, i in word_index.items(): if i &amp;gt;= max_features: continue embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[i] = embedding_vector else: embedding_vector = embeddings_index.get(word.capitalize()) if embedding_vector is not None: embedding_matrix[i] = embedding_vector return embedding_matrix embedding_matrix = load_glove(tokenizer.word_index)  Be sure to put the path of the folder where you download these GLoVE vectors. What does the embeddings_index contain? It’s a dictionary in which the key is the word, and the value is the word vector, a np.array of length 300. The length of this dictionary is somewhere around a billion.
Since we only want the embeddings of words that are in our word_index, we will create a matrix that just contains required embeddings using the word index from our tokenizer.
Deep Learning Models 1. TextCNN The idea of using a CNN to classify text was first presented in the paper Convolutional Neural Networks for Sentence Classification by Yoon Kim.
Representation: The central concept of this idea is to see our documents as images. But how? Let’s say we have a sentence, and we have maxlen = 70 and embedding size = 300. We can create a matrix of numbers with the shape 70×300 to represent this sentence. Images also have a matrix where individual elements are pixel values. But instead of image pixels, the input to the task is sentences or documents represented as a matrix. Each row of the matrix corresponds to a one-word vector.
Convolution Idea: For images, we move our conv. filter both horizontally as well as vertically, but for text we fix kernel size to filter_size x embed_size, i.e. (3,300) we are just going to move vertically down the convolution looking at three words at once, since our filter size in this case is 3. This idea seems right since our convolution filter is not splitting word embedding; it gets to look at the full embedding of each word. Also, one can think of filter sizes as unigrams, bigrams, trigrams, etc. Since we are looking at a context window of 1, 2, 3, and 5 words respectively.
Here is the text classification CNN network coded in Pytorch.
class CNN_Text(nn.Module): def __init__(self): super(CNN_Text, self).__init__() filter_sizes = [1,2,3,5] num_filters = 36 n_classes = len(le.classes_) self.embedding = nn.Embedding(max_features, embed_size) self.embedding.weight = nn.Parameter(torch.tensor(embedding_matrix, dtype=torch.float32)) self.embedding.weight.requires_grad = False self.convs1 = nn.ModuleList([nn.Conv2d(1, num_filters, (K, embed_size)) for K in filter_sizes]) self.dropout = nn.Dropout(0.1) self.fc1 = nn.Linear(len(filter_sizes)*num_filters, n_classes) def forward(self, x): x = self.embedding(x) x = x.unsqueeze(1) x = [F.relu(conv(x)).squeeze(3) for conv in self.convs1] x = [F.max_pool1d(i, i.size(2)).squeeze(2) for i in x] x = torch.cat(x, 1) x = self.dropout(x) logit = self.fc1(x) return logit  2. BiDirectional RNN (LSTM/GRU) TextCNN works well for text classification because it takes care of words in close range. For example, it can see “new york” together. However, it still can’t take care of all the context provided in a particular text sequence. It still does not learn the sequential structure of the data, where each word is dependent on the previous word, or a word in the previous sentence.
RNNs can help us with that. They can remember previous information using hidden states and connect it to the current task.
Long Short Term Memory networks (LSTM) are a subclass of RNN, specialized in remembering information for extended periods. Moreover, a bidirectional LSTM keeps the contextual information in both directions, which is pretty useful in text classification tasks (However, it won’t work for a time series prediction task as we don’t have visibility into the future in this case).
For a simple explanation of a bidirectional RNN, think of an RNN cell as a black box taking as input a hidden state (a vector) and a word vector and giving out an output vector and the next hidden state. This box has some weights which need to be tuned using backpropagation of the losses. Also, the same cell is applied to all the words so that the weights are shared across the words in the sentence. This phenomenon is called weight-sharing.
Hidden state, Word vector -&amp;gt;(RNN Cell) -&amp;gt; Output Vector , Next Hidden state
For a sequence of length 4 like “you will never believe”, The RNN cell gives 4 output vectors, which can be concatenated and then used as part of a dense feedforward architecture.
In the bidirectional RNN, the only change is that we read the text in the usual fashion as well in reverse. So we stack two RNNs in parallel, and we get 8 output vectors to append.
Once we get the output vectors, we send them through a series of dense layers and finally, a softmax layer to build a text classifier.
In most cases, you need to understand how to stack some layers in a neural network to get the best results. We can try out multiple bidirectional GRU/LSTM layers in the network if it performs better.
Due to the limitations of RNNs, such as not remembering long term dependencies, in practice, we almost always use LSTM/GRU to model long term dependencies. In this case, you can think of the RNN cell being replaced by an LSTM cell or a GRU cell in the above figure.
Here is some code in Pytorch for this network:
class BiLSTM(nn.Module): def __init__(self): super(BiLSTM, self).__init__() self.hidden_size = 64 drp = 0.1 n_classes = len(le.classes_) self.embedding = nn.Embedding(max_features, embed_size) self.embedding.weight = nn.Parameter(torch.tensor(embedding_matrix, dtype=torch.float32)) self.embedding.weight.requires_grad = False self.lstm = nn.LSTM(embed_size, self.hidden_size, bidirectional=True, batch_first=True) self.linear = nn.Linear(self.hidden_size*4 , 64) self.relu = nn.ReLU() self.dropout = nn.Dropout(drp) self.out = nn.Linear(64, n_classes) def forward(self, x): *#rint(x.size())* h_embedding = self.embedding(x) *#_embedding = torch.squeeze(torch.unsqueeze(h_embedding, 0))* h_lstm, _ = self.lstm(h_embedding) avg_pool = torch.mean(h_lstm, 1) max_pool, _ = torch.max(h_lstm, 1) conc = torch.cat(( avg_pool, max_pool), 1) conc = self.relu(self.linear(conc)) conc = self.dropout(conc) out = self.out(conc) return out  Training Below is the code we use to train our BiLSTM Model. The code is well commented, so please go through the code to understand it. You might also want to look at my post on Pytorch.
n_epochs = 6 model = BiLSTM() loss_fn = nn.CrossEntropyLoss(reduction=&#39;sum&#39;) optimizer = torch.optim.Adam(filter(lambda p: p.requires_grad, model.parameters()), lr=0.001) model.cuda() # Load train and test in CUDA Memory x_train = torch.tensor(train_X, dtype=torch.long).cuda() y_train = torch.tensor(train_y, dtype=torch.long).cuda() x_cv = torch.tensor(test_X, dtype=torch.long).cuda() y_cv = torch.tensor(test_y, dtype=torch.long).cuda() # Create Torch datasets train = torch.utils.data.TensorDataset(x_train, y_train) valid = torch.utils.data.TensorDataset(x_cv, y_cv) # Create Data Loaders train_loader = torch.utils.data.DataLoader(train, batch_size=batch_size, shuffle=True) valid_loader = torch.utils.data.DataLoader(valid, batch_size=batch_size, shuffle=False) train_loss = [] valid_loss = [] for epoch in range(n_epochs): start_time = time.time() # Set model to train configuration model.train() avg_loss = 0. for i, (x_batch, y_batch) in enumerate(train_loader): # Predict/Forward Pass y_pred = model(x_batch) # Compute loss loss = loss_fn(y_pred, y_batch) optimizer.zero_grad() loss.backward() optimizer.step() avg_loss &#43;= loss.item() / len(train_loader) # Set model to validation configuration -Doesn&#39;t get trained here model.eval() avg_val_loss = 0. val_preds = np.zeros((len(x_cv),len(le.classes_))) for i, (x_batch, y_batch) in enumerate(valid_loader): y_pred = model(x_batch).detach() avg_val_loss &#43;= loss_fn(y_pred, y_batch).item() / len(valid_loader) # keep/store predictions val_preds[i * batch_size:(i&#43;1) * batch_size] =F.softmax(y_pred).cpu().numpy() # Check Accuracy val_accuracy = sum(val_preds.argmax(axis=1)==test_y)/len(test_y) train_loss.append(avg_loss) valid_loss.append(avg_val_loss) elapsed_time = time.time() - start_time print(&#39;Epoch {}/{} \t loss={:.4f} \t val_loss={:.4f} \t val_acc={:.4f} \t time={:.2f}s&#39;.format( epoch &#43; 1, n_epochs, avg_loss, avg_val_loss, val_accuracy, elapsed_time))  The training output looks like below:
Results/Prediction import scikitplot as skplt y_true = [le.classes_[x] for x **in** test_y] y_pred = [le.classes_[x] for x **in** val_preds.argmax(axis=1)] skplt.metrics.plot_confusion_matrix( y_true, y_pred, figsize=(12,12),x_tick_rotation=90)  Below is the confusion matrix for the results of the BiLSTM model. We can see that our model does reasonably well, with an 87% accuracy on the validation dataset.
What’s interesting is that even at points where the model performs poorly, it is quite understandable. For example, the model gets confused between weight loss and obesity, or between depression and anxiety, or between depression and bipolar disorder. I am not an expert, but these diseases do feel quite similar.
Conclusion In this post, we covered deep learning architectures like LSTM and CNN for text classification and explained the different steps used in deep learning for NLP.
There is still a lot that can be done to improve this model’s performance. Changing the learning rates, using learning rate schedules, using extra features, enriching embeddings, removing misspellings, etc. I hope this boilerplate code provides a go-to baseline for any text classification problem you might face.
You can find the full working code here on Github, or this Kaggle Kernel.
Also, if you want to learn more about NLP, here is an excellent course.
If you want to learn more about NLP, I would like to call out an excellent course on Natural Language Processing from the Advanced Machine Learning Specialization. Do check it out.
I am going to be writing more of such posts in the future too. Let me know what you think about the series. Follow me up at Medium or Subscribe to my blog.
Also, a small disclaimer — There might be some affiliate links in this post to relevant resources, as sharing knowledge is never a bad idea.
This story was first published here.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Implementing Object Detection and Instance Segmentation for Data Scientists</title>
      <link>https://mlwhiz.com/blog/2019/12/06/weapons/</link>
      <pubDate>Fri, 06 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2019/12/06/weapons/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/weapons/main.png"></media:content>
      

      
      <description>Object Detection is a helpful tool to have in your coding repository.
It forms the backbone of many fantastic industrial applications. Some of them being self-driving cars, medical imaging and face detection.
In my last post on Object detection, I talked about how Object detection models evolved.
But what good is theory, if we can’t implement it?
This post is about implementing and getting an object detector on our custom dataset of weapons.</description>

      <content:encoded>  
        
        <![CDATA[  Object Detection is a helpful tool to have in your coding repository.
It forms the backbone of many fantastic industrial applications. Some of them being self-driving cars, medical imaging and face detection.
In my last post on Object detection, I talked about how Object detection models evolved.
But what good is theory, if we can’t implement it?
This post is about implementing and getting an object detector on our custom dataset of weapons.
The problem we will specifically solve today is that of Instance Segmentation using Mask-RCNN.
Instance Segmentation Can we create masks for each object in the image? Specifically something like:
The most common way to solve this problem is by using Mask-RCNN. The architecture of Mask-RCNN looks like below:
Source
Essentially, it comprises of:
 A backbone network like resnet50/resnet101
 A Region Proposal network
 ROI-Align layers
 Two output layers — one to predict masks and one to predict class and bounding box.
  There is a lot more to it. If you want to learn more about the theory, read my last post&amp;ndash; Demystifying Object Detection and Instance Segmentation for Data Scientists
This post is mostly going to be about the code.
1. Creating your Custom Dataset for Instance Segmentation The use case we will be working on is a weapon detector. A weapon detector is something that can be used in conjunction with street cameras as well as CCTV’s to fight crime. So it is pretty nifty.
So, I started with downloading 40 images each of guns and swords from the open image dataset and annotated them using the VIA tool. Now setting up the annotation project in VIA is petty important, so I will try to explain it step by step.
1. Set up VIA VIA is an annotation tool, using which you can annotate images both bounding boxes as well as masks. I found it as one of the best tools to do annotation as it is online and runs in the browser itself.
To use it, open http://www.robots.ox.ac.uk/~vgg/software/via/via.html
You will see a page like:
The next thing we want to do is to add the different class names in the region_attributes. Here I have added ‘gun’ and ‘sword’ as per our use case as these are the two distinct targets I want to annotate.
2. Annotate the Images I have kept all the files in the folder data. Next step is to add the files we want to annotate. We can add files in the data folder using the “Add Files” button in the VIA tool. And start annotating along with labels as shown below after selecting the polyline tool.
3. Download the annotation file Click on save project on the top menu of the VIA tool.
Save file as via_region_data.json by changing the project name field. This will save the annotations in COCO format.
4. Set up the data directory structure We will need to set up the data directories first so that we can do object detection. In the code below, I am creating a directory structure that is required for the model that we are going to use.
from random import random import os from glob import glob import json # Path to your images image_paths = glob(&amp;#34;data/*&amp;#34;) #Path to your annotations from VIA tool annotation_file = &amp;#39;via_region_data.json&amp;#39; #clean up the annotations a little annotations = json.load(open(annotation_file)) cleaned_annotations = {} for k,v in annotations[&amp;#39;_via_img_metadata&amp;#39;].items(): cleaned_annotations[v[&amp;#39;filename&amp;#39;]] = v # create train and validation directories ! mkdir procdata ! mkdir procdata/val ! mkdir procdata/train train_annotations = {} valid_annotations = {} # 20% of images in validation folder for img in image_paths: # Image goes to Validation folder if random()&amp;lt;0.2: os.system(&amp;#34;cp &amp;#34;&#43; img &#43; &amp;#34; procdata/val/&amp;#34;) img = img.split(&amp;#34;/&amp;#34;)[-1] valid_annotations[img] = cleaned_annotations[img] else: os.system(&amp;#34;cp &amp;#34;&#43; img &#43; &amp;#34; procdata/train/&amp;#34;) img = img.split(&amp;#34;/&amp;#34;)[-1] train_annotations[img] = cleaned_annotations[img] # put different annotations in different folders with open(&amp;#39;procdata/val/via_region_data.json&amp;#39;, &amp;#39;w&amp;#39;) as fp: json.dump(valid_annotations, fp) with open(&amp;#39;procdata/train/via_region_data.json&amp;#39;, &amp;#39;w&amp;#39;) as fp: json.dump(train_annotations, fp) After running the above code, we will get the data in the below folder structure:
- procdata - train - img1.jpg - img2.jpg - via_region_data.json - val - img3.jpg - img4.jpg - via_region_data.json  2. Setup the Coding Environment We will use the code from the matterport/Mask_RCNN GitHub repository. You can start by cloning the repository and installing the required libraries.
git clone https://github.com/matterport/Mask_RCNN cd Mask_RCNN pip install -r requirements.txt Once we are done with installing the dependencies and cloning the repo, we can start with implementing our project.
We make a copy of the samples/balloon directory in Mask_RCNN folder and create a samples/guns_and_swords directory where we will continue our work:
cp -r samples/balloon samples/guns_and_swords Setting up the Code We start by renaming and changing balloon.py in the samples/guns_and_swords directory to gns.py. The balloon.py file right now trains for one target. I have extended it to use multiple targets. In this file, we change:
 balloonconfig to gnsConfig
 BalloonDataset to gnsDataset : We changed some code here to get the target names from our annotation data and also give multiple targets.
 And some changes in the train function
  Showing only the changed gnsConfig here to get you an idea. You can take a look at the whole gns.py code here.
class gnsConfig(Config): &amp;#34;&amp;#34;&amp;#34;Configuration for training on the toy dataset. Derives from the base Config class and overrides some values. &amp;#34;&amp;#34;&amp;#34; # Give the configuration a recognizable name NAME = &amp;#34;gns&amp;#34; # We use a GPU with 16GB memory, which can fit three image. # Adjust down if you use a smaller GPU. IMAGES_PER_GPU = 3 # Number of classes (including background) NUM_CLASSES = 1 &#43; 2 # Background &#43; sword &#43; gun # Number of training steps per epoch 3. Visualizing Images and Masks Once we are done with changing the gns.py file,we can visualize our masks and images. You can do simply by following this Visualize Dataset.ipynb notebook.
4. Train the MaskRCNN Model with Transfer Learning To train the maskRCNN model, on the Guns and Swords dataset, we need to run one of the following commands on the command line based on if we want to initialise our model with COCO weights or imagenet weights:
# Train a new model starting from pre-trained COCO weights python3 gns.py train — dataset=/path/to/dataset — weights=coco # Resume training a model that you had trained earlier python3 gns.py train — dataset=/path/to/dataset — weights=last # Train a new model starting from ImageNet weights python3 gns.py train — dataset=/path/to/dataset — weights=imagenet The command with weights=last will resume training from the last epoch. The weights are going to be saved in the logs directory in the Mask_RCNN folder.
This is how the loss looks after our final epoch.
Visualize the losses using Tensorboard You can take advantage of tensorboard to visualise how your network is performing. Just run:
tensorboard --logdir ~/objectDetection/Mask_RCNN/logs/gns20191010T1234 You can get the tensorboard at
https://localhost:6006  Here is how our mask loss looks like:
We can see that the validation loss is performing pretty abruptly. This is expected as we only have kept 20 images in the validation set.
5. Prediction on New Images Predicting a new image is also pretty easy. Just follow the prediction.ipynb notebook for a minimal example using our trained model. Below is the main part of the code.
# Function taken from utils.dataset def load_image(image_path): &amp;#34;&amp;#34;&amp;#34;Load the specified image and return a [H,W,3] Numpy array. &amp;#34;&amp;#34;&amp;#34; # Load image image = skimage.io.imread(image_path) # If grayscale. Convert to RGB for consistency. if image.ndim != 3: image = skimage.color.gray2rgb(image) # If has an alpha channel, remove it for consistency if image.shape[-1] == 4: image = image[..., :3] return image # path to image to be predicted image = load_image(&amp;#34;../../../data/2c8ce42709516c79.jpg&amp;#34;) # Run object detection results = model.detect([image], verbose=1) # Display results ax = get_ax(1) r = results[0] a = visualize.display_instances(image, r[&amp;#39;rois&amp;#39;], r[&amp;#39;masks&amp;#39;], r[&amp;#39;class_ids&amp;#39;], dataset.class_names, r[&amp;#39;scores&amp;#39;], ax=ax, title=&amp;#34;Predictions&amp;#34;) This is how the result looks for some images in the validation set:
Improvements The results don’t look very promising and leave a lot to be desired, but that is to be expected because of very less training data(60 images). One can try to do the below things to improve the model performance for this weapon detector.
 We just trained on 60 images due to time constraints. While we used transfer learning the data is still too less — Annotate more data.
 Train for more epochs and longer time. See how validation loss and training loss looks like.
 Change hyperparameters in the mrcnn/config file in the Mask_RCNN directory. For information on what these hyperparameters mean, take a look at my previous post. The main ones you can look at:
  # if you want to provide different weights to different losses LOSS_WEIGHTS ={&amp;#39;rpn_class_loss&amp;#39;: 1.0, &amp;#39;rpn_bbox_loss&amp;#39;: 1.0, &amp;#39;mrcnn_class_loss&amp;#39;: 1.0, &amp;#39;mrcnn_bbox_loss&amp;#39;: 1.0, &amp;#39;mrcnn_mask_loss&amp;#39;: 1.0} # Length of square anchor side in pixels RPN_ANCHOR_SCALES = (32, 64, 128, 256, 512) # Ratios of anchors at each cell (width/height) # A value of 1 represents a square anchor, and 0.5 is a wide anchor RPN_ANCHOR_RATIOS = [0.5, 1, 2] Conclusion In this post, I talked about how to implement Instance segmentation using Mask-RCNN for a custom dataset.
I tried to make the coding part as simple as possible and hope you find the code useful. In the next part of this post, I will deploy this model using a web app. So stay tuned.
You can download the annotated weapons data as well as the code at Github.
If you want to know more about various Object Detection techniques, motion estimation, object tracking in video etc., I would like to recommend this awesome course on Deep Learning in Computer Vision in the Advanced machine learning specialization.
Thanks for the read. I am going to be writing more beginner-friendly posts in the future too. Follow me up at Medium or Subscribe to my blog.
Also, a small disclaimer — There might be some affiliate links in this post to relevant resources as sharing knowledge is never a bad idea.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Demystifying Object Detection and Instance Segmentation for Data Scientists</title>
      <link>https://mlwhiz.com/blog/2019/12/05/od/</link>
      <pubDate>Thu, 05 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2019/12/05/od/</guid>
      
      
      <media:content type="image/jpeg" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/od/main.jpeg"></media:content>
      

      
      <description>I like deep learning a lot but Object Detection is something that doesn’t come easily to me.
And Object detection is important and does have its uses. Most common of them being self-driving cars, medical imaging and face detection.
It is definitely a hard problem to solve. And with so many moving parts and new concepts introduced over the long history of this problem, it becomes even harder to understand.</description>

      <content:encoded>  
        
        <![CDATA[  I like deep learning a lot but Object Detection is something that doesn’t come easily to me.
And Object detection is important and does have its uses. Most common of them being self-driving cars, medical imaging and face detection.
It is definitely a hard problem to solve. And with so many moving parts and new concepts introduced over the long history of this problem, it becomes even harder to understand.
This post is about distilling that history into an easy explanation and explaining the gory details for Object Detection and Instance Segmentation.
Introduction We all know about the image classification problem. Given an image can you find out the class the image belongs to?
We can solve any new image classification problem with ConvNets and Transfer Learning using pre-trained nets.
 ConvNet as fixed feature extractor. Take a ConvNet pretrained on ImageNet, remove the last fully-connected layer (this layer’s outputs are the 1000 class scores for a different task like ImageNet), then treat the rest of the ConvNet as a fixed feature extractor for the new dataset. In an AlexNet, this would compute a 4096-D vector for every image that contains the activations of the hidden layer immediately before the classifier. We call these features CNN codes. It is important for performance that these codes are ReLUd (i.e. thresholded at zero) if they were also thresholded during the training of the ConvNet on ImageNet (as is usually the case). Once you extract the 4096-D codes for all images, train a linear classifier (e.g. Linear SVM or Softmax classifier) for the new dataset.
 But there are lots of other interesting problems in the Image domain:
Source
These problems can be divided into 4 major buckets. In the next few lines I would try to explain each of these problems concisely before we take a deeper dive:
 Semantic Segmentation: Given an image, can we classify each pixel as belonging to a particular class?
 Classification&#43;Localization: We were able to classify an image as a cat. Great. Can we also get the location of the said cat in that image by drawing a bounding box around the cat? Here we assume that there is a fixed number of objects(commonly 1) in the image.
 Object Detection: A More general case of the Classification&#43;Localization problem. In a real-world setting, we don’t know how many objects are in the image beforehand. So can we detect all the objects in the image and draw bounding boxes around them?
 Instance Segmentation: Can we create masks for each individual object in the image? It is different from semantic segmentation. How? If you look in the 4th image on the top, we won’t be able to distinguish between the two dogs using semantic segmentation procedure as it would sort of merge both the dogs together.
  As you can see all the problems have something of a similar flavour but a little different than each other. In this post, I will focus mainly on Object Detection and Instance segmentation as they are the most interesting.I will go through the 4 most famous techniques for object detection and how they improved with time and new ideas.
Classification&#43;Localization So lets first try to understand how we can solve the problem when we have a single object in the image. How to solve the Classification&#43;Localization case.
 💡 Treat localization as a regression problem!
 Input Data Lets first talk about what sort of data such sort of model expects. Normally in an image classification setting, we used to have data in the form (X,y) where X is the image and y used to be the class label.
In the Classification&#43;Localization setting, we will have data normally in the form (X,y), where X is still the image and y is an array containing (class_label, x,y,w,h) where,
x = bounding box top left corner x-coordinate
y = bounding box top left corner y-coordinate
w = width of the bounding box in pixels
h = height of the bounding box in pixels
Model So in this setting, we create a multi-output model which takes an image as the input and has (n_labels &#43; 4) output nodes. n_labels nodes for each of the output class and 4 nodes that give the predictions for (x,y,w,h).
Loss Normally the loss is a weighted sum of the Softmax Loss(from the Classification Problem) and the regression L2 loss(from the bounding box coordinates).
 Loss = alpha*Softmax_Loss &#43; (1-alpha)*L2_Loss
 Since these two losses would be on a different scale, the alpha hyper-parameter is something that needs to be tuned.
There is one thing I would like to note here. We are trying to do object localization task but we still have our convnets in place here. We are just adding one more output layer to also predict the coordinates of the bounding box and tweaking our loss function.
And herein lies the essence of the whole Deep Learning framework — Stack layers on top of each other, reuse components to create better models, and create architectures to solve your own problem. And that is what we are going to see a lot going forward.
Object Detection So how does this idea of localization using regression get mapped to Object Detection? It doesn’t.
We don’t have a fixed number of objects. So we can’t have 4 outputs denoting, the bounding box coordinates.
One naive idea could be to apply CNN to many different crops of the image. CNN classifies each crop as an object class or background class. This is intractable. There could be a lot of such crops that you can create.
Region Proposals: So, if just there was just a method(Normally called Region Proposal Network)which could find some smaller number of cropped regions for us automatically, we could just run our convnet on those regions and be done with object detection. And that is the basic idea behind RCNN-The first major success in object detection.
And that is what selective search (Uijlings et al, “Selective Search for Object Recognition”, IJCV 2013) provided.
So what are Region Proposals?
 Find “blobby” image regions that are likely to contain objects
 Relatively fast to run; e.g. Selective Search gives 2000 region proposals in a few seconds on CPU
  So, how exactly the region proposals are made?
Selective Search for Object Recognition: This paper finds regions in two steps.
First, we start with a set of some initial regions using Efficient GraphBased Image Segmentation.
 Graph-based image segmentation techniques generally represent the problem in terms of a graph G = (V, E) where each node v ∈ V corresponds to a pixel in the image, and the edges in E connect certain pairs of neighboring pixels.
 In this paper they take an approach:
 Each edge (vi , vj )∈ E has a corresponding weight w((vi , vj )), which is a non-negative measure of the similarity between neighboring elements vi and vj . In the graph-based approach, a segmentation S is a partition of V into components such that each component (or region) C ∈ S corresponds to a connected component in a graph.
 Put simply, they use graph-based methods to find connected components in an image and the edges are made on some measure of similarity between pixels.
As you can see if we create bounding boxes around these masks we will be losing a lot of regions. We want to have the whole baseball player in a single bounding box/frame. We need to somehow group these initial regions. And that is the second step.
For that, the authors of Selective Search for Object Recognition apply the Hierarchical Grouping algorithm to these initial regions. In this algorithm, they merge most similar regions together based on different notions of similarity based on colour, texture, size and fill to provide us with much better region proposals.
1. R-CNN So now we have our region proposals. How do we exactly use them in R-CNN?
 Object detection system overview. Our system (1) takes an input image, (2) extracts around 2000 bottom-up region proposals, (3) computes features for each proposal using a large convolutional neural network (CNN), and then (4) classifies each region using class-specific linear SVM.
 Along with this, the authors have also used a class-specific bounding box regressor, that takes:
Input : (Px, Py, Ph, Pw) — the location of the proposed region.
Target: (Gx, Gy, Gh, Gw) — Ground truth labels for the region.
The goal is to learn a transformation that maps the proposed region(P) to the Ground truth box(G)
Training R-CNN What is the input to an RCNN?
So we have got an image, Region Proposals from the RPN strategy and the ground truths of the labels (labels, ground truth boxes)
Next, we treat all region proposals with ≥ 0.5 IoU(Intersection over Union) overlap with a ground-truth box as a positive training example for that box’s class and the rest as negative. We train class-specific SVM’s
So every region proposal becomes a training example. and the convnet gives a feature vector for that region proposal. We can then train our n-SVMs using the class-specific data.
Test Time R-CNN At test time we predict detection boxes using class-specific SVMs. We will be getting a lot of overlapping detection boxes at the time of testing. Thus, non-maximum suppression is an integral part of the object detection pipeline.
First, it sorts all detection boxes on the basis of their scores. The detection box M with the maximum score is selected and all other detection boxes with a significant overlap (using a pre-defined threshold) with M are suppressed.
This process is recursively applied on all the remaining boxes until we are left with good bounding boxes only.
Problems with RCNN:  Training is slow.
 Inference (detection) is slow. 47s / image with VGG16 — Since the Convnet needs to be run many times.
  Need for speed. So Fast R-CNN.
2. Fast R-CNN  💡 So the next idea from the same authors: Why not create convolution map of input image and then just select the regions from that convolutional map? Do we really need to run so many convnets? What we can do is run just a single convnet and then apply region proposal crops on the features calculated by the convnet and use a simple SVM/classifier to classify those crops.
 Something like:
 From Paper: Fig. illustrates the Fast R-CNN architecture. A Fast R-CNN network takes as input an entire image and a set of object proposals. The network first processes the whole image with several convolutional (conv) and max pooling layers to produce a conv feature map. Then, for each object proposal a region of interest (RoI) pooling layer extracts a fixed-length feature vector from the feature map. Each feature vector is fed into a sequence of fully connected (fc) layers that finally branch into two sibling output layers: one that produces softmax probability estimates over K object classes plus a catch-all “background” class and another layer that outputs four real-valued numbers for each of the K object classes. Each set of 4 values encodes refined bounding-box positions for one of the K classes.
 💡Idea So the basic idea is to have to run the convolution only once in the image rather than so many convolution networks in R-CNN. Then we can map the ROI proposals using some method and filter the last convolution layer and just run a final classifier on that.
This idea depends a little upon the architecture of the model that gets used too.
So the architecture that the authors have proposed is:
 We experiment with three pre-trained ImageNet [4] networks, each with five max pooling layers and between five and thirteen conv layers (see Section 4.1 for network details). When a pre-trained network initializes a Fast R-CNN network, it undergoes three transformations. First, the last max pooling layer is replaced by a RoI pooling layer that is configured by setting H and W to be compatible with the net’s first fully connected layer (e.g., H = W = 7 for VGG16). Second, the network’s last fully connected layer and softmax (which were trained for 1000-way ImageNet classification) are replaced with the two sibling layers described earlier (a fully connected layer and softmax over K &#43; 1 categories and category-specific bounding-box regressors). Third, the network is modified to take two data inputs: a list of images and a list of RoIs in those images.
 Don’t worry if you don’t understand the above. This obviously is a little confusing, so let us break this down. But for that, we need to see VGG16 architecture first.
The last pooling layer is 7x7x512. This is the layer the network authors intend to replace by the ROI pooling layers. This pooling layer has got as input the location of the region proposal(xmin_roi,ymin_roi,h_roi,w_roi) and the previous feature map(14x14x512).
Now the location of ROI coordinates is in the units of the input image i.e. 224x224 pixels. But the layer on which we have to apply the ROI pooling operation is 14x14x512.
As we are using VGG, we have transformed the image (224 x 224 x 3) into (14 x 14 x 512) — i.e. the height and width are divided by 16. We can map ROIs coordinates onto the feature map just by dividing them by 16.
 In its depth, the convolutional feature map has encoded all the information for the image while maintaining the location of the “things” it has encoded relative to the original image. For example, if there was a red square on the top left of the image and the convolutional layers activate for it, then the information for that red square would still be on the top left of the convolutional feature map.
 What is ROI pooling?
Remember that the final classifier runs for each crop. And so each crop needs to be of the same size. And that is what ROI Pooling does.
In the above image, our region proposal is (0,3,5,7) in x,y,w,h format.
We divide that area into 4 regions since we want to have an ROI pooling layer of 2x2. We divide the whole area into buckets by rounding 5&amp;frasl;2 and 7&amp;frasl;2 and then just do a max-pool.
How do you do ROI-Pooling on Areas smaller than the target size? if region proposal size is 5x5 and ROI pooling layer of size 7x7. If this happens, we resize to 35x35 just by copying 7 times each cell and then max-pooling back to 7x7.
After replacing the pooling layer, the authors also replaced the 1000 layer imagenet classification layer by a fully connected layer and softmax over K &#43; 1 categories(&#43;1 for Background) and category-specific bounding-box regressors.
Training Fast-RCNN What is the input to a Fast- RCNN?
Pretty much similar to R-CNN: So we have got an image, Region Proposals from the RPN strategy and the ground truths of the labels (labels, ground truth boxes)
Next, we treat all region proposals with ≥ 0.5 IoU(Intersection over Union) overlap with a ground-truth box as a positive training example for that box’s class and the rest as negative. This time we have a dense layer on top, and we use multi-task loss.
So every ROI becomes a training example. The main difference is that there is a concept of multi-task loss:
A Fast R-CNN network has two sibling output layers.
The first outputs a discrete probability distribution (per RoI), p = (p0, &amp;hellip; , pK), over K &#43; 1 categories. As usual, p is computed by a softmax over the K&#43;1 outputs of a fully connected layer.
The second sibling layer outputs bounding-box regression offsets, t= (tx, ty, tw, th), for each of the K object classes. Each training RoI is labelled with a ground-truth class u and a ground-truth bounding-box regression target v. We use a multi-task loss L on each labelled RoI to jointly train for classification and bounding-box regression
Where Lcls is the softmax classification loss and Lloc is the regression loss. u=0 is for BG class and hence we add to loss only when we have a boundary box for any of the other class.
Problem: Region proposals are still taking up most of the time. Can we reduce the time taken for Region proposals?
3. Faster-RCNN The next question that got asked was: Can the network itself do region proposals?
 The intuition is that: With FastRCNN we’re already computing an Activation Map in the CNN, why not run the Activation Map through a few more layers to find the interesting regions, and then finish off the forward pass by predicting the classes &#43; bbox coordinates?
 How does the Region Proposal Network work? One of the main ideas in the paper is the idea of Anchors. Anchors are fixed bounding boxes that are placed throughout the image with different sizes and ratios that are going to be used for reference when first predicting object locations.
So, first of all, we define anchor centres on the image.
The anchor centres are separated by 16 px in case of VGG16 network as the final convolution layer of (14x14x512) subsamples the image by a factor of 16(224&amp;frasl;14).
This is how anchors look like:
 So we start with some predefined regions we think our objects could be with Anchors.
 Our Region Proposal Network(RPN) classifies which regions have the object and the offset of the object bounding box. Training is done using the same logic. 1 if IOU for anchor with bounding box&amp;gt;0.5 0 otherwise.
 Non-Maximum suppression to reduce region proposals
 Fast RCNN detection network on top of proposals
  Faster-RCNN Loss The whole network is then jointly trained with 4 losses:
 RPN classify object / not object
 RPN regress box coordinates offset
 Final classification score (object classes)
 Final box coordinates offset
  Performance Instance Segmentation Now comes the most interesting part — Instance segmentation. Can we create masks for each individual object in the image? Specifically something like:
Mask-RCNN The same authors come to rescue again. The basic idea is to add another output layer that predicts the mask. And to use ROIAlign instead of ROIPooling.
Source: Everything remains the same. Just one more output layer to predict masks and ROI pooling replaced by ROIAlign
Mask R-CNN adopts the same two-stage procedure, with an identical first stage (RPN).
In the second stage, in parallel to predicting the class and box offset, Mask R-CNN also outputs a binary mask for each RoI.
ROIAlign vs ROIPooling In ROI pooling we lose the exact location-based information. See how we arbitrarily divided our region into 4 different sized boxes. For a classification task, it works well.
But for providing masks on a pixel level, we don’t want to lose this information. And hence we don’t quantize the pooling layer and use bilinear interpolation to find out values that properly aligns the extracted features with the input. See how 0.8 differs from 0.88
Source
Training During training, we define a multi-task loss on each sampled RoI as
L = Lcls &#43; Lbox &#43; Lmask
The classification loss Lcls and bounding-box loss Lbox are identical as in Faster R-CNN. The mask branch has a K × m × m — dimensional output for each RoI, which encodes K binary masks of resolution m × m, one for each of the K classes.
To this, we apply a per-pixel sigmoid and define Lmask as the average binary cross-entropy loss. For an RoI associated with ground-truth class k, Lmask is only defined on the kth mask (other mask outputs do not contribute to the loss).
Mask Prediction The mask layer is K × m × m dimensional where K is the number of classes. The m×m floating-number mask output is resized to the RoI size and binarized at a threshold of 0.5 to get final masks.
Conclusion Congrats for reaching the end. This post was a long one.
In this post, I talked about some of the most important advancements in the field of Object detection and Instance segmentation and tried to explain them as easily as I can.
This is my own understanding of these papers with inputs from many blogs and slides on the internet and I sincerely thank the creators. Let me know if you find something wrong with my understanding.
Object detection is a vast field and there are a lot of other methods that dominate this field. Some of them being U-net, SSD and YOLO.
There is no dearth of resources to learn them so I would encourage you to go and take a look at them. You have got a solid backing/understanding now.
In this post, I didn’t write about coding and implementation. So stay tuned for my next post in which we will train a Mask RCNN model for a custom dataset.
If you want to know more about various Object Detection techniques, motion estimation, object tracking in video etc., I would like to recommend this awesome course on Deep Learning in Computer Vision in the Advanced machine learning specialization.
Thanks for the read. I am going to be writing more beginner-friendly posts in the future too. Follow me up at Medium or Subscribe to my blog.
Also, a small disclaimer — There might be some affiliate links in this post to relevant resources as sharing knowledge is never a bad idea.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>An End to End Introduction to GANs</title>
      <link>https://mlwhiz.com/blog/2019/06/17/gans/</link>
      <pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2019/06/17/gans/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/gans/faces.png"></media:content>
      

      
      <description>I bet most of us have seen a lot of AI-generated people faces in recent times, be it in papers or blogs. We have reached a stage where it is becoming increasingly difficult to distinguish between actual human faces and faces that are generated by Artificial Intelligence.
In this post, I will help the reader to understand how they can create and build such applications on their own.</description>

      <content:encoded>  
        
        <![CDATA[    I bet most of us have seen a lot of AI-generated people faces in recent times, be it in papers or blogs. We have reached a stage where it is becoming increasingly difficult to distinguish between actual human faces and faces that are generated by Artificial Intelligence.
In this post, I will help the reader to understand how they can create and build such applications on their own.
I will try to keep this post as intuitive as possible for starters while not dumbing it down too much.
This post is about understanding how GANs work.
Task Overview I will work on creating our own anime characters using anime characters dataset.
The DC-GAN flavor of GANs which I will use here is widely applicable not only to generate Faces or new anime characters; it can also be used to create modern fashion styles, for general content creation and sometimes for data augmentation purposes as well.
As per my view, GANs will change the way video games and special effects are generated. The approach could create realistic textures or characters on demand.
You can find the full code for this chapter in the Github Repository. I have also uploaded the code to Google Colab so that you can try it yourself.
Using DCGAN architecture to generate anime images As always before we get into the coding, it helps to delve a little bit into the theory.
The main idea of DC-GAN’s stemmed from the paper UNSUPERVISED REPRESENTATION LEARNING WITH DEEP CONVOLUTIONAL GENERATIVE ADVERSARIAL NETWORKS written in 2016 by Alec Radford, Luke Metz, and Soumith Chintala.
Although I am going to explain the paper in the next few sections, do take a look at it. It is an excellent paper.
INTUITION: Brief Intro to GANs for Generating Fake Images   Generator vs. Discriminator    Typically, GANs employ two dueling neural networks to train a computer to learn the nature of a data set well enough to generate convincing fakes.
We can think of this as two systems where one Neural Network works to generate fakes (Generator), and another neural network (Discriminator) tries to classify which image is a fake.
As both generator and discriminator networks do this repetitively, the networks eventually get better at their respective tasks.
Think of this as simple as swordplay. Two noobs start sparring with each other. After a while, both become better at swordplay.
Or you could think of this as a robber(generator) and a policeman(Discriminator). After a lot of thefts, the robber becomes better at thieving while the policeman gets better at catching the robber. In an ideal world.
The Losses in these neural networks are primarily a function of how the other network performs:
 Discriminator network loss is a function of generator network quality- Loss is high for the discriminator if it gets fooled by the generator’s fake images
 Generator network loss is a function of discriminator network quality — Loss is high if the generator is not able to fool the discriminator.
  In the training phase, we train our Discriminator and Generator networks sequentially intending to improve both the Discriminator and Generator performance.
The objective is to end up with weights that help Generators to generate realistic looking images. In the end, we can use the Generator Neural network to generate fake images from Random Noise.
Generator architecture One of the main problems we face with GANs is that the training is not very stable. Thus we have to come up with a Generator architecture that solves our problem and also results in stable training.
     The preceding diagram is taken from the paper, which explains the DC-GAN generator architecture. It might look a little bit confusing.
Essentially we can think of a generator Neural Network as a black box which takes as input a 100 sized normally generated vector of numbers and gives us an image:
     How do we get such an architecture?
In the below architecture, we use a dense layer of size 4x4x1024 to create a dense vector out of this 100-d vector. Then, we reshape this dense vector in the shape of an image of 4x4 with 1024 filters, as shown in the following figure:
  tc   We don’t have to worry about any weights right now as the network itself will learn those while training.
Once we have the 1024 4x4 maps, we do upsampling using a series of Transposed convolutions, which after each operation doubles the size of the image and halves the number of maps. In the last step, though we don’t half the number of maps but reduce it to 3 channels/maps only for each RGB channel since we need three channels for the output image.
Now, What are Transpose convolutions? In most simple terms, transpose convolutions provide us with a way to upsample images. While in the convolution operation we try to go from a 4x4 image to a 2x2 image, in Transpose convolutions, we convolve from 2x2 to 4x4 as shown in the following figure:
     Q: We know that Un-pooling is popularly used for upsampling input feature maps in the convolutional neural network (CNN). Why don’t we use Un-pooling?
It is because un-pooling does not involve any learning. However, transposed convolution is learnable, and that is why we prefer transposed convolutions to un-pooling. Their parameters can be learned by the generator as we will see in some time.
Discriminator architecture Now, as we have understood the generator architecture, here is the discriminator as a black box.
In practice, it contains a series of convolutional layers and a dense layer at the end to predict if an image is fake or not as shown in the following figure:
     Takes an image as input and predicts if it is real/fake. Every image conv net ever.
Data preprocessing and visualization The first thing we want to do is to look at some of the images in the dataset. The following are the python commands to visualize some of the images from the dataset:
filenames = glob.glob(&amp;#39;animeface-character-dataset/*/*.pn*&amp;#39;) plt.figure(figsize=(10, 8)) for i in range(5): img = plt.imread(filenames[i], 0) plt.subplot(4, 5, i&#43;1) plt.imshow(img) plt.title(img.shape) plt.xticks([]) plt.yticks([]) plt.tight_layout() plt.show() The resultant output is as follows:
     We get to see the sizes of the images and the images themselves.
We also need functions to preprocess the images to a standard size of 64x64x3, in this particular case, before proceeding further with our training.
We will also need to normalize the image pixels before we use it to train our GAN. You can see the code it is well commented.
# A function to normalize image pixels. def norm_img(img): &amp;#39;&amp;#39;&amp;#39;A function to Normalize Images. Input: img : Original image as numpy array. Output: Normailized Image as numpy array &amp;#39;&amp;#39;&amp;#39; img = (img / 127.5) - 1 return img def denorm_img(img): &amp;#39;&amp;#39;&amp;#39;A function to Denormailze, i.e. recreate image from normalized image Input: img : Normalized image as numpy array. Output: Original Image as numpy array &amp;#39;&amp;#39;&amp;#39; img = (img &#43; 1) * 127.5 return img.astype(np.uint8) def sample_from_dataset(batch_size, image_shape, data_dir=None): &amp;#39;&amp;#39;&amp;#39;Create a batch of image samples by sampling random images from a data directory. Resizes the image using image_shape and normalize the images. Input: batch_size : Sample size required image_size : Size that Image should be resized to data_dir : Path of directory where training images are placed. Output: sample : batch of processed images &amp;#39;&amp;#39;&amp;#39; sample_dim = (batch_size,) &#43; image_shape sample = np.empty(sample_dim, dtype=np.float32) all_data_dirlist = list(glob.glob(data_dir)) sample_imgs_paths = np.random.choice(all_data_dirlist,batch_size) for index,img_filename in enumerate(sample_imgs_paths): image = Image.open(img_filename) image = image.resize(image_shape[:-1]) image = image.convert(&amp;#39;RGB&amp;#39;) image = np.asarray(image) image = norm_img(image) sample[index,...] = image return sample As you will see, we will be using the preceding defined functions in the training part of our code.
Implementation of DCGAN This is the part where we define our DCGAN. We will be defining our noise generator function, Generator architecture, and Discriminator architecture.
Generating noise vector for Generator   Kids: Normal Noise generators    The following code block is a helper function to create a noise vector of predefined length for a Generator. It will generate the noise which we want to convert to an image using our generator architecture.
We use a normal distribution
to generate the noise vector:
def gen_noise(batch_size, noise_shape): &amp;#39;&amp;#39;&amp;#39; Generates a numpy vector sampled from normal distribution of shape (batch_size,noise_shape) Input: batch_size : size of batch noise_shape: shape of noise vector, normally kept as 100 Output:a numpy vector sampled from normal distribution of shape (batch_size,noise_shape) &amp;#39;&amp;#39;&amp;#39; return np.random.normal(0, 1, size=(batch_size,)&#43;noise_shape) Generator architecture The Generator is the most crucial part of the GAN.
Here, I create a generator by adding some transposed convolution layers to upsample the noise vector to an image.
As you will notice, this generator architecture is not the same as given in the Original DC-GAN paper.
I needed to make some architectural changes to fit our data better, so I added a convolution layer in the middle and removed all dense layers from the generator architecture, making it fully convolutional.
I also use a lot of Batchnorm layers with a momentum of 0.5 and leaky ReLU activation. I use Adam optimizer with β=0.5. The following code block is the function I will use to create the generator:
def get_gen_normal(noise_shape): &amp;#39;&amp;#39;&amp;#39; This function takes as input shape of the noise vector and creates the Keras generator architecture. &amp;#39;&amp;#39;&amp;#39; kernel_init = &amp;#39;glorot_uniform&amp;#39; gen_input = Input(shape = noise_shape) # Transpose 2D conv layer 1. generator = Conv2DTranspose(filters = 512, kernel_size = (4,4), strides = (1,1), padding = &amp;#34;valid&amp;#34;, data_format = &amp;#34;channels_last&amp;#34;, kernel_initializer = kernel_init)(gen_input) generator = BatchNormalization(momentum = 0.5)(generator) generator = LeakyReLU(0.2)(generator) # Transpose 2D conv layer 2. generator = Conv2DTranspose(filters = 256, kernel_size = (4,4), strides = (2,2), padding = &amp;#34;same&amp;#34;, data_format = &amp;#34;channels_last&amp;#34;, kernel_initializer = kernel_init)(generator) generator = BatchNormalization(momentum = 0.5)(generator) generator = LeakyReLU(0.2)(generator) # Transpose 2D conv layer 3. generator = Conv2DTranspose(filters = 128, kernel_size = (4,4), strides = (2,2), padding = &amp;#34;same&amp;#34;, data_format = &amp;#34;channels_last&amp;#34;, kernel_initializer = kernel_init)(generator) generator = BatchNormalization(momentum = 0.5)(generator) generator = LeakyReLU(0.2)(generator) # Transpose 2D conv layer 4. generator = Conv2DTranspose(filters = 64, kernel_size = (4,4), strides = (2,2), padding = &amp;#34;same&amp;#34;, data_format = &amp;#34;channels_last&amp;#34;, kernel_initializer = kernel_init)(generator) generator = BatchNormalization(momentum = 0.5)(generator) generator = LeakyReLU(0.2)(generator) # conv 2D layer 1. generator = Conv2D(filters = 64, kernel_size = (3,3), strides = (1,1), padding = &amp;#34;same&amp;#34;, data_format = &amp;#34;channels_last&amp;#34;, kernel_initializer = kernel_init)(generator) generator = BatchNormalization(momentum = 0.5)(generator) generator = LeakyReLU(0.2)(generator) # Final Transpose 2D conv layer 5 to generate final image. Filter size 3 for 3 image channel generator = Conv2DTranspose(filters = 3, kernel_size = (4,4), strides = (2,2), padding = &amp;#34;same&amp;#34;, data_format = &amp;#34;channels_last&amp;#34;, kernel_initializer = kernel_init)(generator) # Tanh activation to get final normalized image generator = Activation(&amp;#39;tanh&amp;#39;)(generator) # defining the optimizer and compiling the generator model. gen_opt = Adam(lr=0.00015, beta_1=0.5) generator_model = Model(input = gen_input, output = generator) generator_model.compile(loss=&amp;#39;binary_crossentropy&amp;#39;, optimizer=gen_opt, metrics=[&amp;#39;accuracy&amp;#39;]) generator_model.summary() return generator_model You can plot the final generator model:
plot_model(generator, to_file=&amp;#39;gen_plot.png&amp;#39;, show_shapes=True, show_layer_names=True)   Generator Architecture    Discriminator architecture Here is the discriminator architecture where I use a series of convolutional layers and a dense layer at the end to predict if an image is fake or not.
Here is the architecture of the discriminator:
def get_disc_normal(image_shape=(64,64,3)): dropout_prob = 0.4 kernel_init = &amp;#39;glorot_uniform&amp;#39; dis_input = Input(shape = image_shape) # Conv layer 1: discriminator = Conv2D(filters = 64, kernel_size = (4,4), strides = (2,2), padding = &amp;#34;same&amp;#34;, data_format = &amp;#34;channels_last&amp;#34;, kernel_initializer = kernel_init)(dis_input) discriminator = LeakyReLU(0.2)(discriminator) # Conv layer 2: discriminator = Conv2D(filters = 128, kernel_size = (4,4), strides = (2,2), padding = &amp;#34;same&amp;#34;, data_format = &amp;#34;channels_last&amp;#34;, kernel_initializer = kernel_init)(discriminator) discriminator = BatchNormalization(momentum = 0.5)(discriminator) discriminator = LeakyReLU(0.2)(discriminator) # Conv layer 3:  discriminator = Conv2D(filters = 256, kernel_size = (4,4), strides = (2,2), padding = &amp;#34;same&amp;#34;, data_format = &amp;#34;channels_last&amp;#34;, kernel_initializer = kernel_init)(discriminator) discriminator = BatchNormalization(momentum = 0.5)(discriminator) discriminator = LeakyReLU(0.2)(discriminator) # Conv layer 4: discriminator = Conv2D(filters = 512, kernel_size = (4,4), strides = (2,2), padding = &amp;#34;same&amp;#34;, data_format = &amp;#34;channels_last&amp;#34;, kernel_initializer = kernel_init)(discriminator) discriminator = BatchNormalization(momentum = 0.5)(discriminator) discriminator = LeakyReLU(0.2)(discriminator)#discriminator = MaxPooling2D(pool_size=(2, 2))(discriminator) # Flatten discriminator = Flatten()(discriminator) # Dense Layer discriminator = Dense(1)(discriminator) # Sigmoid Activation discriminator = Activation(&amp;#39;sigmoid&amp;#39;)(discriminator) # Optimizer and Compiling model dis_opt = Adam(lr=0.0002, beta_1=0.5) discriminator_model = Model(input = dis_input, output = discriminator) discriminator_model.compile(loss=&amp;#39;binary_crossentropy&amp;#39;, optimizer=dis_opt, metrics=[&amp;#39;accuracy&amp;#39;]) discriminator_model.summary() return discriminator_modelplot_model(discriminator, to_file=&amp;#39;dis_plot.png&amp;#39;, show_shapes=True, show_layer_names=True)   Discriminator Architecture    Training Understanding how the training works in GAN is essential. And maybe a little interesting too.
I start by creating our discriminator and generator using the functions defined in the previous section:
discriminator = get_disc_normal(image_shape) generator = get_gen_normal(noise_shape) The generator and discriminator are then combined to create the final GAN.
discriminator.trainable = False # Optimizer for the GAN opt = Adam(lr=0.00015, beta_1=0.5) #same as generator # Input to the generator gen_inp = Input(shape=noise_shape) GAN_inp = generator(gen_inp) GAN_opt = discriminator(GAN_inp) # Final GAN gan = Model(input = gen_inp, output = GAN_opt) gan.compile(loss = &amp;#39;binary_crossentropy&amp;#39;, optimizer = opt, metrics=[&amp;#39;accuracy&amp;#39;]) plot_model(gan, to_file=&amp;#39;gan_plot.png&amp;#39;, show_shapes=True, show_layer_names=True) This is the architecture of our whole GAN:
The Training Loop This is the main region where we need to understand how the blocks we have created until now assemble and work together to work as one.
# Use a fixed noise vector to see how the GAN Images transition through time on a fixed noise. fixed_noise = gen_noise(16,noise_shape) # To keep Track of losses avg_disc_fake_loss = [] avg_disc_real_loss = [] avg_GAN_loss = [] # We will run for num_steps iterations for step in range(num_steps): tot_step = step print(&amp;#34;Begin step: &amp;#34;, tot_step) # to keep track of time per step step_begin_time = time.time() # sample a batch of normalized images from the dataset real_data_X = sample_from_dataset(batch_size, image_shape, data_dir=data_dir) # Genearate noise to send as input to the generator noise = gen_noise(batch_size,noise_shape) # Use generator to create(predict) images fake_data_X = generator.predict(noise) # Save predicted images from the generator every 10th step if (tot_step % 100) == 0: step_num = str(tot_step).zfill(4) save_img_batch(fake_data_X,img_save_dir&#43;step_num&#43;&amp;#34;_image.png&amp;#34;) # Create the labels for real and fake data. We don&amp;#39;t give exact ones and zeros but add a small amount of noise. This is an important GAN training trick real_data_Y = np.ones(batch_size) - np.random.random_sample(batch_size)*0.2 fake_data_Y = np.random.random_sample(batch_size)*0.2 # train the discriminator using data and labels discriminator.trainable = True generator.trainable = False # Training Discriminator seperately on real data dis_metrics_real = discriminator.train_on_batch(real_data_X,real_data_Y) # training Discriminator seperately on fake data dis_metrics_fake = discriminator.train_on_batch(fake_data_X,fake_data_Y) print(&amp;#34;Disc: real loss: %ffake loss: %f&amp;#34; % (dis_metrics_real[0], dis_metrics_fake[0])) # Save the losses to plot later avg_disc_fake_loss.append(dis_metrics_fake[0]) avg_disc_real_loss.append(dis_metrics_real[0]) # Train the generator using a random vector of noise and its labels (1&amp;#39;s with noise) generator.trainable = True discriminator.trainable = False GAN_X = gen_noise(batch_size,noise_shape) GAN_Y = real_data_Y gan_metrics = gan.train_on_batch(GAN_X,GAN_Y) print(&amp;#34;GAN loss: %f&amp;#34; % (gan_metrics[0])) # Log results by opening a file in append mode text_file = open(log_dir&#43;&amp;#34;\\training_log.txt&amp;#34;, &amp;#34;a&amp;#34;) text_file.write(&amp;#34;Step: %dDisc: real loss: %ffake loss: %fGAN loss: %f\n&amp;#34; % (tot_step, dis_metrics_real[0], dis_metrics_fake[0],gan_metrics[0])) text_file.close() # save GAN loss to plot later avg_GAN_loss.append(gan_metrics[0]) end_time = time.time() diff_time = int(end_time - step_begin_time) print(&amp;#34;Step %dcompleted. Time took: %ssecs.&amp;#34; % (tot_step, diff_time)) # save model at every 500 steps if ((tot_step&#43;1) % 500) == 0: print(&amp;#34;-----------------------------------------------------------------&amp;#34;) print(&amp;#34;Average Disc_fake loss: %f&amp;#34; % (np.mean(avg_disc_fake_loss))) print(&amp;#34;Average Disc_real loss: %f&amp;#34; % (np.mean(avg_disc_real_loss))) print(&amp;#34;Average GAN loss: %f&amp;#34; % (np.mean(avg_GAN_loss))) print(&amp;#34;-----------------------------------------------------------------&amp;#34;) discriminator.trainable = False generator.trainable = False # predict on fixed_noise fixed_noise_generate = generator.predict(noise) step_num = str(tot_step).zfill(4) save_img_batch(fixed_noise_generate,img_save_dir&#43;step_num&#43;&amp;#34;fixed_image.png&amp;#34;) generator.save(save_model_dir&#43;str(tot_step)&#43;&amp;#34;_GENERATOR_weights_and_arch.hdf5&amp;#34;) discriminator.save(save_model_dir&#43;str(tot_step)&#43;&amp;#34;_DISCRIMINATOR_weights_and_arch.hdf5&amp;#34;) Don’t worry, I will try to break the above code step by step here. The main steps in every training iteration are:
Step 1: Sample a batch of normalized images from the dataset directory
# Use a fixed noise vector to see how the GAN Images transition through time on a fixed noise. fixed_noise = gen_noise(16,noise_shape) # To keep Track of losses avg_disc_fake_loss = [] avg_disc_real_loss = [] avg_GAN_loss = [] # We will run for num_steps iterations for step in range(num_steps): tot_step = step print(&amp;#34;Begin step: &amp;#34;, tot_step) # to keep track of time per step step_begin_time = time.time() # sample a batch of normalized images from the dataset real_data_X = sample_from_dataset(batch_size, image_shape, data_dir=data_dir) Step2:Generate noise for input to the generator
# Generate noise to send as input to the generator noise = gen_noise(batch_size,noise_shape) Step3:Generate images using random noise using the generator.
# Use generator to create(predict) images fake_data_X = generator.predict(noise) # Save predicted images from the generator every 100th step if (tot_step % 100) == 0: step_num = str(tot_step).zfill(4) save_img_batch(fake_data_X,img_save_dir&#43;step_num&#43;&amp;#34;_image.png&amp;#34;) Step 4:Train discriminator using generator images(Fake images) and real normalized images(Real Images) and their noisy labels.
# Create the labels for real and fake data. We don&amp;#39;t give exact ones and zeros but add a small amount of noise. This is an important GAN training trick real_data_Y = np.ones(batch_size) - np.random.random_sample(batch_size)*0.2 fake_data_Y = np.random.random_sample(batch_size)*0.2 # train the discriminator using data and labels discriminator.trainable = True generator.trainable = False # Training Discriminator seperately on real data dis_metrics_real = discriminator.train_on_batch(real_data_X,real_data_Y) # training Discriminator seperately on fake data dis_metrics_fake = discriminator.train_on_batch(fake_data_X,fake_data_Y) print(&amp;#34;Disc: real loss: %ffake loss: %f&amp;#34; % (dis_metrics_real[0], dis_metrics_fake[0])) # Save the losses to plot later avg_disc_fake_loss.append(dis_metrics_fake[0]) avg_disc_real_loss.append(dis_metrics_real[0]) Step 5:Train the GAN using noise as X and 1&amp;rsquo;s(noisy) as Y while keeping discriminator as untrainable.
# Train the generator using a random vector of noise and its labels (1&amp;#39;s with noise) generator.trainable = True discriminator.trainable = False GAN_X = gen_noise(batch_size,noise_shape) GAN_Y = real_data_Y gan_metrics = gan.train_on_batch(GAN_X,GAN_Y) print(&amp;#34;GAN loss: %f&amp;#34; % (gan_metrics[0])) We repeat the steps using the for loop to end up with a good discriminator and generator.
Results The final output image looks like the following. As we can see, the GAN can generate pretty good images for our content editor friends to work with.
They might be a little crude for your liking, but still, this project was a starter for our GAN journey.
     Loss over the training period Here is the graph generated for the losses. We can see that the GAN Loss is decreasing on average and the variance is decreasing too as we do more steps. One might want to train for even more iterations to get better results.
Image generated at every 1500 steps You can see the output and running code in Colab:
# Generating GIF from PNGs import imageio # create a list of PNGs generated_images = [img_save_dir&#43;str(x).zfill(4)&#43;&amp;#34;_image.png&amp;#34; for x in range(0,num_steps,100)] images = [] for filename in generated_images: images.append(imageio.imread(filename)) imageio.mimsave(img_save_dir&#43;&amp;#39;movie.gif&amp;#39;, images) from IPython.display import Image with open(img_save_dir&#43;&amp;#39;movie.gif&amp;#39;,&amp;#39;rb&amp;#39;) as f: display(Image(data=f.read(), format=&amp;#39;png&amp;#39;)) Given below is the code to generate some images at different training steps. As we can see, as the number of steps increases the images are getting better.
# create a list of 20 PNGs to show generated_images = [img_save_dir&#43;str(x).zfill(4)&#43;&amp;#34;fixed_image.png&amp;#34; for x in range(0,num_steps,1500)] print(&amp;#34;Displaying generated images&amp;#34;) # You might need to change grid size and figure size here according to num images. plt.figure(figsize=(16,20)) gs1 = gridspec.GridSpec(5, 4) gs1.update(wspace=0, hspace=0) for i,image in enumerate(generated_images): ax1 = plt.subplot(gs1[i]) ax1.set_aspect(&amp;#39;equal&amp;#39;) step = image.split(&amp;#34;fixed&amp;#34;)[0] image = Image.open(image) fig = plt.imshow(image) # you might need to change some params here fig = plt.text(20,47,&amp;#34;Step: &amp;#34;&#43;step,bbox=dict(facecolor=&amp;#39;red&amp;#39;, alpha=0.5),fontsize=12) plt.axis(&amp;#39;off&amp;#39;) fig.axes.get_xaxis().set_visible(False) fig.axes.get_yaxis().set_visible(False) plt.tight_layout() plt.savefig(&amp;#34;GENERATEDimage.png&amp;#34;,bbox_inches=&amp;#39;tight&amp;#39;,pad_inches=0) plt.show() Given below is the result of the GAN at different time steps:
Conclusion In this post, we learned about the basics of GAN. We also learned about the Generator and Discriminator architecture for DC-GANs, and we built a simple DC-GAN to generate anime images from scratch.
This model is not very good at generating fake images, yet we get to understand the basics of GANs with this project, and we are fired up to build more exciting and complex GANs as we go forward.
The DC-GAN flavor of GANs is widely applicable not only to generate Faces or new anime characters, but it can also be used to generate new fashion styles, for general content creation and sometimes for data augmentation purposes as well.
We can now conjure up realistic textures or characters on demand if we have the training data at hand, and that is no small feat.
If you want to know more about deep learning applications and use cases, take a look at the Sequence Models course in the Deep Learning Specialization by Andrew NG. Andrew is a great instructor, and this course is great too.
I am going to be writing more of such posts in the future too. Let me know what you think about the series. Follow me up at Medium or Subscribe to my blog.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Chatbots  aren&#39;t as difficult to make as You Think</title>
      <link>https://mlwhiz.com/blog/2019/04/15/chatbot/</link>
      <pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2019/04/15/chatbot/</guid>
      
      
      <media:content type="image/jpeg" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/chatbot/dvader.jpeg"></media:content>
      

      
      <description>Chatbots are the in thing now. Every website must implement it. Every Data Scientist must know about them. Anytime we talk about AI; Chatbots must be discussed. But they look intimidating to someone very new to the field. We struggle with a lot of questions before we even begin to start working on them. Are they hard to create? What technologies should I know before attempting to work on them?</description>

      <content:encoded>  
        
        <![CDATA[  Chatbots are the in thing now. Every website must implement it. Every Data Scientist must know about them. Anytime we talk about AI; Chatbots must be discussed. But they look intimidating to someone very new to the field. We struggle with a lot of questions before we even begin to start working on them. Are they hard to create? What technologies should I know before attempting to work on them? In the end, we end up discouraged reading through many posts on the internet and effectively accomplishing nothing.
  Let me assure you this is not going to be &amp;ldquo;that kind of a post&amp;rdquo;.
I will try to distill some of the knowledge I acquired while working through a project in the Natural Language Processing course in the Advanced machine learning specialization.
So before I start, let me first say it for once that don&amp;rsquo;t be intimidated by the hype and the enigma surrounding Chatbots. They are pretty much using pretty simple NLP techniques which most of us already know. If you don&amp;rsquo;t, you are welcome to check out my NLP Learning Series, where I go through the problem of text classification in fair detail using Conventional, Deep Learning and Transfer Learning methods.
A Very brief Intro to Chatbots We can logically divide of Chatbots in the following two categories.
 Database/FAQ based - We have a database with some questions and answers, and we would like that a user can query that using Natural Language. This is the sort of Chatbots you find at most of the Banking websites for answering FAQs.
 Chit-Chat Based - Simulate dialogue with the user. These are the kind of chatbots that bring the cool in chatbots. We can use Seq-2-Seq models to create such bots.
  The Chatbot we will be creating We will be creating a dialogue chat bot, which will be able to:
 Answer programming-related questions (using StackOverflow dataset) Chit-Chat and simulate dialogue on all non-programming related questions  Once we will have it up and running our final chatbot should look like this.
  Seems quite fun.
We will be taking help of resources like Telegram and Chatterbot to build our Chatbot. So before we start, I think I should get you up and running with these two tools.
1. Telegram: From the website:
 Telegram is a messaging app with a focus on speed and security, it’s super-fast, simple and free. You can use Telegram on all your devices at the same time — your messages sync seamlessly across any number of your phones, tablets or computers.
 For us, Telegram provides us with an easy way to create a Chatbot UI. It provides us with an access token which we will use to connect to the Telegram App backend and run our chatbot logic. Naturally, we need to have a window where we will write our questions to the chatbot, for us that is provided by Telegram. Also, telegram powers the chatbot by communicating with our chatbot logic. The above screenshot is taken from the telegram app only.
Set up Telegram: Don&amp;rsquo;t worry if you don&amp;rsquo;t understand how it works yet; I will try to give step by step instructions as we go forward.
 Step 1: Download and Install Telegram App on your Laptop.
 Step 2: Talk with BotFather by opening this link in Chrome and subsequently your Telegram App.
 Step 3: The above steps will take you to a Chatbot called Botfather which can help you create a new bot. Inception Anyone? It will look something like this.
 Set up a new bot using command &amp;ldquo;/newbot&amp;rdquo; Create a name for Your bot. Create a username for your bot.      Step 4: You will get an access token for the bot. Copy the Token at a safe place. Step 5: Click on the &amp;ldquo;t.me/MLWhizbot&amp;rdquo; link to open Chat with your chatbot in a new window.  Right now if you try to communicate with the chatbot, you won&amp;rsquo;t receive any answers. And that is how it should be.
  But that&amp;rsquo;s not at all fun. Is it? Let&amp;rsquo;s do some python magic to make it responsive.
Making our Telegram Chatbot responsive Create a file main.py and put the following code in it. Don&amp;rsquo;t worry most of the code here is Boilerplate code to make our Chatbot communicate with Telegram using the Access token. We need to worry about implementing the class SimpleDialogueManager. This class contains a function called generate_answer which is where we will write our bot logic.
#!/usr/bin/env python3 import requests import time import argparse import os import json from requests.compat import urljoin class BotHandler(object): &amp;#34;&amp;#34;&amp;#34; BotHandler is a class which implements all back-end of the bot. It has three main functions: &amp;#39;get_updates&amp;#39; — checks for new messages &amp;#39;send_message&amp;#39; – posts new message to user &amp;#39;get_answer&amp;#39; — computes the most relevant on a user&amp;#39;s question &amp;#34;&amp;#34;&amp;#34; def __init__(self, token, dialogue_manager): self.token = token self.api_url = &amp;#34;https://api.telegram.org/bot{}/&amp;#34;.format(token) self.dialogue_manager = dialogue_manager def get_updates(self, offset=None, timeout=30): params = {&amp;#34;timeout&amp;#34;: timeout, &amp;#34;offset&amp;#34;: offset} raw_resp = requests.get(urljoin(self.api_url, &amp;#34;getUpdates&amp;#34;), params) try: resp = raw_resp.json() except json.decoder.JSONDecodeError as e: print(&amp;#34;Failed to parse response {}: {}.&amp;#34;.format(raw_resp.content, e)) return [] if &amp;#34;result&amp;#34; not in resp: return [] return resp[&amp;#34;result&amp;#34;] def send_message(self, chat_id, text): params = {&amp;#34;chat_id&amp;#34;: chat_id, &amp;#34;text&amp;#34;: text} return requests.post(urljoin(self.api_url, &amp;#34;sendMessage&amp;#34;), params) def get_answer(self, question): if question == &amp;#39;/start&amp;#39;: return &amp;#34;Hi, I am your project bot. How can I help you today?&amp;#34; return self.dialogue_manager.generate_answer(question) def is_unicode(text): return len(text) == len(text.encode()) class SimpleDialogueManager(object): &amp;#34;&amp;#34;&amp;#34; This is a simple dialogue manager to test the telegram bot. The main part of our bot will be written here. &amp;#34;&amp;#34;&amp;#34; def generate_answer(self, question): if &amp;#34;Hi&amp;#34; in question: return &amp;#34;Hello, You&amp;#34; else: return &amp;#34;Don&amp;#39;t be rude. Say Hi first.&amp;#34; def main(): # Put your own Telegram Access token here... token = &amp;#39;839585958:AAEfTDo2X6PgHb9IEdb62ueS4SmdpCkhtmc&amp;#39; simple_manager = SimpleDialogueManager() bot = BotHandler(token, simple_manager) ############################################################### print(&amp;#34;Ready to talk!&amp;#34;) offset = 0 while True: updates = bot.get_updates(offset=offset) for update in updates: print(&amp;#34;An update received.&amp;#34;) if &amp;#34;message&amp;#34; in update: chat_id = update[&amp;#34;message&amp;#34;][&amp;#34;chat&amp;#34;][&amp;#34;id&amp;#34;] if &amp;#34;text&amp;#34; in update[&amp;#34;message&amp;#34;]: text = update[&amp;#34;message&amp;#34;][&amp;#34;text&amp;#34;] if is_unicode(text): print(&amp;#34;Update content: {}&amp;#34;.format(update)) bot.send_message(chat_id, bot.get_answer(update[&amp;#34;message&amp;#34;][&amp;#34;text&amp;#34;])) else: bot.send_message(chat_id, &amp;#34;Hmm, you are sending some weird characters to me...&amp;#34;) offset = max(offset, update[&amp;#39;update_id&amp;#39;] &#43; 1) time.sleep(1) if __name__ == &amp;#34;__main__&amp;#34;: main() You can run the file main.py in the terminal window to make your bot responsive.
$ python main.py   Nice. It is following simple logic. But the good thing is that our bot now does something.
Also, take a look at the terminal window where we have run our main.py File. Whenever a user asks a question, we get the sort of dictionary below containing Unique Chat ID, Chat Text, User Information, etc.
Update content: {&#39;update_id&#39;: 484689748, &#39;message&#39;: {&#39;message_id&#39;: 115, &#39;from&#39;: {&#39;id&#39;: 844474950, &#39;is_bot&#39;: False, &#39;first_name&#39;: &#39;Rahul&#39;, &#39;last_name&#39;: &#39;Agarwal&#39;, &#39;language_code&#39;: &#39;en&#39;}, &#39;chat&#39;: {&#39;id&#39;: 844474950, &#39;first_name&#39;: &#39;Rahul&#39;, &#39;last_name&#39;: &#39;Agarwal&#39;, &#39;type&#39;: &#39;private&#39;}, &#39;date&#39;: 1555266010, &#39;text&#39;: &#39;What is 2&#43;2&#39;}}  Until now whatever we had done was sort of setting up and engineering sort of work.
Only if we can write some sound Data Science logic in the generate_answer function in our main.py we should have a decent chatbot.
2. ChatterBot From the Documentation:
 ChatterBot is a Python library that makes it easy to generate automated responses to a user’s input. ChatterBot uses a selection of machine learning algorithms to produce different types of reactions. This makes it easy for developers to create chat bots and automate conversations with users.
 Simply. It is a Blackbox system which can provide us with responses for Chitchat type questions for our Chatbot. And the best part about it is that it is pretty easy to integrate with our current flow. We could also have trained a SeqtoSeq model to do the same thing. Might be I will do it in a later post. I digress.
So, install it with:
$ pip install chatterbot And change the SimpleDialogueManager Class in main.py to the following. We can have a bot that can talk to the user and answer random queries.
class SimpleDialogueManager(object): &amp;#34;&amp;#34;&amp;#34; This is a simple dialogue manager to test the telegram bot. The main part of our bot will be written here. &amp;#34;&amp;#34;&amp;#34; def __init__(self): from chatterbot import ChatBot from chatterbot.trainers import ChatterBotCorpusTrainer chatbot = ChatBot(&amp;#39;MLWhizChatterbot&amp;#39;) trainer = ChatterBotCorpusTrainer(chatbot) trainer.train(&amp;#39;chatterbot.corpus.english&amp;#39;) self.chitchat_bot = chatbot def generate_answer(self, question): response = self.chitchat_bot.get_response(question) return response The code in init instantiates a chatbot using chatterbot and trains it on the provided english corpus data. The data is pretty small, but you can always train it on your dataset too. Just see the documentation. We can then give our responses using the Chatterbot chatbot in the generate_answer function.
  Not too &amp;ldquo;ba a a a a a d&amp;rdquo; , I must say.
Creating our StackOverFlow ChatBot Ok, so finally we are at a stage where we can do something we love. Use Data Science to power our Application/Chatbot. Let us start with creating a rough architecture of what we are going to do next.
  We will need to create two classifiers and save them as .pkl files.
 Intent-Classifier: This classifier will predict if it a question is a Stack-Overflow question or not. If it is not a Stack-overflow question, we let Chatterbot handle it.
 Programming-Language(Tag) Classifier: This classifier will predict which language a question belongs to if the question is a Stack-Overflow question. We do this so that we can search for those language questions in our database only.
  To keep it simple we will create simple TFIDF models. We will need to save these TFIDF vectorizers.
We will also need to store word vectors for every question for similarity calculations later.
Let us go through the process step by step. You can get the full code in this jupyter notebook in my project repository.
Step 1. Reading and Visualizing the Data dialogues = pd.read_csv(&amp;#34;data/dialogues.tsv&amp;#34;,sep=&amp;#34;\t&amp;#34;) posts = pd.read_csv(&amp;#34;data/tagged_posts.tsv&amp;#34;,sep=&amp;#34;\t&amp;#34;)dialogues.head()  .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: left; }    text tag     0 Okay -- you&#39;re gonna need to learn how to lie. dialogue   1 I&#39;m kidding. You know how sometimes you just ... dialogue   2 Like my fear of wearing pastels? dialogue   3 I figured you&#39;d get to the good stuff eventually. dialogue   4 Thank God! If I had to hear one more story ab... dialogue     posts.head()  .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; }    post_id title tag     0 9 Calculate age in C# c#   1 16 Filling a DataSet or DataTable from a LINQ que... c#   2 39 Reliable timer in a console application c#   3 42 Best way to allow plugins for a PHP application php   4 59 How do I get a distinct, ordered list of names... c#     print(&amp;#34;Num Posts:&amp;#34;,len(posts)) print(&amp;#34;Num Dialogues:&amp;#34;,len(dialogues)) Num Posts: 2171575 Num Dialogues: 218609  Step 2: Create training data for intent classifier - Chitchat/StackOverflow Question We will be creating a TFIDF model with Logistic regression to do this. If you want to know about the TFIDF model you can read it here.
We could also have used one of the Deep Learning models or transfer learning approaches to do this, but since the main objective of this post is to get a chatbot up and running and not worry too much about the accuracy we sort of work with the TFIDF based model only.
texts = list(dialogues[:200000].text.values) &#43; list(posts[:200000].title.values) labels = [&amp;#39;dialogue&amp;#39;]*200000 &#43; [&amp;#39;stackoverflow&amp;#39;]*200000 data = pd.DataFrame({&amp;#39;text&amp;#39;:texts,&amp;#39;target&amp;#39;:labels}) def text_prepare(text): &amp;#34;&amp;#34;&amp;#34;Performs tokenization and simple preprocessing.&amp;#34;&amp;#34;&amp;#34; replace_by_space_re = re.compile(&amp;#39;[/(){}\[\]\|@,;]&amp;#39;) bad_symbols_re = re.compile(&amp;#39;[^0-9a-z #&#43;_]&amp;#39;) stopwords_set = set(stopwords.words(&amp;#39;english&amp;#39;)) text = text.lower() text = replace_by_space_re.sub(&amp;#39; &amp;#39;, text) text = bad_symbols_re.sub(&amp;#39;&amp;#39;, text) text = &amp;#39; &amp;#39;.join([x for x in text.split() if x and x not in stopwords_set]) return text.strip() # Doing some data cleaning data[&amp;#39;text&amp;#39;] = data[&amp;#39;text&amp;#39;].apply(lambda x : text_prepare(x)) X_train, X_test, y_train, y_test = train_test_split(data[&amp;#39;text&amp;#39;],data[&amp;#39;target&amp;#39;],test_size = .1 , random_state=0) print(&amp;#39;Train size = {}, test size = {}&amp;#39;.format(len(X_train), len(X_test))) Train size = 360000, test size = 40000  Step 3. Create Intent classifier Here we Create a TFIDF Vectorizer to create features and also train a Logistic regression model to create the intent_classifier. Please note how we are saving TFIDF Vectorizer to resources/tfidf.pkl and intent_classifier to resources/intent_clf.pkl. We will need these files once we are going to write the SimpleDialogueManager class for our final Chatbot.
# We will keep our models and vectorizers in this folder !mkdir resources def tfidf_features(X_train, X_test, vectorizer_path): &amp;#34;&amp;#34;&amp;#34;Performs TF-IDF transformation and dumps the model.&amp;#34;&amp;#34;&amp;#34; tfv = TfidfVectorizer(dtype=np.float32, min_df=3, max_features=None, strip_accents=&amp;#39;unicode&amp;#39;, analyzer=&amp;#39;word&amp;#39;,token_pattern=r&amp;#39;\w{1,}&amp;#39;, ngram_range=(1, 3), use_idf=1,smooth_idf=1,sublinear_tf=1, stop_words = &amp;#39;english&amp;#39;) X_train = tfv.fit_transform(X_train) X_test = tfv.transform(X_test) pickle.dump(tfv,vectorizer_path) return X_train, X_test X_train_tfidf, X_test_tfidf = tfidf_features(X_train, X_test, open(&amp;#34;resources/tfidf.pkl&amp;#34;,&amp;#39;wb&amp;#39;)) intent_recognizer = LogisticRegression(C=10,random_state=0) intent_recognizer.fit(X_train_tfidf,y_train) pickle.dump(intent_recognizer, open(&amp;#34;resources/intent_clf.pkl&amp;#34; , &amp;#39;wb&amp;#39;)) # Check test accuracy. y_test_pred = intent_recognizer.predict(X_test_tfidf) test_accuracy = accuracy_score(y_test, y_test_pred) print(&amp;#39;Test accuracy = {}&amp;#39;.format(test_accuracy)) Test accuracy = 0.989825  The Intent Classifier has a pretty good test accuracy of 98%. TFIDF is not so bad.
Step 4: Create Programming Language classifier Let us first create the data for Programming Language classifier and then train a Logistic Regression model using TFIDF features. We save this tag Classifier at the location resources/tag_clf.pkl. We do this step mostly because we don&amp;rsquo;t want to do similarity calculations over the whole database of questions but only on the subset of questions by the language tag.
# creating the data for Programming Language classifier X = posts[&amp;#39;title&amp;#39;].values y = posts[&amp;#39;tag&amp;#39;].values X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=0) print(&amp;#39;Train size = {}, test size = {}&amp;#39;.format(len(X_train), len(X_test))) Train size = 1737260, test size = 434315  vectorizer = pickle.load(open(&amp;#34;resources/tfidf.pkl&amp;#34;, &amp;#39;rb&amp;#39;)) X_train_tfidf, X_test_tfidf = vectorizer.transform(X_train), vectorizer.transform(X_test) tag_classifier = OneVsRestClassifier(LogisticRegression(C=5,random_state=0)) tag_classifier.fit(X_train_tfidf,y_train) pickle.dump(tag_classifier, open(&amp;#34;resources/tag_clf.pkl&amp;#34;, &amp;#39;wb&amp;#39;)) # Check test accuracy. y_test_pred = tag_classifier.predict(X_test_tfidf) test_accuracy = accuracy_score(y_test, y_test_pred) print(&amp;#39;Test accuracy = {}&amp;#39;.format(test_accuracy)) Test accuracy = 0.8043816124241622  Not Bad again.
Step 5: Store Question database Embeddings One can use pre-trained word vectors from Google or get a better result by training their embeddings using their data. Since again accuracy and precision is not the primary goal of this post, we will use pretrained vectors.
# Load Google&amp;#39;s pre-trained Word2Vec model. model = gensim.models.KeyedVectors.load_word2vec_format(&amp;#39;GoogleNews-vectors-negative300.bin&amp;#39;, binary=True) We want to convert every question to an embedding and store them so that we don&amp;rsquo;t calculate the embeddings for the whole dataset every time. In essence, whenever the user asks a Stack Overflow question, we want to use some distance similarity measure to get the most similar question.
def question_to_vec(question, embeddings, dim=300): &amp;#34;&amp;#34;&amp;#34; question: a string embeddings: dict where the key is a word and a value is its&amp;#39; embedding dim: size of the representation result: vector representation for the question &amp;#34;&amp;#34;&amp;#34; word_tokens = question.split(&amp;#34; &amp;#34;) question_len = len(word_tokens) question_mat = np.zeros((question_len,dim), dtype = np.float32) for idx, word in enumerate(word_tokens): if word in embeddings: question_mat[idx,:] = embeddings[word] # remove zero-rows which stand for OOV words  question_mat = question_mat[~np.all(question_mat == 0, axis = 1)] # Compute the mean of each word along the sentence if question_mat.shape[0] &amp;gt; 0: vec = np.array(np.mean(question_mat, axis = 0), dtype = np.float32).reshape((1,dim)) else: vec = np.zeros((1,dim), dtype = np.float32) return vec counts_by_tag = posts.groupby(by=[&amp;#39;tag&amp;#39;])[&amp;#34;tag&amp;#34;].count().reset_index(name = &amp;#39;count&amp;#39;).sort_values([&amp;#39;count&amp;#39;], ascending = False) counts_by_tag = list(zip(counts_by_tag[&amp;#39;tag&amp;#39;],counts_by_tag[&amp;#39;count&amp;#39;])) print(counts_by_tag) [(&#39;c#&#39;, 394451), (&#39;java&#39;, 383456), (&#39;javascript&#39;, 375867), (&#39;php&#39;, 321752), (&#39;c_cpp&#39;, 281300), (&#39;python&#39;, 208607), (&#39;ruby&#39;, 99930), (&#39;r&#39;, 36359), (&#39;vb&#39;, 35044), (&#39;swift&#39;, 34809)]  We save the embeddings in a folder aptly named resources/embeddings_folder. This folder will contain a .pkl file for every tag. For example one of the files will be python.pkl.
! mkdir resources/embeddings_folder for tag, count in counts_by_tag: tag_posts = posts[posts[&amp;#39;tag&amp;#39;] == tag] tag_post_ids = tag_posts[&amp;#39;post_id&amp;#39;].values tag_vectors = np.zeros((count, 300), dtype=np.float32) for i, title in enumerate(tag_posts[&amp;#39;title&amp;#39;]): tag_vectors[i, :] = question_to_vec(title, model, 300) # Dump post ids and vectors to a file. filename = &amp;#39;resources/embeddings_folder/&amp;#39;&#43; tag &#43; &amp;#39;.pkl&amp;#39; pickle.dump((tag_post_ids, tag_vectors), open(filename, &amp;#39;wb&amp;#39;)) We are nearing the end now. We need to have a function to get most similar question&amp;rsquo;s post id in the dataset given we know the programming Language of the question. Here it is:
def get_similar_question(question,tag): # get the path where all question embeddings are kept and load the post_ids and post_embeddings embeddings_path = &amp;#39;resources/embeddings_folder/&amp;#39; &#43; tag &#43; &amp;#34;.pkl&amp;#34; post_ids, post_embeddings = pickle.load(open(embeddings_path, &amp;#39;rb&amp;#39;)) # Get the embeddings for the question question_vec = question_to_vec(question, model, 300) # find index of most similar post best_post_index = pairwise_distances_argmin(question_vec, post_embeddings) # return best post id return post_ids[best_post_index] get_similar_question(&amp;#34;how to use list comprehension in python?&amp;#34;,&amp;#39;python&amp;#39;) array([5947137])  we can use this post ID and find this question at https://stackoverflow.com/questions/5947137
The question the similarity checker suggested has the actual text: &amp;ldquo;How can I use a list comprehension to extend a list in python? [duplicate]&amp;rdquo;
Not too bad. It could have been better if we train our embeddings or use starspace embeddings.
Assemble the Puzzle - SimpleDialogueManager Class Finally, we have reached the end of the whole exercise, and we have to fit all the pieces in the puzzle in our SimpleDialogueManager Class. Here is the code for that. Go in the main.py file again to paste this code and see if it works or not.
Go through the comments to understand how the pieces are fitting together to build one wholesome logic.
import gensim import pickle import re import nltk from nltk.corpus import stopwords import numpy as np from sklearn.metrics.pairwise import pairwise_distances_argmin # We will need this function to prepare text at prediction time def text_prepare(text): &amp;#34;&amp;#34;&amp;#34;Performs tokenization and simple preprocessing.&amp;#34;&amp;#34;&amp;#34; replace_by_space_re = re.compile(&amp;#39;[/(){}\[\]\|@,;]&amp;#39;) bad_symbols_re = re.compile(&amp;#39;[^0-9a-z #&#43;_]&amp;#39;) stopwords_set = set(stopwords.words(&amp;#39;english&amp;#39;)) text = text.lower() text = replace_by_space_re.sub(&amp;#39; &amp;#39;, text) text = bad_symbols_re.sub(&amp;#39;&amp;#39;, text) text = &amp;#39; &amp;#39;.join([x for x in text.split() if x and x not in stopwords_set]) return text.strip() # need this to convert questions asked by user to vectors def question_to_vec(question, embeddings, dim=300): &amp;#34;&amp;#34;&amp;#34; question: a string embeddings: dict where the key is a word and a value is its&amp;#39; embedding dim: size of the representation result: vector representation for the question &amp;#34;&amp;#34;&amp;#34; word_tokens = question.split(&amp;#34; &amp;#34;) question_len = len(word_tokens) question_mat = np.zeros((question_len,dim), dtype = np.float32) for idx, word in enumerate(word_tokens): if word in embeddings: question_mat[idx,:] = embeddings[word] # remove zero-rows which stand for OOV words  question_mat = question_mat[~np.all(question_mat == 0, axis = 1)] # Compute the mean of each word along the sentence if question_mat.shape[0] &amp;gt; 0: vec = np.array(np.mean(question_mat, axis = 0), dtype = np.float32).reshape((1,dim)) else: vec = np.zeros((1,dim), dtype = np.float32) return vec class SimpleDialogueManager(object): &amp;#34;&amp;#34;&amp;#34; This is a simple dialogue manager to test the telegram bot. The main part of our bot will be written here. &amp;#34;&amp;#34;&amp;#34; def __init__(self): # Instantiate all the models and TFIDF Objects. print(&amp;#34;Loading resources...&amp;#34;) # Instantiate a Chatterbot for Chitchat type questions from chatterbot import ChatBot from chatterbot.trainers import ChatterBotCorpusTrainer chatbot = ChatBot(&amp;#39;MLWhizChatterbot&amp;#39;) trainer = ChatterBotCorpusTrainer(chatbot) trainer.train(&amp;#39;chatterbot.corpus.english&amp;#39;) self.chitchat_bot = chatbot print(&amp;#34;Loading Word2vec model...&amp;#34;) # Instantiate the Google&amp;#39;s pre-trained Word2Vec model. self.model = gensim.models.KeyedVectors.load_word2vec_format(&amp;#39;GoogleNews-vectors-negative300.bin&amp;#39;, binary=True) print(&amp;#34;Loading Classifier objects...&amp;#34;) # Load the intent classifier and tag classifier self.intent_recognizer = pickle.load(open(&amp;#39;resources/intent_clf.pkl&amp;#39;, &amp;#39;rb&amp;#39;)) self.tag_classifier = pickle.load(open(&amp;#39;resources/tag_clf.pkl&amp;#39;, &amp;#39;rb&amp;#39;)) # Load the TFIDF vectorizer object self.tfidf_vectorizer = pickle.load(open(&amp;#39;resources/tfidf.pkl&amp;#39;, &amp;#39;rb&amp;#39;)) print(&amp;#34;Finished Loading Resources&amp;#34;) # We created this function just above. We just need to have a function to get most similar question&amp;#39;s *post id* in the dataset given we know the programming Language of the question. Here it is: def get_similar_question(self,question,tag): # get the path where all question embeddings are kept and load the post_ids and post_embeddings embeddings_path = &amp;#39;resources/embeddings_folder/&amp;#39; &#43; tag &#43; &amp;#34;.pkl&amp;#34; post_ids, post_embeddings = pickle.load(open(embeddings_path, &amp;#39;rb&amp;#39;)) # Get the embeddings for the question question_vec = question_to_vec(question, self.model, 300) # find index of most similar post best_post_index = pairwise_distances_argmin(question_vec, post_embeddings) # return best post id return post_ids[best_post_index] def generate_answer(self, question): prepared_question = text_prepare(question) features = self.tfidf_vectorizer.transform([prepared_question]) # find intent intent = self.intent_recognizer.predict(features)[0] # Chit-chat part:  if intent == &amp;#39;dialogue&amp;#39;: response = self.chitchat_bot.get_response(question) # Stack Overflow Question else: # find programming language tag = self.tag_classifier.predict(features)[0] # find most similar question post id post_id = self.get_similar_question(question,tag)[0] # respond with response = &amp;#39;I think its about %s\nThis thread might help you: https://stackoverflow.com/questions/%s&amp;#39; % (tag, post_id) return response Here is the code for the whole main.py for you to use and see. Just run the whole main.py using
$ python main.py And we will have our bot up and running.
Again, here is the link to the github repository
The possibilities are really endless This is just a small demo project of what you can do with the chatbots. You can do a whole lot more once you recognize that the backend is just python.
 One idea is to run a chatbot script on all the servers I have to run system commands straight from telegram. We can use os.system to run any system command. Bye Bye SSH.
 You can make chatbots to do some daily tasks by using simple keyword-based intents. It is just simple logic. Find out the weather, find out cricket scores or maybe newly released movies. Whatever floats your boat.
 Or maybe try to integrate Telegram based Chatbot in your website. See livechatbot
 Or maybe just try to have fun with it.
    Conclusion Here we learned how to create a simple chatbot. And it works well. We can improve a whole lot on this present chatbot by increasing classifier accuracy, handling edge cases, making it respond faster or maybe adding more logic to handle more use cases. But the fact remains the same. The AI in chatbots is just simple human logic and nothing magic.
In this post, I closely followed one of the projects from this course to create this chatbot. Do check out this course if you get confused, or tell me your problems in the comments I will certainly try to help.
Follow me up at Medium or Subscribe to my blog to be informed about my next posts.
Till then Ciao!!
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>NLP  Learning Series: Part 4 - Transfer Learning Intuition for Text Classification</title>
      <link>https://mlwhiz.com/blog/2019/03/30/transfer_learning_text_classification/</link>
      <pubDate>Sat, 30 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2019/03/30/transfer_learning_text_classification/</guid>
      
      
      <media:content type="image/jpeg" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/nlp_tl/spiderman.jpeg"></media:content>
      

      
      <description>This post is the fourth post of the NLP Text classification series. To give you a recap, I started up with an NLP text classification competition on Kaggle called Quora Question insincerity challenge. So I thought to share the knowledge via a series of blog posts on text classification. The first post talked about the different preprocessing techniques that work with Deep learning models and increasing embeddings coverage.</description>

      <content:encoded>  
        
        <![CDATA[    This post is the fourth post of the NLP Text classification series. To give you a recap, I started up with an NLP text classification competition on Kaggle called Quora Question insincerity challenge. So I thought to share the knowledge via a series of blog posts on text classification. The first post talked about the different preprocessing techniques that work with Deep learning models and increasing embeddings coverage. In the second post, I talked through some basic conventional models like TFIDF, Count Vectorizer, Hashing, etc. that have been used in text classification and tried to access their performance to create a baseline. In the third post, I delved deeper into Deep learning models and the various architectures we could use to solve the text Classification problem. In this post, I will try to use ULMFit model which is a transfer learning approach to this data.
As a side note: if you want to know more about NLP, I would like to recommend this excellent course on Natural Language Processing in the Advanced machine learning specialization. You can start for free with the 7-day Free Trial. This course covers a wide range of tasks in Natural Language Processing from basic to advanced: sentiment analysis, summarization, dialogue state tracking, to name a few. You can start for free with the 7-day Free Trial.
Before introducing the notion of transfer learning to NLP applications, we will first need to understand a little bit about Language models.
Language Models And NLP Transfer Learning Intuition: In very basic terms the objective of the language model is to predict the next word given a stream of input words. In the past, many different approaches have been used to solve this particular problem. Probabilistic models using Markov assumption is one example of this sort of models.
$$ P(W_n) = P(W_n|W_{n-1}) $$
In the recent era, people have been using RNNs/LSTMs to create such language models. They take as input a word embedding and at each time state return the probability distribution of next word probability over the dictionary words. An example of this is shown below in which the below Neural Network uses multiple stacked layers of RNN cells to learn a language model to predict the next word.
  Now why do we need the concept of Language Modeling? Or How does predicting the next word tie with the current task of text classification? The intuition ties to the way that the neural network gets trained. The neural network that can predict the next word after being trained on a massive corpus like Wikipedia already has learned a lot of structure in a particular language. Can we use this knowledge in the weights of the network for our advantage? Yes, we can, and that is where the idea of Transfer Learning in NLP stems from. So to make this intuition more concrete, Let us think that our neural network is divided into two parts -
 Language Specific: The lower part of the neural network is language specific. That is it learns the features of the language. This part could be used to transfer our knowledge from a language corpus to our current task Task Specific: I will call the upper part of our network as task specific. The weights in these layers are trained so that it learns to predict the next word.    Now as it goes in a lot of transfer learning models for Image, we stack the Language Specific part with some dense and softmax layers(Our new task) and train on our new task to achieve what we want to do.
ULMFit: Now the concept of Transfer learning in NLP is not entirely new and people already used Language models for transfer learning back in 2015-16 without good result. So what has changed now?
The thing that has changed is that people like Jeremy Howard and Sebastian Ruder have done a lot of research on how to train these networks. And so we have achieved state of the art results on many text datasets with Transfer Learning approaches.
Let&amp;rsquo;s follow up with the key research findings in the ULMFit paper written by them along with the code.
Change in the way Transfer Learning networks are trained:   Training a model as per ULMFiT we need to take these three steps:
a) Create a Base Language Model: Training the language model on a general-domain corpus that captures high-level natural language features
b) Finetune Base Language Model on Task Specific Data: Fine-tuning the pre-trained language model on target task data
c) Finetune Base Language Model Layers &#43; Task Specific Layers on Task Specific Data: Fine-tuning the classifier on target task data
So let us go through these three steps one by one along with the code that is provided to us with the FastAI library.
a) Create a Base Language Model: This task might be the most time-consuming task. This model is analogous to resnet50 or Inception for the vision task. In the paper, they use the language model AWD-LSTM, a regular LSTM architecture trained with various tuned dropout hyperparameters. This model was trained on Wikitext-103 consisting of 28,595 preprocessed Wikipedia articles and 103 million words. We won&amp;rsquo;t perform this task ourselves and will use the fabulous FastAI library to use this model as below. The code below will take our data and preprocess it for usage in the AWD_LSTM model as well as load the model.
# Language model data : We use test_df as validation for language model data_lm = TextLMDataBunch.from_df(path = &amp;#34;&amp;#34;,train_df= train_df ,valid_df = test_df) learn = language_model_learner(data_lm, AWD_LSTM, drop_mult=0.5) It is also where we preprocess the data as per the required usage for the FastAI models. For example:
print(train_df)   print(data_lm) TextLMDataBunch; Train: LabelList (1306122 items) x: LMTextList xxbos xxmaj how did xxmaj quebec nationalists see their province as a nation in the 1960s ?,xxbos xxmaj do you have an adopted dog , how would you encourage people to adopt and not shop ?,xxbos xxmaj why does velocity affect time ? xxmaj does velocity affect space geometry ?,xxbos xxmaj how did xxmaj otto von xxmaj guericke used the xxmaj magdeburg hemispheres ?,xxbos xxmaj can i convert montra xxunk d to a mountain bike by just changing the tyres ? y: LMLabelList ,,,, Path: .; Valid: LabelList (375806 items) x: LMTextList xxbos xxmaj why do so many women become so rude and arrogant when they get just a little bit of wealth and power ?,xxbos xxmaj when should i apply for xxup rv college of engineering and xxup bms college of engineering ? xxmaj should i wait for the xxup comedk result or am i supposed to apply before the result ?,xxbos xxmaj what is it really like to be a nurse practitioner ?,xxbos xxmaj who are entrepreneurs ?,xxbos xxmaj is education really making good people nowadays ? y: LMLabelList ,,,, Path: .; Test: None  The tokenized prepared data is based on a lot of research from the FastAI developers. To make this post a little bit complete, I am sharing some of the tokens definition as well.
 xxunk is for an unknown word (one that isn&amp;rsquo;t present in the current vocabulary) xxpad is the token used for padding, if we need to regroup several texts of different lengths in a batch xxbos represents the beginning of a text in your dataset xxmaj is used to indicate the next word begins with a capital in the original text xxup is used to indicate the next word is written in all caps in the original text  b) Finetune Base Language Model on Task Specific Data This task is also pretty easy when we look at the code. The specific details of how we do the training is what holds the essence.
# Learning with Discriminative fine tuning learn.fit_one_cycle(1, 1e-2) learn.unfreeze() learn.fit_one_cycle(1, 1e-3) # Save encoder Object learn.save_encoder(&amp;#39;ft_enc&amp;#39;) The paper introduced two general concepts for this learning stage:
 Discriminative fine-tuning:  The Main Idea is: As different layers capture different types of information, they should be fine-tuned to different extents. Instead of using the same learning rate for all layers of the model, discriminative fine-tuning allows us to tune each layer with different learning rates. In the paper, the authors suggest first to finetune only the last layer, and then unfreeze all the layers with a learning rate lowered by a factor of 2.6.
 Slanted triangular learning rates:    According to the authors: &amp;ldquo;For adapting its parameters to task-specific features, we would like the model to quickly converge to a suitable region of the parameter space in the beginning of training and then refine its parameters&amp;rdquo; The Main Idea is to use a high learning rate at the starting stage for increased learning and low learning rates to finetune at later stages in an epoch.
After training our Language model on the Quora dataset, we should be able to see how our model performs on the Language Model task itself. FastAI library provides us with a simple function to do that.
# check how the language model performs learn.predict(&amp;#34;What should&amp;#34;, n_words=10) &#39;What should be the likelihood of a tourist visiting Mumbai for&#39;  c) Finetune Base Language Model Layers &#43; Task Specific Layers on Task Specific Data This is the stage where task-specific learning takes place that is we add the classification layers and fine tune them.
The authors augment the pretrained language model with two additional linear blocks. Each block uses batch normalization (Ioffe and Szegedy, 2015) and dropout, with ReLU activations for the intermediate layer and a softmax activation that outputs a probability distribution over target classes at the last layer. The params of these task-specific layers are the only ones that are learned from scratch.
#Creating Classification Data data_clas = TextClasDataBunch.from_df(path =&amp;#34;&amp;#34;, train_df=train, valid_df =valid, test_df=test_df, vocab=data_lm.train_ds.vocab, bs=32,label_cols = &amp;#39;target&amp;#39;) # Creating Classifier Object learn = text_classifier_learner(data_clas, AWD_LSTM, drop_mult=0.5) # Add weights of finetuned Language model learn.load_encoder(&amp;#39;ft_enc&amp;#39;) # Fitting Classifier Object learn.fit_one_cycle(1, 1e-2) # Fitting Classifier Object after freezing all but last 2 layers learn.freeze_to(-2) learn.fit_one_cycle(1, slice(5e-3/2., 5e-3)) # Fitting Classifier Object - discriminative learning learn.unfreeze() learn.fit_one_cycle(1, slice(2e-3/100, 2e-3)) Here also the Authors have derived a few novel methods:
 Concat Pooling:  The authors use not only the concatenation of all the hidden state but also the Maxpool and Meanpool representation of all hidden states as input to the linear layers.
$$ H = [h_1, &amp;hellip; , h_T ] $$
$$ h_c = [h_T , maxpool(H), meanpool(H)] $$
 Gradual Unfreezing:  Rather than fine-tuning all layers at once, which risks catastrophic forgetting(Forgetting everything we have learned so far from language models), the authors propose to gradually unfreeze the model starting from the last layer as this contains the least general knowledge. The Authors first unfreeze the last layer and fine-tune all unfrozen layers for one epoch. They then unfreeze the next lower frozen layer and repeat, until they finetune all layers until convergence at the last iteration. The function slice(2e-3/100, 2e-3) means that we train every layer with different learning rates ranging from max to min value.
One can get the predictions for the test data at once using:
test_preds = np.array(learn.get_preds(DatasetType.Test, ordered=True)[0])[:,1] I am a big fan of Kaggle Kernels. One could not have imagined having all that compute for free. You can find a running version of the above code in this kaggle kernel. Do try to experiment with it after forking and running the code. Also please upvote the kernel if you find it helpful.
Results: Here are the final results of all the different approaches I have tried on the Kaggle Dataset. I ran a 5 fold Stratified CV.
a. Conventional Methods:   b. Deep Learning Methods:   c. Transfer Learning Methods(ULMFIT):   The results achieved were not very good compared to deep learning methods, but I still liked the idea of the transfer learning approach, and it was so easy to implement it using fastAI. Also running the code took a lot of time at 9 hours, compared to other methods which got over in 2 hours.
Even if this approach didn&amp;rsquo;t work well for this dataset, it is a valid approach for other datasets, as the Authors of the paper have achieved pretty good results on different datasets — definitely a genuine method to try out.
PS: Note that I didn&amp;rsquo;t work on tuning the above models, so these results are only cursory. You can try to squeeze more performance by performing hyperparams tuning using hyperopt or just old fashioned Grid-search.
Conclusion: Finally, this post concludes my NLP Learning series. It took a lot of time to write, but the effort was well worth it. I hope you found it helpful in your work. I will try to write some more on this topic when I get some time. Follow me up at Medium or Subscribe to my blog to be informed about my next posts.
Also if you want to learn more about NLP here is an excellent course. You can start for free with the 7-day Free Trial.
Let me know if you think I can add something more to the post; I will try to incorporate it.
Cheers!!!
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>NLP  Learning Series: Part 3 - Attention, CNN and what not for Text Classification</title>
      <link>https://mlwhiz.com/blog/2019/03/09/deeplearning_architectures_text_classification/</link>
      <pubDate>Sat, 09 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2019/03/09/deeplearning_architectures_text_classification/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/birnn.png"></media:content>
      

      
      <description>This post is the third post of the NLP Text classification series. To give you a recap, I started up with an NLP text classification competition on Kaggle called Quora Question insincerity challenge. So I thought to share the knowledge via a series of blog posts on text classification. The first post talked about the different preprocessing techniques that work with Deep learning models and increasing embeddings coverage. In the second post, I talked through some basic conventional models like TFIDF, Count Vectorizer, Hashing, etc.</description>

      <content:encoded>  
        
        <![CDATA[  This post is the third post of the NLP Text classification series. To give you a recap, I started up with an NLP text classification competition on Kaggle called Quora Question insincerity challenge. So I thought to share the knowledge via a series of blog posts on text classification. The first post talked about the different preprocessing techniques that work with Deep learning models and increasing embeddings coverage. In the second post, I talked through some basic conventional models like TFIDF, Count Vectorizer, Hashing, etc. that have been used in text classification and tried to access their performance to create a baseline. In this post, I delve deeper into Deep learning models and the various architectures we could use to solve the text Classification problem. To make this post platform generic, I am going to code in both Keras and Pytorch. I will use various other models which we were not able to use in this competition like ULMFit transfer learning approaches in the fourth post in the series.
As a side note: if you want to know more about NLP, I would like to recommend this excellent course on Natural Language Processing in the Advanced machine learning specialization. You can start for free with the 7-day Free Trial. This course covers a wide range of tasks in Natural Language Processing from basic to advanced: sentiment analysis, summarization, dialogue state tracking, to name a few. You can start for free with the 7-day Free Trial.
So let me try to go through some of the models which people are using to perform text classification and try to provide a brief intuition for them — also, some code in Keras and Pytorch. So you can try them out for yourself.
1. TextCNN The idea of using a CNN to classify text was first presented in the paper Convolutional Neural Networks for Sentence Classification by Yoon Kim.
Representation: The central intuition about this idea is to see our documents as images. How? Let us say we have a sentence and we have maxlen = 70 and embedding size = 300. We can create a matrix of numbers with the shape 70x300 to represent this sentence. For images, we also have a matrix where individual elements are pixel values. Instead of image pixels, the input to the tasks is sentences or documents represented as a matrix. Each row of the matrix corresponds to one-word vector.
  Convolution Idea: While for an image we move our conv filter horizontally as well as vertically, for text we fix kernel size to filter_size x embed_size, i.e. (3,300) we are just going to move vertically down for the convolution taking look at three words at once since our filter size is 3 in this case. This idea seems right since our convolution filter is not splitting word embedding. It gets to look at the full embedding of each word. Also one can think of filter sizes as unigrams, bigrams, trigrams, etc. Since we are looking at a context window of 1,2,3, and 5 words respectively.
Here is the text classification network coded in Pytorch:
import torch import torch.nn as nn import torch.nn.functional as F from torch.autograd import Variable class CNN_Text(nn.Module): def __init__(self): super(CNN_Text, self).__init__() filter_sizes = [1,2,3,5] num_filters = 36 self.embedding = nn.Embedding(max_features, embed_size) self.embedding.weight = nn.Parameter(torch.tensor(embedding_matrix, dtype=torch.float32)) self.embedding.weight.requires_grad = False self.convs1 = nn.ModuleList([nn.Conv2d(1, num_filters, (K, embed_size)) for K in filter_sizes]) self.dropout = nn.Dropout(0.1) self.fc1 = nn.Linear(len(Ks)*num_filters, 1) def forward(self, x): x = self.embedding(x) x = x.unsqueeze(1) x = [F.relu(conv(x)).squeeze(3) for conv in self.convs1] x = [F.max_pool1d(i, i.size(2)).squeeze(2) for i in x] x = torch.cat(x, 1) x = self.dropout(x) logit = self.fc1(x) return logit And for the Keras enthusiasts:
# https://www.kaggle.com/yekenot/2dcnn-textclassifier def model_cnn(embedding_matrix): filter_sizes = [1,2,3,5] num_filters = 36 inp = Input(shape=(maxlen,)) x = Embedding(max_features, embed_size, weights=[embedding_matrix])(inp) x = Reshape((maxlen, embed_size, 1))(x) maxpool_pool = [] for i in range(len(filter_sizes)): conv = Conv2D(num_filters, kernel_size=(filter_sizes[i], embed_size), kernel_initializer=&amp;#39;he_normal&amp;#39;, activation=&amp;#39;relu&amp;#39;)(x) maxpool_pool.append(MaxPool2D(pool_size=(maxlen - filter_sizes[i] &#43; 1, 1))(conv)) z = Concatenate(axis=1)(maxpool_pool) z = Flatten()(z) z = Dropout(0.1)(z) outp = Dense(1, activation=&amp;#34;sigmoid&amp;#34;)(z) model = Model(inputs=inp, outputs=outp) model.compile(loss=&amp;#39;binary_crossentropy&amp;#39;, optimizer=&amp;#39;adam&amp;#39;, metrics=[&amp;#39;accuracy&amp;#39;]) return model I am a big fan of Kaggle Kernels. One could not have imagined having all that compute for free. You can find a running version of the above two code snippets in this kaggle kernel. Do try to experiment with it after forking and running the code. Also please upvote the kernel if you find it helpful.
The Keras model and Pytorch model performed similarly with Pytorch model beating the keras model by a small margin. The Out-Of-Fold CV F1 score for the Pytorch model came out to be 0.6609 while for Keras model the same score came out to be 0.6559. I used the same preprocessing in both the models to be better able to compare the platforms.
2. BiDirectional RNN(LSTM/GRU): TextCNN works well for Text Classification. It takes care of words in close range. It can see &amp;ldquo;new york&amp;rdquo; together. However, it still can&amp;rsquo;t take care of all the context provided in a particular text sequence. It still does not learn the sequential structure of the data, where every word is dependent on the previous word. Or a word in the previous sentence.
RNN help us with that. They can remember previous information using hidden states and connect it to the current task.
Long Short Term Memory networks (LSTM) are a subclass of RNN, specialized in remembering information for an extended period. Moreover, the Bidirectional LSTM keeps the contextual information in both directions which is pretty useful in text classification task (But won&amp;rsquo;t work for a time series prediction task as we don&amp;rsquo;t have visibility into the future in this case).
  For a most simplistic explanation of Bidirectional RNN, think of RNN cell as a black box taking as input a hidden state(a vector) and a word vector and giving out an output vector and the next hidden state. This box has some weights which are to be tuned using Backpropagation of the losses. Also, the same cell is applied to all the words so that the weights are shared across the words in the sentence. This phenomenon is called weight-sharing.
   Hidden state, Word vector -&amp;gt;(RNN Cell) -&amp;gt; Output Vector , Next Hidden state  For a sequence of length 4 like &amp;ldquo;you will never believe&amp;rdquo;, The RNN cell gives 4 output vectors, which can be concatenated and then used as part of a dense feedforward architecture.
In the Bidirectional RNN, the only change is that we read the text in the usual fashion as well in reverse. So we stack two RNNs in parallel, and hence we get 8 output vectors to append.
Once we get the output vectors, we send them through a series of dense layers and finally a softmax layer to build a text classifier.
In most cases, you need to understand how to stack some layers in a neural network to get the best results. We can try out multiple bidirectional GRU/LSTM layers in the network if it performs better.
Due to the limitations of RNNs like not remembering long term dependencies, in practice, we almost always use LSTM/GRU to model long term dependencies. In such a case you can think of the RNN cell being replaced by an LSTM cell or a GRU cell in the above figure. An example model is provided below. You can use CuDNNGRU interchangeably with CuDNNLSTM when you build models. (CuDNNGRU/LSTM are just implementations of LSTM/GRU that are created to run faster on GPUs. In most cases always use them instead of the vanilla LSTM/GRU implementations)
So here is some code in Pytorch for this network.
class BiLSTM(nn.Module): def __init__(self): super(BiLSTM, self).__init__() self.hidden_size = 64 drp = 0.1 self.embedding = nn.Embedding(max_features, embed_size) self.embedding.weight = nn.Parameter(torch.tensor(embedding_matrix, dtype=torch.float32)) self.embedding.weight.requires_grad = False self.lstm = nn.LSTM(embed_size, self.hidden_size, bidirectional=True, batch_first=True) self.linear = nn.Linear(self.hidden_size*4 , 64) self.relu = nn.ReLU() self.dropout = nn.Dropout(drp) self.out = nn.Linear(64, 1) def forward(self, x): h_embedding = self.embedding(x) h_embedding = torch.squeeze(torch.unsqueeze(h_embedding, 0)) h_lstm, _ = self.lstm(h_embedding) avg_pool = torch.mean(h_lstm, 1) max_pool, _ = torch.max(h_lstm, 1) conc = torch.cat(( avg_pool, max_pool), 1) conc = self.relu(self.linear(conc)) conc = self.dropout(conc) out = self.out(conc) return out Also, here is the same code in Keras.
# BiDirectional LSTM def model_lstm_du(embedding_matrix): inp = Input(shape=(maxlen,)) x = Embedding(max_features, embed_size, weights=[embedding_matrix])(inp) &amp;#39;&amp;#39;&amp;#39; Here 64 is the size(dim) of the hidden state vector as well as the output vector. Keeping return_sequence we want the output for the entire sequence. So what is the dimension of output for this layer? 64*70(maxlen)*2(bidirection concat) CuDNNLSTM is fast implementation of LSTM layer in Keras which only runs on GPU &amp;#39;&amp;#39;&amp;#39; x = Bidirectional(CuDNNLSTM(64, return_sequences=True))(x) avg_pool = GlobalAveragePooling1D()(x) max_pool = GlobalMaxPooling1D()(x) conc = concatenate([avg_pool, max_pool]) conc = Dense(64, activation=&amp;#34;relu&amp;#34;)(conc) conc = Dropout(0.1)(conc) outp = Dense(1, activation=&amp;#34;sigmoid&amp;#34;)(conc) model = Model(inputs=inp, outputs=outp) model.compile(loss=&amp;#39;binary_crossentropy&amp;#39;, optimizer=&amp;#39;adam&amp;#39;, metrics=[&amp;#39;accuracy&amp;#39;]) return model You can run this code in my BiLSTM with Pytorch and Keras kaggle kernel for this competition. Please do upvote the kernel if you find it helpful.
In the BiLSTM case also, Pytorch model beats the keras model by a small margin. The Out-Of-Fold CV F1 score for the Pytorch model came out to be 0.6741 while for Keras model the same score came out to be 0.6727. This score is around a 1-2% increase from the TextCNN performance which is pretty good. Also, note that it is around 6-7% better than conventional methods.
3. Attention Models Dzmitry Bahdanau et al first presented attention in their paper Neural Machine Translation by Jointly Learning to Align and Translate but I find that the paper on Hierarchical Attention Networks for Document Classification written jointly by CMU and Microsoft in 2016 is a much easier read and provides more intuition.
So let us talk about the intuition first. In the past conventional methods like TFIDF/CountVectorizer etc. we used to find features from the text by doing a keyword extraction. Some word is more helpful in determining the category of a text than others. However, in this method we sort of lost the sequential structure of the text. With LSTM and deep learning methods, while we can take care of the sequence structure, we lose the ability to give higher weight to more important words. Can we have the best of both worlds?
The answer is Yes. Actually, Attention is all you need. In the author&amp;rsquo;s words:
 Not all words contribute equally to the representation of the sentence meaning. Hence, we introduce attention mechanism to extract such words that are important to the meaning of the sentence and aggregate the representation of those informative words to form a sentence vector
   In essence, we want to create scores for every word in the text, which is the attention similarity score for a word.
To do this, we start with a weight matrix(W), a bias vector(b) and a context vector u. The optimization algorithm learns all of these weights. On this note I would like to highlight something I like a lot about neural networks - If you don&amp;rsquo;t know some params, let the network learn them. We only have to worry about creating architectures and params to tune.
Then there are a series of mathematical operations. See the figure for more clarification. We can think of u1 as nonlinearity on RNN word output. After that v1 is a dot product of u1 with a context vector u raised to exponentiation. From an intuition viewpoint, the value of v1 will be high if u and u1 are similar. Since we want the sum of scores to be 1, we divide v by the sum of v’s to get the Final Scores,s
These final scores are then multiplied by RNN output for words to weight them according to their importance. After which the outputs are summed and sent through dense layers and softmax for the task of text classification.
Here is the code in Pytorch. Do try to read through the pytorch code for attention layer. It just does what I have explained above.
class Attention(nn.Module): def __init__(self, feature_dim, step_dim, bias=True, **kwargs): super(Attention, self).__init__(**kwargs) self.supports_masking = True self.bias = bias self.feature_dim = feature_dim self.step_dim = step_dim self.features_dim = 0 weight = torch.zeros(feature_dim, 1) nn.init.kaiming_uniform_(weight) self.weight = nn.Parameter(weight) if bias: self.b = nn.Parameter(torch.zeros(step_dim)) def forward(self, x, mask=None): feature_dim = self.feature_dim step_dim = self.step_dim eij = torch.mm( x.contiguous().view(-1, feature_dim), self.weight ).view(-1, step_dim) if self.bias: eij = eij &#43; self.b eij = torch.tanh(eij) a = torch.exp(eij) if mask is not None: a = a * mask a = a / (torch.sum(a, 1, keepdim=True) &#43; 1e-10) weighted_input = x * torch.unsqueeze(a, -1) return torch.sum(weighted_input, 1) class Attention_Net(nn.Module): def __init__(self): super(Attention_Net, self).__init__() drp = 0.1 self.embedding = nn.Embedding(max_features, embed_size) self.embedding.weight = nn.Parameter(torch.tensor(embedding_matrix, dtype=torch.float32)) self.embedding.weight.requires_grad = False self.embedding_dropout = nn.Dropout2d(0.1) self.lstm = nn.LSTM(embed_size, 128, bidirectional=True, batch_first=True) self.lstm2 = nn.GRU(128*2, 64, bidirectional=True, batch_first=True) self.attention_layer = Attention(128, maxlen) self.linear = nn.Linear(64*2 , 64) self.relu = nn.ReLU() self.out = nn.Linear(64, 1) def forward(self, x): h_embedding = self.embedding(x) h_embedding = torch.squeeze(torch.unsqueeze(h_embedding, 0)) h_lstm, _ = self.lstm(h_embedding) h_lstm, _ = self.lstm2(h_lstm) h_lstm_atten = self.attention_layer(h_lstm) conc = self.relu(self.linear(h_lstm_atten)) out = self.out(conc) return out Same code for Keras.
def dot_product(x, kernel): &amp;#34;&amp;#34;&amp;#34; Wrapper for dot product operation, in order to be compatible with both Theano and Tensorflow Args: x (): input kernel (): weights Returns: &amp;#34;&amp;#34;&amp;#34; if K.backend() == &amp;#39;tensorflow&amp;#39;: return K.squeeze(K.dot(x, K.expand_dims(kernel)), axis=-1) else: return K.dot(x, kernel) class AttentionWithContext(Layer): &amp;#34;&amp;#34;&amp;#34; Attention operation, with a context/query vector, for temporal data. Supports Masking. Follows the work of Yang et al. [https://www.cs.cmu.edu/~diyiy/docs/naacl16.pdf] &amp;#34;Hierarchical Attention Networks for Document Classification&amp;#34; by using a context vector to assist the attention # Input shape 3D tensor with shape: `(samples, steps, features)`. # Output shape 2D tensor with shape: `(samples, features)`. How to use: Just put it on top of an RNN Layer (GRU/LSTM/SimpleRNN) with return_sequences=True. The dimensions are inferred based on the output shape of the RNN. Note: The layer has been tested with Keras 2.0.6 Example: model.add(LSTM(64, return_sequences=True)) model.add(AttentionWithContext()) # next add a Dense layer (for classification/regression) or whatever... &amp;#34;&amp;#34;&amp;#34; def __init__(self, W_regularizer=None, u_regularizer=None, b_regularizer=None, W_constraint=None, u_constraint=None, b_constraint=None, bias=True, **kwargs): self.supports_masking = True self.init = initializers.get(&amp;#39;glorot_uniform&amp;#39;) self.W_regularizer = regularizers.get(W_regularizer) self.u_regularizer = regularizers.get(u_regularizer) self.b_regularizer = regularizers.get(b_regularizer) self.W_constraint = constraints.get(W_constraint) self.u_constraint = constraints.get(u_constraint) self.b_constraint = constraints.get(b_constraint) self.bias = bias super(AttentionWithContext, self).__init__(**kwargs) def build(self, input_shape): assert len(input_shape) == 3 self.W = self.add_weight((input_shape[-1], input_shape[-1],), initializer=self.init, name=&amp;#39;{}_W&amp;#39;.format(self.name), regularizer=self.W_regularizer, constraint=self.W_constraint) if self.bias: self.b = self.add_weight((input_shape[-1],), initializer=&amp;#39;zero&amp;#39;, name=&amp;#39;{}_b&amp;#39;.format(self.name), regularizer=self.b_regularizer, constraint=self.b_constraint) self.u = self.add_weight((input_shape[-1],), initializer=self.init, name=&amp;#39;{}_u&amp;#39;.format(self.name), regularizer=self.u_regularizer, constraint=self.u_constraint) super(AttentionWithContext, self).build(input_shape) def compute_mask(self, input, input_mask=None): # do not pass the mask to the next layers return None def call(self, x, mask=None): uit = dot_product(x, self.W) if self.bias: uit &#43;= self.b uit = K.tanh(uit) ait = dot_product(uit, self.u) a = K.exp(ait) # apply mask after the exp. will be re-normalized next if mask is not None: # Cast the mask to floatX to avoid float64 upcasting in theano a *= K.cast(mask, K.floatx()) # in some cases especially in the early stages of training the sum may be almost zero # and this results in NaN&amp;#39;s. A workaround is to add a very small positive number ε to the sum. # a /= K.cast(K.sum(a, axis=1, keepdims=True), K.floatx()) a /= K.cast(K.sum(a, axis=1, keepdims=True) &#43; K.epsilon(), K.floatx()) a = K.expand_dims(a) weighted_input = x * a return K.sum(weighted_input, axis=1) def compute_output_shape(self, input_shape): return input_shape[0], input_shape[-1] def model_lstm_atten(embedding_matrix): inp = Input(shape=(maxlen,)) x = Embedding(max_features, embed_size, weights=[embedding_matrix], trainable=False)(inp) x = Bidirectional(CuDNNLSTM(128, return_sequences=True))(x) x = Bidirectional(CuDNNLSTM(64, return_sequences=True))(x) x = AttentionWithContext()(x) x = Dense(64, activation=&amp;#34;relu&amp;#34;)(x) x = Dense(1, activation=&amp;#34;sigmoid&amp;#34;)(x) model = Model(inputs=inp, outputs=x) model.compile(loss=&amp;#39;binary_crossentropy&amp;#39;, optimizer=&amp;#39;adam&amp;#39;, metrics=[&amp;#39;accuracy&amp;#39;]) return model Again, my Attention with Pytorch and Keras Kaggle kernel contains the working versions for this code. Please do upvote the kernel if you find it useful.
This method performed well with Pytorch CV scores reaching around 0.6758 and Keras CV scores reaching around 0.678. This score is more than what we were able to achieve with BiLSTM and TextCNN. However, please note that we didn&amp;rsquo;t work on tuning any of the given methods yet and so the scores might be different.
With this, I leave you to experiment with new architectures and playing around with stacking multiple GRU/LSTM layers to improve your network performance. You can also look at including more techniques in these network like Bucketing, handmade features, etc. Some of the tips and new techniques are mentioned here on my blog post: What my first Silver Medal taught me about Text Classification and Kaggle in general?. Also, here is another Kaggle kernel which is my silver-winning entry for this competition.
Results Here are the final results of all the different approaches I have tried on the Kaggle Dataset. I ran a 5 fold Stratified CV.
a. Conventional Methods:   b. Deep Learning Methods:   PS: Note that I didn&amp;rsquo;t work on tuning the above models, so these results are only cursory. You can try to squeeze more performance by performing hyperparams tuning using hyperopt or just old fashioned Grid-search.
Conclusion In this post, I went through with the explanations of various deep learning architectures people are using for Text classification tasks. In the next post, we will delve further into the next new phenomenon in NLP space - Transfer Learning with BERT and ULMFit. Follow me up at Medium or Subscribe to my blog to be informed about my next post.
Also if you want to learn more about NLP here is an excellent course. You can start for free with the 7-day Free Trial.
Let me know if you think I can add something more to the post; I will try to incorporate it.
Cheers!!!
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>What my first Silver Medal taught me about Text Classification and Kaggle in general?</title>
      <link>https://mlwhiz.com/blog/2019/02/19/siver_medal_kaggle_learnings/</link>
      <pubDate>Tue, 19 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2019/02/19/siver_medal_kaggle_learnings/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/silver/CV_vs_LB.png"></media:content>
      

      
      <description>Kaggle is an excellent place for learning. And I learned a lot of things from the recently concluded competition on Quora Insincere questions classification in which I got a rank of 182/4037. In this post, I will try to provide a summary of the things I tried. I will also try to summarize the ideas which I missed but were a part of other winning solutions.
As a side note: if you want to know more about NLP, I would like to recommend this awesome course on Natural Language Processing in the Advanced machine learning specialization.</description>

      <content:encoded>  
        
        <![CDATA[    Kaggle is an excellent place for learning. And I learned a lot of things from the recently concluded competition on Quora Insincere questions classification in which I got a rank of 182/4037. In this post, I will try to provide a summary of the things I tried. I will also try to summarize the ideas which I missed but were a part of other winning solutions.
As a side note: if you want to know more about NLP, I would like to recommend this awesome course on Natural Language Processing in the Advanced machine learning specialization. You can start for free with the 7-day Free Trial. This course covers a wide range of tasks in Natural Language Processing from basic to advanced: sentiment analysis, summarization, dialogue state tracking, to name a few. You can start for free with the 7-day Free Trial.
So first a little bit of summary about the competition for the uninitiated. In this competition, we had to develop models that identify and flag insincere questions. The challenge was not only a test for performance but also a test of efficient code writing skills. As it was a kernel competition with limited outside data options, competitors were limited to use only the word embeddings provided by the competition organizers. That means we were not allowed to use State of the art models like BERT. We were also limited in the sense that all our models should run in a time of 2 hours. So say bye bye to stacking and monster ensembles though some solutions were able to do this by making their code ultra-efficient. More on this later.
Some Kaggle Learnings: There were a couple of learnings about kaggle as a whole that I would like to share before jumping into my final solution:
1. Always trust your CV   One of the things that genuinely baffled a lot of people in this competition was that a good CV score did not necessarily translate well to a good LB score. The main reason for this was small test dataset(only 65k rows) in the first stage(around 15% of total test data).
A common theme on discussion forums was focussing on which submissions we should select as the final submission:
 The one having the best local CV? or The one having the best LB?  And while it seems simple to say to trust your CV, common sense goes for a toss when you see that your LB score is going down or remaining constant whenever your Local CV score increases.
Luckily I didn&amp;rsquo;t end up making the mistake of not trusting my CV score. Owing to a lot of excellent posts on Kaggle discussion board, I selected a kernel with Public LB score of 0.697 and a Local CV of 0.701, which was around &amp;gt;1200 rank on Public LB as of the final submission. It achieved a score of 0.702 and ranked 182 on the private LB.
While this seems like a straightforward choice post-facto, it was a hard decision to make at a time when you have at your disposal some public kernels having Public LB score &amp;gt;= 0.70
2. Use the code from public kernels but check for errors This Pytorch kernel by Benjamin Minixhofer is awesome. It made the base of many of my submissions for this competition. But this kernel had a mistake. It didn&amp;rsquo;t implement spatial dropout in the right way. You can find the correct implementation of spatial dropout in my post here or on my kernel. Implementing spatial dropout in the right way gave a boost of around 0.004 to the local CV.
Nonetheless, I learned pytorch using this kernel, and I am grateful to him for the same.
3. Don&amp;rsquo;t trust everything that goes on the discussion forums   I will talk about two things here:
 Seed tuning: While in the middle of the competition, everyone was trying to get the best possible rank on the public LB. It is just human nature. A lot of discussions was around good seeds and bad seeds for neural network initialization. While it seems okay in the first look, the conversation went a stage further where people started tuning seeds in the kernel as a hyper param. Some discussions even went on to say that it was a valid strategy. And that is where a large amount of overfitting to public LB started happening. The same submission would score 0.704 from 0.699 just by changing the seed. For a reference, that meant you could go from anywhere near 400-500 rank to top 50 only by changing seed in a public kernel. And that spelled disaster. Some people did that. They went up the public LB. Went crashing out at the private stage.
 CV score disclosure on discussion forums: We always try to gauge our performance against other people. In a lot of discussions, people provided their CV scores and corresponding Public LB scores. The scores were all over the place and not comparable due to Different CV schemes, No of folds in CV, Metric reported, Overfitting or just plain Wrong implementation of Cross-Validation. But they ended up influencing a lot of starters and newcomers.
  4. On that note, be active on Discussion forums and check public kernels regularly You can learn a lot just by being part of discussion forums and following public kernels. This competition had a lot of excellent public kernels on embeddings by SRK, Models by Shujian, and Preprocessing by Theo Viel which gave everyone a headstart. As the competition progressed, the discussions also evolved. There were discussions on speeding up the code, working approaches, F1 threshold finders, and other exciting topics which kept me occupied with new ideas and improvements.
Even after the end, while reading up discussions on solutions overview, I learned a lot. And I would say it is very ** vital to check out the winning solutions.**
5. Share a lot Sharing is everything on Kaggle. People have shared their codes as well as their ideas while competing as well as after the competition ended. It is only together that we can go forward. I like blogging, so I am sharing the knowledge via a series of blog posts on text classification. The first post talked about the different preprocessing techniques that work with Deep learning models and increasing embeddings coverage. In the second post, I talked through some basic conventional models like TFIDF, Count Vectorizer, Hashing, etc. that have been used in text classification and tried to access their performance to create a baseline. In the third post, I will delve deeper into Deep learning models and the various architectures we could use to solve the text Classification problem. To make this post platform generic I will try to write code in both Keras and Pytorch. We will try to use various other models which we were not able to use in this competition like ULMFit transfer learning approaches in the fourth post in the series.
It might take me a little time to write the whole series. Till then you can take a look at my other posts too: What Kagglers are using for Text Classification, which talks about various deep learning models in use in NLP and how to switch from Keras to Pytorch.
6. Beware of trolls :) We were going along happily towards the end of the competition with two weeks left. Scores were increasing slowly. The top players were somewhat stagnant. And then came Pavel and team with a Public LB score of 0.782. The next group had an LB score of 0.713. Such a huge difference. I was so sure that there was some leakage in the data which nobody has caught yet except for Pavel. I spent nearly half a day to do EDA again.
In the end, it turned out that what they did was scraping — nicely played!
They also have some pretty awesome ideas around including additional data, which could have worked but did not in this competition.
My Final Solution:   My main focus was on meta-feature engineering and on increasing embedding coverage and quality. That means I did not play much with various Neural Net architectures. Here are the things that I included in my final submission:
 I noticed that Glove embeddings were doing good on the local CV but not on LB, while meta embeddings(mean of glove and paragram) were doing good on LB but not that good on the CV. I took a mixed approach so some of my models are trained with only glove embedding and some on meta embeddings. Included four more features in embedding. Thus my embedding was a 304-dimensional vector. The four new values corresponded to title case flag, uppercase flag, Textblob word polarity, textblob word subjectivity Found out NER tokens from the whole train and test data using spacy and kept the tokens and the entities in a dict. I used this dict to create extra features like counts of GPE, PERSON, ORG, NORP, WORK_OF_ART.Added some value and were highly correlated with the target. Other features that I used include total_length,capitals,words_vs_unique as well as some engineered features like sum_feat(sum of expletives), question_start_with_why, question_start_with_how_or_what, question_start_with_do_or_are. Might not have added much value but still kept them. My final solution consisted of a stacked ensemble for four models. I stacked the four models using Logistic regression(with positive weights and 0 intercept) and gave the weights as a list in the final kernel.  You can find the kernel for my final submission here.
Tips and Tricks used in other solutions: 1. Increasing Embeddings Coverage: In the third place solution kernel, wowfattie uses stemming, lemmatization, capitalize, lower, uppercase, as well as embedding of the nearest word using a spell checker to get embeddings for all words in his vocab. Such a great idea. I liked this solution the best as it can do what I was trying to do and finished at a pretty good place. Also, the code is very clean.
from nltk.stem import PorterStemmer ps = PorterStemmer() from nltk.stem.lancaster import LancasterStemmer lc = LancasterStemmer() from nltk.stem import SnowballStemmer sb = SnowballStemmer(&amp;#34;english&amp;#34;) def load_glove(word_dict, lemma_dict): EMBEDDING_FILE = &amp;#39;../input/embeddings/glove.840B.300d/glove.840B.300d.txt&amp;#39; def get_coefs(word,*arr): return word, np.asarray(arr, dtype=&amp;#39;float32&amp;#39;) embeddings_index = dict(get_coefs(*o.split(&amp;#34; &amp;#34;)) for o in open(EMBEDDING_FILE)) embed_size = 300 nb_words = len(word_dict)&#43;1 embedding_matrix = np.zeros((nb_words, embed_size), dtype=np.float32) unknown_vector = np.zeros((embed_size,), dtype=np.float32) - 1. print(unknown_vector[:5]) for key in tqdm(word_dict): word = key embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[word_dict[key]] = embedding_vector continue word = key.lower() embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[word_dict[key]] = embedding_vector continue word = key.upper() embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[word_dict[key]] = embedding_vector continue word = key.capitalize() embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[word_dict[key]] = embedding_vector continue word = ps.stem(key) embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[word_dict[key]] = embedding_vector continue word = lc.stem(key) embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[word_dict[key]] = embedding_vector continue word = sb.stem(key) embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[word_dict[key]] = embedding_vector continue word = lemma_dict[key] embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[word_dict[key]] = embedding_vector continue if len(key) &amp;gt; 1: word = correction(key) embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[word_dict[key]] = embedding_vector continue embedding_matrix[word_dict[key]] = unknown_vector return embedding_matrix, nb_words 2. Checkpoint Ensembling: Get a lot of models at no cost. Most of the winning solutions have some version of checkpoint ensembling. For the third place solution, the predictions are a weighted average of predictions after the 4th epoch and predictions after the 5th epoch. I got this idea but forgot to implement it in my ensemble based kernel submission.
3. Meta Embeddings: A lot of winning solutions ended up using weighted meta embeddings where they provided a higher weight to the Glove embedding. Some solutions also used concatenated embeddings.
4. Model Architecture: One surprising thing I saw people doing was to use a 1Dconv layer just after the Bidirectional layer. For example, This is the architecture used by the team that placed first in the competition.
  5. Bucketing/Variable Sequence Length and increased hidden units: Another thing I noticed is the increased number of hidden units as compared to many public kernels. Most of the public kernels used a hidden unit size of 60 due to time constraints. I used 80 units at the cost of training one less network. A lot of high scoring kernels were able to use a higher number of hidden units owing to variable sequence length idea or bucketing. From the 1st place kernel discussion:
 We do not pad sequences to the same length based on the whole data, but just on a batch level. That means we conduct padding and truncation on the data generator level for each batch separately, so that length of the sentences in a batch can vary in size. Additionally, we further improved this by not truncating based on the length of the longest sequence in the batch but based on the 95% percentile of lengths within the sequence. This improved runtime heavily and kept accuracy quite robust on single model level, and improved it by being able to average more models.
 Also from 7th place discussion:
 Bucketing is to make a minibatch from instances that have similar lengths to alleviate the cost of padding. This makes the training speed more than 3x faster, and thus I can run 9 epochs for each split of 5-fold.
 Thus the use of this technique also allowed some competitors to fit many more epochs in less time and run more models at the same time. Pretty Neat!
6. For those winners who didn&amp;rsquo;t use bucketing, Maxlen = 72 was too large: Most of us saw a distribution of question length and took the length that covered maximum questions fully as the maxlen parameter. I never tried to tune it, but it seems like it could have been tuned. One of the tricks was to use maxlen ranging from 35 to 60. This made the kernels run a lot faster.
7. Time taking models/complex architectures like Capsule were mostly not used: Most of the winning solutions didn&amp;rsquo;t use capsule networks as they took a lot of time to train.
8. Backprop errors on embeddings weights in last few epochs: Another thing I saw was in the 18th place kernel which uses a single model
if epoch &amp;gt;= 3: model.embedding.embeddings.weight.requires_grad = True Conclusion: It was a good and long 2-month competition, and I learned a lot about Text and NLP during this time. I want to emphasize here is that I ended up trying a lot of things that didn&amp;rsquo;t work before reaching my final solution. It was a little frustrating at times, but in the end, I was happy that I ended up with the best data science practices. Would also like to thank Kaggle master Kazanova who along with some of his friends released a “How to win a data science competition” Coursera course. I learned a lot from this course.
Let me know in the comments if you think something is missing/wrong or if I could add more tips/tricks for this competition.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>NLP  Learning Series: Part 2 - Conventional Methods for Text Classification</title>
      <link>https://mlwhiz.com/blog/2019/02/08/deeplearning_nlp_conventional_methods/</link>
      <pubDate>Fri, 08 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2019/02/08/deeplearning_nlp_conventional_methods/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/tfidf.png"></media:content>
      

      
      <description>This is the second post of the NLP Text classification series. To give you a recap, recently I started up with an NLP text classification competition on Kaggle called Quora Question insincerity challenge. And I thought to share the knowledge via a series of blog posts on text classification. The first post talked about the various preprocessing techniques that work with Deep learning models and increasing embeddings coverage. In this post, I will try to take you through some basic conventional models like TFIDF, Count Vectorizer, Hashing etc.</description>

      <content:encoded>  
        
        <![CDATA[  This is the second post of the NLP Text classification series. To give you a recap, recently I started up with an NLP text classification competition on Kaggle called Quora Question insincerity challenge. And I thought to share the knowledge via a series of blog posts on text classification. The first post talked about the various preprocessing techniques that work with Deep learning models and increasing embeddings coverage. In this post, I will try to take you through some basic conventional models like TFIDF, Count Vectorizer, Hashing etc. that have been used in text classification and try to access their performance to create a baseline. We will delve deeper into Deep learning models in the third post which will focus on different architectures for solving the text classification problem. We will try to use various other models which we were not able to use in this competition like ULMFit transfer learning approaches in the fourth post in the series.
As a side note: if you want to know more about NLP, I would like to recommend this awesome course on Natural Language Processing in the Advanced machine learning specialization. You can start for free with the 7-day Free Trial. This course covers a wide range of tasks in Natural Language Processing from basic to advanced: sentiment analysis, summarization, dialogue state tracking, to name a few. You can start for free with the 7-day Free Trial.
It might take me a little time to write the whole series. Till then you can take a look at my other posts too: What Kagglers are using for Text Classification, which talks about various deep learning models in use in NLP and how to switch from Keras to Pytorch.
So again we start with the first step: Preprocessing.
Basic Preprocessing Techniques for text data(Continued) So in the last post, we talked about various preprocessing methods for text for deep learning purpose. Most of the preprocessing for conventional methods remains the same. We will still remove special characters, punctuations, and contractions. But We also may want to do stemming/lemmatization when it comes to conventional methods. Let us talk about them.
 For grammatical reasons, documents are going to use different forms of a word, such as organize, organizes, and organizing. Additionally, there are families of derivationally related words with similar meanings, such as democracy, democratic, and democratization.
 Since we are going to create features for words in the feature creation step, it makes sense to reduce words to a common denominator so that &amp;lsquo;organize&amp;rsquo;,&amp;lsquo;organizes&amp;rsquo; and &amp;lsquo;organizing&amp;rsquo; could be referred to by a single word &amp;lsquo;organize&amp;rsquo;
a) Stemming Stemming is the process of converting words to their base forms using crude Heuristic rules. For example, one rule could be to remove &amp;rsquo;s&amp;rsquo; from the end of any word, so that &amp;lsquo;cats&amp;rsquo; becomes &amp;lsquo;cat&amp;rsquo;. or another rule could be to replace &amp;lsquo;ies&amp;rsquo; with &amp;lsquo;i&amp;rsquo; so that &amp;lsquo;ponies becomes &amp;lsquo;poni&amp;rsquo;. One of the main point to note here is that when we stem the word we might get a nonsense word like &amp;lsquo;poni&amp;rsquo;. But it will still work for our use case as we count the number of occurrences of a particular word and not focus on the meanings of these words in conventional methods. It doesn&amp;rsquo;t work with deep learning for precisely the same reason.
  We can do this pretty simply by using this function in python.
from nltk.stem import SnowballStemmer from nltk.tokenize.toktok import ToktokTokenizer def stem_text(text): tokenizer = ToktokTokenizer() stemmer = SnowballStemmer(&amp;#39;english&amp;#39;) tokens = tokenizer.tokenize(text) tokens = [token.strip() for token in tokens] tokens = [stemmer.stem(token) for token in tokens] return &amp;#39; &amp;#39;.join(tokens) b) Lemmatization Lemmatization is very similar to stemming but it aims to remove endings only if the base form is present in a dictionary.
from nltk.stem import WordNetLemmatizer from nltk.tokenize.toktok import ToktokTokenizer def lemma_text(text): tokenizer = ToktokTokenizer() tokens = tokenizer.tokenize(text) tokens = [token.strip() for token in tokens] tokens = [wordnet_lemmatizer.lemmatize(token) for token in tokens] return &amp;#39; &amp;#39;.join(tokens) Once we are done with processing a text, our text will necessarily go through these following steps.
def clean_sentence(x): x = x.lower() x = clean_text(x) x = clean_numbers(x) x = replace_typical_misspell(x) x = remove_stopwords(x) x = replace_contractions(x) x = lemma_text(x) x = x.replace(&amp;#34;&amp;#39;&amp;#34;,&amp;#34;&amp;#34;) return x Text Representation In Conventional Machine learning methods, we ought to create features for a text. There are a lot of representations that are present to achieve this. Let us talk about them one by one.
a) Bag of Words - Countvectorizer Features Suppose we have a series of sentences(documents)
X = [ &amp;#39;This is good&amp;#39;, &amp;#39;This is bad&amp;#39;, &amp;#39;This is awesome&amp;#39; ]    Bag of words will create a dictionary of the most common words in all the sentences. For the example above the dictionary would look like:
word_index {&amp;#39;this&amp;#39;:0,&amp;#39;is&amp;#39;:1,&amp;#39;good&amp;#39;:2,&amp;#39;bad&amp;#39;:3,&amp;#39;awesome&amp;#39;:4} And then encode the sentences using the above dict.
This is good - [1,1,1,0,0] This is bad - [1,1,0,1,0] This is awesome - [1,1,0,0,1] We could do this pretty simply in Python by using the CountVectorizer class from Python. Don&amp;rsquo;t worry much about the heavy name, it just does what I explained above. It has a lot of parameters most significant of which are:
 ngram_range: I specify in the code (1,3). This means that unigrams, bigrams, and trigrams will be taken into account while creating features. min_df: Minimum no of time an ngram should appear in a corpus to be used as a feature.  cnt_vectorizer = CountVectorizer(dtype=np.float32, strip_accents=&amp;#39;unicode&amp;#39;, analyzer=&amp;#39;word&amp;#39;,token_pattern=r&amp;#39;\w{1,}&amp;#39;, ngram_range=(1, 3),min_df=3) # we fit count vectorizer to get ngrams from both train and test data. cnt_vectorizer.fit(list(train_df.cleaned_text.values) &#43; list(test_df.cleaned_text.values)) xtrain_cntv = cnt_vectorizer.transform(train_df.cleaned_text.values) xtest_cntv = cnt_vectorizer.transform(test_df.cleaned_text.values) We could then use these features with any machine learning classification model like Logistic Regression, Naive Bayes, SVM or LightGBM as we would like. For example:
# Fitting a simple Logistic Regression on CV Feats clf = LogisticRegression(C=1.0) clf.fit(xtrain_cntv,y_train) Here is a link to a kernel where I tried these features on the Quora Dataset. If you like it please don&amp;rsquo;t forget to upvote.
b) TFIDF Features TFIDF is a simple technique to find features from sentences. While in Count features we take count of all the words/ngrams present in a document, with TFIDF we take features only for the significant words. How do we do that? If you think of a document in a corpus, we will consider two things about any word in that document:
   Term Frequency: How important is the word in the document?  $$TF(word\ in\ a\ document) = \dfrac{No\ of\ occurances\ of\ that\ word\ in\ document}{No\ of\ words\ in\ document}$$
 Inverse Document Frequency: How important the term is in the whole corpus?  $$IDF(word\ in\ a\ corpus) = -log(ratio\ of\ documents\ that\ include\ the\ word)$$
TFIDF then is just multiplication of these two scores.
Intuitively, One can understand that a word is important if it occurs many times in a document. But that creates a problem. Words like &amp;ldquo;a&amp;rdquo;, &amp;ldquo;the&amp;rdquo; occur many times in sentence. Their TF score will always be high. We solve that by using Inverse Document frequency, which is high if the word is rare, and low if the word is common across the corpus.
In essence, we want to find important words in a document which are also not very common.
We could do this pretty simply in Python by using the TFIDFVectorizer class from Python. It has a lot of parameters most significant of which are:
 ngram_range: I specify in the code (1,3). This means that unigrams, bigrams, and trigrams will be taken into account while creating features. min_df: Minimum no of time an ngram should appear in a corpus to be used as a feature.  # Always start with these features. They work (almost) everytime! tfv = TfidfVectorizer(dtype=np.float32, min_df=3, max_features=None, strip_accents=&amp;#39;unicode&amp;#39;, analyzer=&amp;#39;word&amp;#39;,token_pattern=r&amp;#39;\w{1,}&amp;#39;, ngram_range=(1, 3), use_idf=1,smooth_idf=1,sublinear_tf=1, stop_words = &amp;#39;english&amp;#39;) # Fitting TF-IDF to both training and test sets (semi-supervised learning) tfv.fit(list(train_df.cleaned_text.values) &#43; list(test_df.cleaned_text.values)) xtrain_tfv = tfv.transform(train_df.cleaned_text.values) xvalid_tfv = tfv.transform(test_df.cleaned_text.values) Again, we could use these features with any machine learning classification model like Logistic Regression, Naive Bayes, SVM or LightGBM as we would like. Here is a link to a kernel where I tried these features on the Quora Dataset. If you like it please don&amp;rsquo;t forget to upvote.
c) Hashing Features Normally there will be a lot of ngrams in a document corpus. The number of features that our TFIDFVectorizer generated was in excess of 2,00,000 features. This might lead to a problem on very large datasets as we have to hold a very large vocabulary dictionary in memory. One way to counter this is to use the Hash Trick.
  One can think of hashing as a single function which maps any ngram to a number range for example between 0 to 1024. Now we don&amp;rsquo;t have to store our ngrams in a dictionary. We can just use the function to get the index of any word, rather than getting the index from a dictionary.
Since there can be more than 1024 ngrams, different ngrams might map to the same number, and this is called collision. The larger the range we provide our Hashing function, the less is the chance of collisions.
We could do this pretty simply in Python by using the HashingVectorizer class from Python. It has a lot of parameters most significant of which are:
 ngram_range: I specify in the code (1,3). This means that unigrams, bigrams, and trigrams will be taken into account while creating features. n_features: No of features you want to consider. The range I gave above.  # Always start with these features. They work (almost) everytime! hv = HashingVectorizer(dtype=np.float32, strip_accents=&amp;#39;unicode&amp;#39;, analyzer=&amp;#39;word&amp;#39;, ngram_range=(1, 4),n_features=2**12,non_negative=True) # Fitting Hash Vectorizer to both training and test sets (semi-supervised learning) hv.fit(list(train_df.cleaned_text.values) &#43; list(test_df.cleaned_text.values)) xtrain_hv = hv.transform(train_df.cleaned_text.values) xvalid_hv = hv.transform(test_df.cleaned_text.values) y_train = train_df.target.values Here is a link to a kernel where I tried these features on the Quora Dataset. If you like it please don&amp;rsquo;t forget to upvote.
d) Word2vec Features We already talked a little about word2vec in the previous post. We can use the word to vec features to create sentence level feats also. We want to create a d dimensional vector for sentence. For doing this, we will simply average the word embedding of all the words in a sentence.
  We can do this in Python using the following functions.
# load the GloVe vectors in a dictionary: def load_glove_index(): EMBEDDING_FILE = &amp;#39;../input/embeddings/glove.840B.300d/glove.840B.300d.txt&amp;#39; def get_coefs(word,*arr): return word, np.asarray(arr, dtype=&amp;#39;float32&amp;#39;)[:300] embeddings_index = dict(get_coefs(*o.split(&amp;#34; &amp;#34;)) for o in open(EMBEDDING_FILE)) return embeddings_index embeddings_index = load_glove_index() print(&amp;#39;Found %sword vectors.&amp;#39; % len(embeddings_index)) from nltk.corpus import stopwords stop_words = stopwords.words(&amp;#39;english&amp;#39;) def sent2vec(s): words = str(s).lower() words = word_tokenize(words) words = [w for w in words if not w in stop_words] words = [w for w in words if w.isalpha()] M = [] for w in words: try: M.append(embeddings_index[w]) except: continue M = np.array(M) v = M.sum(axis=0) if type(v) != np.ndarray: return np.zeros(300) return v / np.sqrt((v ** 2).sum()) # create glove features xtrain_glove = np.array([sent2vec(x) for x in tqdm(train_df.cleaned_text.values)]) xtest_glove = np.array([sent2vec(x) for x in tqdm(test_df.cleaned_text.values)]) Here is a link to a kernel where I tried these features on the Quora Dataset. If you like it please don&amp;rsquo;t forget to upvote.
Results Here are the results of different approaches on the Kaggle Dataset. I ran a 5 fold Stratified CV.
  Here is the code. If you like it please don&amp;rsquo;t forget to upvote. Also note that I didn&amp;rsquo;t work on tuning the models, so these results are only cursory. You can try to squeeze more performance by performing hyperparams tuning using hyperopt or just old fashioned Grid-search and the performance of models may change after that substantially.
Conclusion While Deep Learning works a lot better for NLP classification task, it still makes sense to have an understanding of how these problems were solved in the past, so that we can appreciate the nature of the problem. I have tried to provide a perspective on the conventional methods and one should experiment with them too to create baselines before moving to Deep Learning methods. If you want to learn more about NLP here is an awesome course. You can start for free with the 7-day Free Trial. If you think I can add something to the flow, do mention it in the comments.
Endnotes and References This post is a result of an effort of a lot of excellent Kagglers and I will try to reference them in this section. If I leave out someone, do understand that it was not my intention to do so.
 Approaching (Almost) Any NLP Problem on Kaggle How to: Preprocessing when using embeddings  ]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>NLP  Learning Series: Part 1 - Text Preprocessing Methods for Deep Learning</title>
      <link>https://mlwhiz.com/blog/2019/01/17/deeplearning_nlp_preprocess/</link>
      <pubDate>Thu, 17 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2019/01/17/deeplearning_nlp_preprocess/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/text_processing_flow_1.png"></media:content>
      

      
      <description>Recently, I started up with an NLP competition on Kaggle called Quora Question insincerity challenge. It is an NLP Challenge on text classification and as the problem has become more clear after working through the competition as well as by going through the invaluable kernels put up by the kaggle experts, I thought of sharing the knowledge.
Since we have a large amount of material to cover, I am splitting this post into a series of posts.</description>

      <content:encoded>  
        
        <![CDATA[  Recently, I started up with an NLP competition on Kaggle called Quora Question insincerity challenge. It is an NLP Challenge on text classification and as the problem has become more clear after working through the competition as well as by going through the invaluable kernels put up by the kaggle experts, I thought of sharing the knowledge.
Since we have a large amount of material to cover, I am splitting this post into a series of posts. The first post i.e. this one will be based on preprocessing techniques that work with Deep learning models and we will also talk about increasing embeddings coverage. In the second post, I will try to take you through some basic conventional models like TFIDF, Count Vectorizer, Hashing etc. that have been used in text classification and try to access their performance to create a baseline. We will delve deeper into Deep learning models in the third post which will focus on different architectures for solving the text classification problem. We will try to use various other models which we were not able to use in this competition like ULMFit transfer learning approaches in the fourth post in the series.
As a side note: if you want to know more about NLP, I would like to recommend this awesome course on Natural Language Processing in the Advanced machine learning specialization. You can start for free with the 7-day Free Trial. This course covers a wide range of tasks in Natural Language Processing from basic to advanced: sentiment analysis, summarization, dialogue state tracking, to name a few. You can start for free with the 7-day Free Trial.
It might take me a little time to write the whole series. Till then you can take a look at my other posts: What Kagglers are using for Text Classification, which talks about various deep learning models in use in NLP and how to switch from Keras to Pytorch.
So first let me start with explaining a little more about the text classification problem. Text classification is a common task in natural language processing, which transforms a sequence of a text of indefinite length into a category of text. How could you use that?
 To find the sentiment of a review. Find toxic comments on a platform like Facebook Find Insincere questions on Quora. A current ongoing competition on kaggle Find fake reviews on websites Will a text advert get clicked or not?  Now each of these problems has something in common. From a Machine Learning perspective, these are essentially the same problem with just the target labels changing and nothing else. With that said, the addition of business knowledge can help make these models more robust and that is what we want to incorporate while preprocessing the data for test classification. While the preprocessing pipeline I am focussing on in this post is mainly centered around Deep Learning but most of it will also be applicable to conventional machine learning models too.
But let me first go through the flow of a deep learning pipeline for text data before going through all the steps to get a higher level perspective about the whole process.
  We normally start with cleaning up the text data and performing basic EDA. Here we try to improve our data quality by cleaning up the data. We also try to improve the quality of our word2vec embeddings by removing OOV(Out-of-Vocabulary) words. These first two steps normally don&amp;rsquo;t have much order between them and I generally go back and forth between these two steps. Next, we create a representation for text that could be fed into a deep learning model. We then start with creating our models and training them. Finally, we evaluate the models using appropriate metrics and get approval from respective shareholders to deploy our models. Don&amp;rsquo;t worry if these terms don&amp;rsquo;t make much sense now. I will try to explain them through the course of this article.
Here at this junction, let us take a little detour to talk a little about word embeddings. We will have to think about them while preprocessing data for our Deep Learning models.
A Primer on word2vec embeddings: We need to have a way to represent words in a vocab. One way to do that could be to use One hot encoding of word vectors but that is not really a good choice. One of the major reasons is that the one-hot word vectors cannot accurately express the similarity between different words, such as the cosine similarity.
$$\frac{\boldsymbol{x}^\top \boldsymbol{y}}{|\boldsymbol{x}| |\boldsymbol{y}|} \in [-1, 1].$$
Given the structure of one hot encoded vectors, the similarity is always going to come as 0 between different words. Another reason is that as the size of vocabulary increases these one hot encoded vectors become very large.
Word2Vec overcomes the above difficulties by providing us with a fixed length vector representation of words and by capturing the similarity and analogy relationships between different words.
  Word2vec vectors of words are learned in such a way that they allow us to learn different analogies. It enables us to do algebraic manipulations on words which were not possible before. For example: What is king - man &#43; woman? It comes out to be Queen.
Word2Vec vectors also help us to find out the similarity between words. If we try to find similar words to &amp;ldquo;good&amp;rdquo;, we will find awesome, great etc. It is this property of word2vec that makes it invaluable for text classification. Now our deep learning network understands that &amp;ldquo;good&amp;rdquo; and &amp;ldquo;great&amp;rdquo; are essentially words with similar meaning.
Thus in very simple terms, word2vec creates vectors for words. Thus we have a d dimensional vector for every word(common bigrams too) in a dictionary. We normally use pretrained word vectors which are provided to us by others after training on large corpora of texts like Wikipedia, twitter etc. The most commonly used pretrained word vectors are Glove and Fasttext with 300-dimensional word vectors. We are going to use Glove in this post.
Basic Preprocessing Techniques for text data: In most of the cases, we observe that text data is not entirely clean. Data coming from different sources have different characteristics and that makes Text Preprocessing as one of the most important steps in the classification pipeline. For example, Text data from Twitter is totally different from text data on Quora, or some news/blogging platform, and thus would need to be treated differently. Helpfully, the techniques I am going to talk about in this post are generic enough for any kind of data you might encounter in the jungles of NLP.
a) Cleaning Special Characters and Removing Punctuations: Our preprocessing pipeline depends a lot on the word2vec embeddings we are going to use for our classification task. In principle our preprocessing should match the preprocessing that was used before training the word embedding. Since most of the embeddings don&amp;rsquo;t provide vector values for punctuations and other special chars, the first thing you want to do is to get rid of is the special characters in your text data. These are some of the special chars that were there in the Quora Question data and we use replace function to get rid of these special chars.
# Some preprocesssing that will be common to all the text classification methods you will see. puncts = [&amp;#39;,&amp;#39;, &amp;#39;.&amp;#39;, &amp;#39;&amp;#34;&amp;#39;, &amp;#39;:&amp;#39;, &amp;#39;)&amp;#39;, &amp;#39;(&amp;#39;, &amp;#39;-&amp;#39;, &amp;#39;!&amp;#39;, &amp;#39;?&amp;#39;, &amp;#39;|&amp;#39;, &amp;#39;;&amp;#39;, &amp;#34;&amp;#39;&amp;#34;, &amp;#39;$&amp;#39;, &amp;#39;&amp;amp;&amp;#39;, &amp;#39;/&amp;#39;, &amp;#39;[&amp;#39;, &amp;#39;]&amp;#39;, &amp;#39;&amp;gt;&amp;#39;, &amp;#39;%&amp;#39;, &amp;#39;=&amp;#39;, &amp;#39;#&amp;#39;, &amp;#39;*&amp;#39;, &amp;#39;&#43;&amp;#39;, &amp;#39;\\&amp;#39;, &amp;#39;•&amp;#39;, &amp;#39;~&amp;#39;, &amp;#39;@&amp;#39;, &amp;#39;£&amp;#39;, &amp;#39;·&amp;#39;, &amp;#39;_&amp;#39;, &amp;#39;{&amp;#39;, &amp;#39;}&amp;#39;, &amp;#39;©&amp;#39;, &amp;#39;^&amp;#39;, &amp;#39;®&amp;#39;, &amp;#39;`&amp;#39;, &amp;#39;&amp;lt;&amp;#39;, &amp;#39;→&amp;#39;, &amp;#39;°&amp;#39;, &amp;#39;€&amp;#39;, &amp;#39;™&amp;#39;, &amp;#39;›&amp;#39;, &amp;#39;♥&amp;#39;, &amp;#39;←&amp;#39;, &amp;#39;×&amp;#39;, &amp;#39;§&amp;#39;, &amp;#39;″&amp;#39;, &amp;#39;′&amp;#39;, &amp;#39;Â&amp;#39;, &amp;#39;█&amp;#39;, &amp;#39;½&amp;#39;, &amp;#39;à&amp;#39;, &amp;#39;…&amp;#39;, &amp;#39;“&amp;#39;, &amp;#39;★&amp;#39;, &amp;#39;”&amp;#39;, &amp;#39;–&amp;#39;, &amp;#39;●&amp;#39;, &amp;#39;â&amp;#39;, &amp;#39;►&amp;#39;, &amp;#39;−&amp;#39;, &amp;#39;¢&amp;#39;, &amp;#39;²&amp;#39;, &amp;#39;¬&amp;#39;, &amp;#39;░&amp;#39;, &amp;#39;¶&amp;#39;, &amp;#39;↑&amp;#39;, &amp;#39;±&amp;#39;, &amp;#39;¿&amp;#39;, &amp;#39;▾&amp;#39;, &amp;#39;═&amp;#39;, &amp;#39;¦&amp;#39;, &amp;#39;║&amp;#39;, &amp;#39;―&amp;#39;, &amp;#39;¥&amp;#39;, &amp;#39;▓&amp;#39;, &amp;#39;—&amp;#39;, &amp;#39;‹&amp;#39;, &amp;#39;─&amp;#39;, &amp;#39;▒&amp;#39;, &amp;#39;：&amp;#39;, &amp;#39;¼&amp;#39;, &amp;#39;⊕&amp;#39;, &amp;#39;▼&amp;#39;, &amp;#39;▪&amp;#39;, &amp;#39;†&amp;#39;, &amp;#39;■&amp;#39;, &amp;#39;’&amp;#39;, &amp;#39;▀&amp;#39;, &amp;#39;¨&amp;#39;, &amp;#39;▄&amp;#39;, &amp;#39;♫&amp;#39;, &amp;#39;☆&amp;#39;, &amp;#39;é&amp;#39;, &amp;#39;¯&amp;#39;, &amp;#39;♦&amp;#39;, &amp;#39;¤&amp;#39;, &amp;#39;▲&amp;#39;, &amp;#39;è&amp;#39;, &amp;#39;¸&amp;#39;, &amp;#39;¾&amp;#39;, &amp;#39;Ã&amp;#39;, &amp;#39;⋅&amp;#39;, &amp;#39;‘&amp;#39;, &amp;#39;∞&amp;#39;, &amp;#39;∙&amp;#39;, &amp;#39;）&amp;#39;, &amp;#39;↓&amp;#39;, &amp;#39;、&amp;#39;, &amp;#39;│&amp;#39;, &amp;#39;（&amp;#39;, &amp;#39;»&amp;#39;, &amp;#39;，&amp;#39;, &amp;#39;♪&amp;#39;, &amp;#39;╩&amp;#39;, &amp;#39;╚&amp;#39;, &amp;#39;³&amp;#39;, &amp;#39;・&amp;#39;, &amp;#39;╦&amp;#39;, &amp;#39;╣&amp;#39;, &amp;#39;╔&amp;#39;, &amp;#39;╗&amp;#39;, &amp;#39;▬&amp;#39;, &amp;#39;❤&amp;#39;, &amp;#39;ï&amp;#39;, &amp;#39;Ø&amp;#39;, &amp;#39;¹&amp;#39;, &amp;#39;≤&amp;#39;, &amp;#39;‡&amp;#39;, &amp;#39;√&amp;#39;, ] def clean_text(x): x = str(x) for punct in puncts: if punct in x: x = x.replace(punct, f&amp;#39; {punct} &amp;#39;) return x This could also have been done with the help of a simple regex. But I normally like the above way of doing things as it helps to understand the sort of characters we are removing from our data.
def clean_text(x): pattern = r&amp;#39;[^a-zA-z0-9\s]&amp;#39; text = re.sub(pattern, &amp;#39;&amp;#39;, x) return x b) Cleaning Numbers: Why do we want to replace numbers with #s? Because most embeddings have preprocessed their text like this.
Small Python Trick: We use an if statement in the code below to check beforehand if a number exists in a text. It is as an if is always fast than a re.sub command and most of our text doesn&amp;rsquo;t contain numbers.
def clean_numbers(x): if bool(re.search(r&amp;#39;\d&amp;#39;, x)): x = re.sub(&amp;#39;[0-9]{5,}&amp;#39;, &amp;#39;#####&amp;#39;, x) x = re.sub(&amp;#39;[0-9]{4}&amp;#39;, &amp;#39;####&amp;#39;, x) x = re.sub(&amp;#39;[0-9]{3}&amp;#39;, &amp;#39;###&amp;#39;, x) x = re.sub(&amp;#39;[0-9]{2}&amp;#39;, &amp;#39;##&amp;#39;, x) return x c) Removing Misspells: It always helps to find out misspells in the data. As those word embeddings are not present in the word2vec, we should replace words with their correct spellings to get better embedding coverage. The following code artifact is an adaptation of Peter Norvig&amp;rsquo;s spell checker. It uses word2vec ordering of words to approximate word probabilities. As Google word2vec apparently orders words in decreasing order of frequency in the training corpus. You can use this to find out some misspelled words in the data you have.
# This comes from CPMP script in the Quora questions similarity challenge. import re from collections import Counter import gensim import heapq from operator import itemgetter from multiprocessing import Pool model = gensim.models.KeyedVectors.load_word2vec_format(&amp;#39;../input/embeddings/GoogleNews-vectors-negative300/GoogleNews-vectors-negative300.bin&amp;#39;, binary=True) words = model.index2word w_rank = {} for i,word in enumerate(words): w_rank[word] = i WORDS = w_rank def words(text): return re.findall(r&amp;#39;\w&#43;&amp;#39;, text.lower()) def P(word): &amp;#34;Probability of `word`.&amp;#34; # use inverse of rank as proxy # returns 0 if the word isn&amp;#39;t in the dictionary return - WORDS.get(word, 0) def correction(word): &amp;#34;Most probable spelling correction for word.&amp;#34; return max(candidates(word), key=P) def candidates(word): &amp;#34;Generate possible spelling corrections for word.&amp;#34; return (known([word]) or known(edits1(word)) or known(edits2(word)) or [word]) def known(words): &amp;#34;The subset of `words` that appear in the dictionary of WORDS.&amp;#34; return set(w for w in words if w in WORDS) def edits1(word): &amp;#34;All edits that are one edit away from `word`.&amp;#34; letters = &amp;#39;abcdefghijklmnopqrstuvwxyz&amp;#39; splits = [(word[:i], word[i:]) for i in range(len(word) &#43; 1)] deletes = [L &#43; R[1:] for L, R in splits if R] transposes = [L &#43; R[1] &#43; R[0] &#43; R[2:] for L, R in splits if len(R)&amp;gt;1] replaces = [L &#43; c &#43; R[1:] for L, R in splits if R for c in letters] inserts = [L &#43; c &#43; R for L, R in splits for c in letters] return set(deletes &#43; transposes &#43; replaces &#43; inserts) def edits2(word): &amp;#34;All edits that are two edits away from `word`.&amp;#34; return (e2 for e1 in edits1(word) for e2 in edits1(e1)) def build_vocab(texts): sentences = texts.apply(lambda x: x.split()).values vocab = {} for sentence in sentences: for word in sentence: try: vocab[word] &#43;= 1 except KeyError: vocab[word] = 1 return vocab vocab = build_vocab(train.question_text) top_90k_words = dict(heapq.nlargest(90000, vocab.items(), key=itemgetter(1))) pool = Pool(4) corrected_words = pool.map(correction,list(top_90k_words.keys())) for word,corrected_word in zip(top_90k_words,corrected_words): if word!=corrected_word: print(word,&amp;#34;:&amp;#34;,corrected_word) Once we are through with finding misspelled data, the next thing remains to replace them using a misspell mapping and regex functions.
mispell_dict = {&amp;#39;colour&amp;#39;: &amp;#39;color&amp;#39;, &amp;#39;centre&amp;#39;: &amp;#39;center&amp;#39;, &amp;#39;favourite&amp;#39;: &amp;#39;favorite&amp;#39;, &amp;#39;travelling&amp;#39;: &amp;#39;traveling&amp;#39;, &amp;#39;counselling&amp;#39;: &amp;#39;counseling&amp;#39;, &amp;#39;theatre&amp;#39;: &amp;#39;theater&amp;#39;, &amp;#39;cancelled&amp;#39;: &amp;#39;canceled&amp;#39;, &amp;#39;labour&amp;#39;: &amp;#39;labor&amp;#39;, &amp;#39;organisation&amp;#39;: &amp;#39;organization&amp;#39;, &amp;#39;wwii&amp;#39;: &amp;#39;world war 2&amp;#39;, &amp;#39;citicise&amp;#39;: &amp;#39;criticize&amp;#39;, &amp;#39;youtu &amp;#39;: &amp;#39;youtube &amp;#39;, &amp;#39;Qoura&amp;#39;: &amp;#39;Quora&amp;#39;, &amp;#39;sallary&amp;#39;: &amp;#39;salary&amp;#39;, &amp;#39;Whta&amp;#39;: &amp;#39;What&amp;#39;, &amp;#39;narcisist&amp;#39;: &amp;#39;narcissist&amp;#39;, &amp;#39;howdo&amp;#39;: &amp;#39;how do&amp;#39;, &amp;#39;whatare&amp;#39;: &amp;#39;what are&amp;#39;, &amp;#39;howcan&amp;#39;: &amp;#39;how can&amp;#39;, &amp;#39;howmuch&amp;#39;: &amp;#39;how much&amp;#39;, &amp;#39;howmany&amp;#39;: &amp;#39;how many&amp;#39;, &amp;#39;whydo&amp;#39;: &amp;#39;why do&amp;#39;, &amp;#39;doI&amp;#39;: &amp;#39;do I&amp;#39;, &amp;#39;theBest&amp;#39;: &amp;#39;the best&amp;#39;, &amp;#39;howdoes&amp;#39;: &amp;#39;how does&amp;#39;, &amp;#39;mastrubation&amp;#39;: &amp;#39;masturbation&amp;#39;, &amp;#39;mastrubate&amp;#39;: &amp;#39;masturbate&amp;#39;, &amp;#34;mastrubating&amp;#34;: &amp;#39;masturbating&amp;#39;, &amp;#39;pennis&amp;#39;: &amp;#39;penis&amp;#39;, &amp;#39;Etherium&amp;#39;: &amp;#39;Ethereum&amp;#39;, &amp;#39;narcissit&amp;#39;: &amp;#39;narcissist&amp;#39;, &amp;#39;bigdata&amp;#39;: &amp;#39;big data&amp;#39;, &amp;#39;2k17&amp;#39;: &amp;#39;2017&amp;#39;, &amp;#39;2k18&amp;#39;: &amp;#39;2018&amp;#39;, &amp;#39;qouta&amp;#39;: &amp;#39;quota&amp;#39;, &amp;#39;exboyfriend&amp;#39;: &amp;#39;ex boyfriend&amp;#39;, &amp;#39;airhostess&amp;#39;: &amp;#39;air hostess&amp;#39;, &amp;#34;whst&amp;#34;: &amp;#39;what&amp;#39;, &amp;#39;watsapp&amp;#39;: &amp;#39;whatsapp&amp;#39;, &amp;#39;demonitisation&amp;#39;: &amp;#39;demonetization&amp;#39;, &amp;#39;demonitization&amp;#39;: &amp;#39;demonetization&amp;#39;, &amp;#39;demonetisation&amp;#39;: &amp;#39;demonetization&amp;#39;} def _get_mispell(mispell_dict): mispell_re = re.compile(&amp;#39;(%s)&amp;#39; % &amp;#39;|&amp;#39;.join(mispell_dict.keys())) return mispell_dict, mispell_re mispellings, mispellings_re = _get_mispell(mispell_dict) def replace_typical_misspell(text): def replace(match): return mispellings[match.group(0)] return mispellings_re.sub(replace, text) # Usage replace_typical_misspell(&amp;#34;Whta is demonitisation&amp;#34;) d) Removing Contractions: Contractions are words that we write with an apostrophe. Examples of contractions are words like &amp;ldquo;ain&amp;rsquo;t&amp;rdquo; or &amp;ldquo;aren&amp;rsquo;t&amp;rdquo;. Since we want to standardize our text, it makes sense to expand these contractions. Below we have done this using a contraction mapping and regex functions.
contraction_dict = {&amp;#34;ain&amp;#39;t&amp;#34;: &amp;#34;is not&amp;#34;, &amp;#34;aren&amp;#39;t&amp;#34;: &amp;#34;are not&amp;#34;,&amp;#34;can&amp;#39;t&amp;#34;: &amp;#34;cannot&amp;#34;, &amp;#34;&amp;#39;cause&amp;#34;: &amp;#34;because&amp;#34;, &amp;#34;could&amp;#39;ve&amp;#34;: &amp;#34;could have&amp;#34;, &amp;#34;couldn&amp;#39;t&amp;#34;: &amp;#34;could not&amp;#34;, &amp;#34;didn&amp;#39;t&amp;#34;: &amp;#34;did not&amp;#34;, &amp;#34;doesn&amp;#39;t&amp;#34;: &amp;#34;does not&amp;#34;, &amp;#34;don&amp;#39;t&amp;#34;: &amp;#34;do not&amp;#34;, &amp;#34;hadn&amp;#39;t&amp;#34;: &amp;#34;had not&amp;#34;, &amp;#34;hasn&amp;#39;t&amp;#34;: &amp;#34;has not&amp;#34;, &amp;#34;haven&amp;#39;t&amp;#34;: &amp;#34;have not&amp;#34;, &amp;#34;he&amp;#39;d&amp;#34;: &amp;#34;he would&amp;#34;,&amp;#34;he&amp;#39;ll&amp;#34;: &amp;#34;he will&amp;#34;, &amp;#34;he&amp;#39;s&amp;#34;: &amp;#34;he is&amp;#34;, &amp;#34;how&amp;#39;d&amp;#34;: &amp;#34;how did&amp;#34;, &amp;#34;how&amp;#39;d&amp;#39;y&amp;#34;: &amp;#34;how do you&amp;#34;, &amp;#34;how&amp;#39;ll&amp;#34;: &amp;#34;how will&amp;#34;, &amp;#34;how&amp;#39;s&amp;#34;: &amp;#34;how is&amp;#34;, &amp;#34;I&amp;#39;d&amp;#34;: &amp;#34;I would&amp;#34;, &amp;#34;I&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;I would have&amp;#34;, &amp;#34;I&amp;#39;ll&amp;#34;: &amp;#34;I will&amp;#34;, &amp;#34;I&amp;#39;ll&amp;#39;ve&amp;#34;: &amp;#34;I will have&amp;#34;,&amp;#34;I&amp;#39;m&amp;#34;: &amp;#34;I am&amp;#34;, &amp;#34;I&amp;#39;ve&amp;#34;: &amp;#34;I have&amp;#34;, &amp;#34;i&amp;#39;d&amp;#34;: &amp;#34;i would&amp;#34;, &amp;#34;i&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;i would have&amp;#34;, &amp;#34;i&amp;#39;ll&amp;#34;: &amp;#34;i will&amp;#34;, &amp;#34;i&amp;#39;ll&amp;#39;ve&amp;#34;: &amp;#34;i will have&amp;#34;,&amp;#34;i&amp;#39;m&amp;#34;: &amp;#34;i am&amp;#34;, &amp;#34;i&amp;#39;ve&amp;#34;: &amp;#34;i have&amp;#34;, &amp;#34;isn&amp;#39;t&amp;#34;: &amp;#34;is not&amp;#34;, &amp;#34;it&amp;#39;d&amp;#34;: &amp;#34;it would&amp;#34;, &amp;#34;it&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;it would have&amp;#34;, &amp;#34;it&amp;#39;ll&amp;#34;: &amp;#34;it will&amp;#34;, &amp;#34;it&amp;#39;ll&amp;#39;ve&amp;#34;: &amp;#34;it will have&amp;#34;,&amp;#34;it&amp;#39;s&amp;#34;: &amp;#34;it is&amp;#34;, &amp;#34;let&amp;#39;s&amp;#34;: &amp;#34;let us&amp;#34;, &amp;#34;ma&amp;#39;am&amp;#34;: &amp;#34;madam&amp;#34;, &amp;#34;mayn&amp;#39;t&amp;#34;: &amp;#34;may not&amp;#34;, &amp;#34;might&amp;#39;ve&amp;#34;: &amp;#34;might have&amp;#34;,&amp;#34;mightn&amp;#39;t&amp;#34;: &amp;#34;might not&amp;#34;,&amp;#34;mightn&amp;#39;t&amp;#39;ve&amp;#34;: &amp;#34;might not have&amp;#34;, &amp;#34;must&amp;#39;ve&amp;#34;: &amp;#34;must have&amp;#34;, &amp;#34;mustn&amp;#39;t&amp;#34;: &amp;#34;must not&amp;#34;, &amp;#34;mustn&amp;#39;t&amp;#39;ve&amp;#34;: &amp;#34;must not have&amp;#34;, &amp;#34;needn&amp;#39;t&amp;#34;: &amp;#34;need not&amp;#34;, &amp;#34;needn&amp;#39;t&amp;#39;ve&amp;#34;: &amp;#34;need not have&amp;#34;,&amp;#34;o&amp;#39;clock&amp;#34;: &amp;#34;of the clock&amp;#34;, &amp;#34;oughtn&amp;#39;t&amp;#34;: &amp;#34;ought not&amp;#34;, &amp;#34;oughtn&amp;#39;t&amp;#39;ve&amp;#34;: &amp;#34;ought not have&amp;#34;, &amp;#34;shan&amp;#39;t&amp;#34;: &amp;#34;shall not&amp;#34;, &amp;#34;sha&amp;#39;n&amp;#39;t&amp;#34;: &amp;#34;shall not&amp;#34;, &amp;#34;shan&amp;#39;t&amp;#39;ve&amp;#34;: &amp;#34;shall not have&amp;#34;, &amp;#34;she&amp;#39;d&amp;#34;: &amp;#34;she would&amp;#34;, &amp;#34;she&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;she would have&amp;#34;, &amp;#34;she&amp;#39;ll&amp;#34;: &amp;#34;she will&amp;#34;, &amp;#34;she&amp;#39;ll&amp;#39;ve&amp;#34;: &amp;#34;she will have&amp;#34;, &amp;#34;she&amp;#39;s&amp;#34;: &amp;#34;she is&amp;#34;, &amp;#34;should&amp;#39;ve&amp;#34;: &amp;#34;should have&amp;#34;, &amp;#34;shouldn&amp;#39;t&amp;#34;: &amp;#34;should not&amp;#34;, &amp;#34;shouldn&amp;#39;t&amp;#39;ve&amp;#34;: &amp;#34;should not have&amp;#34;, &amp;#34;so&amp;#39;ve&amp;#34;: &amp;#34;so have&amp;#34;,&amp;#34;so&amp;#39;s&amp;#34;: &amp;#34;so as&amp;#34;, &amp;#34;this&amp;#39;s&amp;#34;: &amp;#34;this is&amp;#34;,&amp;#34;that&amp;#39;d&amp;#34;: &amp;#34;that would&amp;#34;, &amp;#34;that&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;that would have&amp;#34;, &amp;#34;that&amp;#39;s&amp;#34;: &amp;#34;that is&amp;#34;, &amp;#34;there&amp;#39;d&amp;#34;: &amp;#34;there would&amp;#34;, &amp;#34;there&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;there would have&amp;#34;, &amp;#34;there&amp;#39;s&amp;#34;: &amp;#34;there is&amp;#34;, &amp;#34;here&amp;#39;s&amp;#34;: &amp;#34;here is&amp;#34;,&amp;#34;they&amp;#39;d&amp;#34;: &amp;#34;they would&amp;#34;, &amp;#34;they&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;they would have&amp;#34;, &amp;#34;they&amp;#39;ll&amp;#34;: &amp;#34;they will&amp;#34;, &amp;#34;they&amp;#39;ll&amp;#39;ve&amp;#34;: &amp;#34;they will have&amp;#34;, &amp;#34;they&amp;#39;re&amp;#34;: &amp;#34;they are&amp;#34;, &amp;#34;they&amp;#39;ve&amp;#34;: &amp;#34;they have&amp;#34;, &amp;#34;to&amp;#39;ve&amp;#34;: &amp;#34;to have&amp;#34;, &amp;#34;wasn&amp;#39;t&amp;#34;: &amp;#34;was not&amp;#34;, &amp;#34;we&amp;#39;d&amp;#34;: &amp;#34;we would&amp;#34;, &amp;#34;we&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;we would have&amp;#34;, &amp;#34;we&amp;#39;ll&amp;#34;: &amp;#34;we will&amp;#34;, &amp;#34;we&amp;#39;ll&amp;#39;ve&amp;#34;: &amp;#34;we will have&amp;#34;, &amp;#34;we&amp;#39;re&amp;#34;: &amp;#34;we are&amp;#34;, &amp;#34;we&amp;#39;ve&amp;#34;: &amp;#34;we have&amp;#34;, &amp;#34;weren&amp;#39;t&amp;#34;: &amp;#34;were not&amp;#34;, &amp;#34;what&amp;#39;ll&amp;#34;: &amp;#34;what will&amp;#34;, &amp;#34;what&amp;#39;ll&amp;#39;ve&amp;#34;: &amp;#34;what will have&amp;#34;, &amp;#34;what&amp;#39;re&amp;#34;: &amp;#34;what are&amp;#34;, &amp;#34;what&amp;#39;s&amp;#34;: &amp;#34;what is&amp;#34;, &amp;#34;what&amp;#39;ve&amp;#34;: &amp;#34;what have&amp;#34;, &amp;#34;when&amp;#39;s&amp;#34;: &amp;#34;when is&amp;#34;, &amp;#34;when&amp;#39;ve&amp;#34;: &amp;#34;when have&amp;#34;, &amp;#34;where&amp;#39;d&amp;#34;: &amp;#34;where did&amp;#34;, &amp;#34;where&amp;#39;s&amp;#34;: &amp;#34;where is&amp;#34;, &amp;#34;where&amp;#39;ve&amp;#34;: &amp;#34;where have&amp;#34;, &amp;#34;who&amp;#39;ll&amp;#34;: &amp;#34;who will&amp;#34;, &amp;#34;who&amp;#39;ll&amp;#39;ve&amp;#34;: &amp;#34;who will have&amp;#34;, &amp;#34;who&amp;#39;s&amp;#34;: &amp;#34;who is&amp;#34;, &amp;#34;who&amp;#39;ve&amp;#34;: &amp;#34;who have&amp;#34;, &amp;#34;why&amp;#39;s&amp;#34;: &amp;#34;why is&amp;#34;, &amp;#34;why&amp;#39;ve&amp;#34;: &amp;#34;why have&amp;#34;, &amp;#34;will&amp;#39;ve&amp;#34;: &amp;#34;will have&amp;#34;, &amp;#34;won&amp;#39;t&amp;#34;: &amp;#34;will not&amp;#34;, &amp;#34;won&amp;#39;t&amp;#39;ve&amp;#34;: &amp;#34;will not have&amp;#34;, &amp;#34;would&amp;#39;ve&amp;#34;: &amp;#34;would have&amp;#34;, &amp;#34;wouldn&amp;#39;t&amp;#34;: &amp;#34;would not&amp;#34;, &amp;#34;wouldn&amp;#39;t&amp;#39;ve&amp;#34;: &amp;#34;would not have&amp;#34;, &amp;#34;y&amp;#39;all&amp;#34;: &amp;#34;you all&amp;#34;, &amp;#34;y&amp;#39;all&amp;#39;d&amp;#34;: &amp;#34;you all would&amp;#34;,&amp;#34;y&amp;#39;all&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;you all would have&amp;#34;,&amp;#34;y&amp;#39;all&amp;#39;re&amp;#34;: &amp;#34;you all are&amp;#34;,&amp;#34;y&amp;#39;all&amp;#39;ve&amp;#34;: &amp;#34;you all have&amp;#34;,&amp;#34;you&amp;#39;d&amp;#34;: &amp;#34;you would&amp;#34;, &amp;#34;you&amp;#39;d&amp;#39;ve&amp;#34;: &amp;#34;you would have&amp;#34;, &amp;#34;you&amp;#39;ll&amp;#34;: &amp;#34;you will&amp;#34;, &amp;#34;you&amp;#39;ll&amp;#39;ve&amp;#34;: &amp;#34;you will have&amp;#34;, &amp;#34;you&amp;#39;re&amp;#34;: &amp;#34;you are&amp;#34;, &amp;#34;you&amp;#39;ve&amp;#34;: &amp;#34;you have&amp;#34;} def _get_contractions(contraction_dict): contraction_re = re.compile(&amp;#39;(%s)&amp;#39; % &amp;#39;|&amp;#39;.join(contraction_dict.keys())) return contraction_dict, contraction_re contractions, contractions_re = _get_contractions(contraction_dict) def replace_contractions(text): def replace(match): return contractions[match.group(0)] return contractions_re.sub(replace, text) # Usage replace_contractions(&amp;#34;this&amp;#39;s a text with contraction&amp;#34;) Apart from the above techniques, there are other preprocessing techniques of text like Stemming, Lemmatization and Stopword Removal. Since these techniques are not used along with Deep Learning NLP models, we won&amp;rsquo;t talk about them.
Representation: Sequence Creation One of the things that have made Deep Learning the goto choice for NLP is the fact that we don&amp;rsquo;t really have to hand-engineer features from the text data. The deep learning algorithms take as input a sequence of text to learn the structure of text just like a human does. Since Machine cannot understand words they expect their data in numerical form. So we would like to represent out text data as a series of numbers. To understand how this is done we need to understand a little about the Keras Tokenizer function. One can use any other tokenizer also but keras tokenizer seems like a good choice for me.
a) Tokenizer: In simple words, a tokenizer is a utility function to split a sentence into words. keras.preprocessing.text.Tokenizer tokenizes(splits) the texts into tokens(words) while keeping only the most occurring words in the text corpus.
#Signature: Tokenizer(num_words=None, filters=&amp;#39;!&amp;#34;#$%&amp;amp;()*&#43;,-./:;&amp;lt;=&amp;gt;?@[\\]^_`{|}~\t\n&amp;#39;, lower=True, split=&amp;#39; &amp;#39;, char_level=False, oov_token=None, document_count=0, **kwargs) The num_words parameter keeps a prespecified number of words in the text only. This is helpful as we don&amp;rsquo;t want our models to get a lot of noise by considering words that occur very infrequently. In real-world data, most of the words we leave using num_words param are normally misspells. The tokenizer also filters some non-wanted tokens by default and converts the text into lowercase.
The tokenizer once fitted to the data also keeps an index of words(dictionary of words which we can use to assign a unique number to a word) which can be accessed by tokenizer.word_index. The words in the indexed dictionary are ranked in order of frequencies.
  So the whole code to use tokenizer is as follows:
from keras.preprocessing.text import Tokenizer ## Tokenize the sentences tokenizer = Tokenizer(num_words=max_features) tokenizer.fit_on_texts(list(train_X)&#43;list(test_X)) train_X = tokenizer.texts_to_sequences(train_X) test_X = tokenizer.texts_to_sequences(test_X) where train_X and test_X are lists of documents in the corpus.
b) Pad Sequence: Normally our model expects that each sequence(each training example) will be of the same length(same number of words/tokens). We can control this using the maxlen parameter.
For example:  
train_X = pad_sequences(train_X, maxlen=maxlen) test_X = pad_sequences(test_X, maxlen=maxlen) Now our train data contains a list of list of numbers. Each list has the same length. And we also have the word_index which is a dictionary of most occuring words in the text corpus.
Embedding Enrichment: As I said I will be using GLoVE Word2Vec embeddings to explain the enrichment. GLoVE pretrained vectors are trained on the Wikipedia corpus. (You can download them here). That means some of the words that might be present in your data might not be present in the embeddings. How could we deal with that? Let&amp;rsquo;s first load the Glove Embeddings first.
def load_glove_index(): EMBEDDING_FILE = &amp;#39;../input/embeddings/glove.840B.300d/glove.840B.300d.txt&amp;#39; def get_coefs(word,*arr): return word, np.asarray(arr, dtype=&amp;#39;float32&amp;#39;)[:300] embeddings_index = dict(get_coefs(*o.split(&amp;#34; &amp;#34;)) for o in open(EMBEDDING_FILE)) return embeddings_index glove_embedding_index = load_glove_index() Be sure to put the path of the folder where you download these GLoVE vectors. What does this glove_embedding_index contain? It is just a dictionary in which the key is the word and the value is the word vector, a np.array of length 300. The length of this dictionary is somewhere around a billion. Since we only want the embeddings of words that are in our word_index, we will create a matrix which just contains required embeddings.
  def create_glove(word_index,embeddings_index): emb_mean,emb_std = -0.005838499,0.48782197 all_embs = np.stack(embeddings_index.values()) embed_size = all_embs.shape[1] nb_words = min(max_features, len(word_index)) embedding_matrix = np.random.normal(emb_mean, emb_std, (nb_words, embed_size)) count_found = nb_words for word, i in tqdm(word_index.items()): if i &amp;gt;= max_features: continue embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[i] = embedding_vector else: count_found-=1 print(&amp;#34;Got embedding for &amp;#34;,count_found,&amp;#34; words.&amp;#34;) return embedding_matrix The above code works fine but is there a way that we can use the preprocessing in GLoVE to our advantage? Yes. When preprocessing was done for glove, the creators didn&amp;rsquo;t convert the words to lowercase. That means that it contains multiple variations of a word like &amp;lsquo;USA&amp;rsquo;, &amp;lsquo;usa&amp;rsquo; and &amp;lsquo;Usa&amp;rsquo;. That also means that in some cases while a word like &amp;lsquo;Word&amp;rsquo; is present, its analog in lowercase i.e. &amp;lsquo;word&amp;rsquo; is not present. We can get through this situation by using the below code.
def create_glove(word_index,embeddings_index): emb_mean,emb_std = -0.005838499,0.48782197 all_embs = np.stack(embeddings_index.values()) embed_size = all_embs.shape[1] nb_words = min(max_features, len(word_index)) embedding_matrix = np.random.normal(emb_mean, emb_std, (nb_words, embed_size)) count_found = nb_words for word, i in tqdm(word_index.items()): if i &amp;gt;= max_features: continue embedding_vector = embeddings_index.get(word) if embedding_vector is not None: embedding_matrix[i] = embedding_vector else: if word.islower(): # try to get the embedding of word in titlecase if lowercase is not present embedding_vector = embeddings_index.get(word.capitalize()) if embedding_vector is not None: embedding_matrix[i] = embedding_vector else: count_found-=1 else: count_found-=1 print(&amp;#34;Got embedding for &amp;#34;,count_found,&amp;#34; words.&amp;#34;) return embedding_matrix The above was just an example of how we can use our knowledge of an embedding to get better coverage. Sometimes depending on the problem, one might also derive value by adding extra information to the embeddings using some domain knowledge and NLP skills. For example, we can add external knowledge to the embeddings themselves by adding polarity and subjectivity of a word from the TextBlob package in Python.
from textblob import TextBlob word_sent = TextBlob(&amp;#34;good&amp;#34;).sentiment print(word_sent.polarity,word_sent.subjectivity) # 0.7 0.6 We can get the polarity and subjectivity of any word using TextBlob. Pretty neat. So let us try to add this extra information to our embeddings.
def create_glove(word_index,embeddings_index): emb_mean,emb_std = -0.005838499,0.48782197 all_embs = np.stack(embeddings_index.values()) embed_size = all_embs.shape[1] nb_words = min(max_features, len(word_index)) embedding_matrix = np.random.normal(emb_mean, emb_std, (nb_words, embed_size&#43;4)) count_found = nb_words for word, i in tqdm(word_index.items()): if i &amp;gt;= max_features: continue embedding_vector = embeddings_index.get(word) word_sent = TextBlob(word).sentiment # Extra information we are passing to our embeddings extra_embed = [word_sent.polarity,word_sent.subjectivity] if embedding_vector is not None: embedding_matrix[i] = np.append(embedding_vector,extra_embed) else: if word.islower(): embedding_vector = embeddings_index.get(word.capitalize()) if embedding_vector is not None: embedding_matrix[i] = np.append(embedding_vector,extra_embed) else: embedding_matrix[i,300:] = extra_embed count_found-=1 else: embedding_matrix[i,300:] = extra_embed count_found-=1 print(&amp;#34;Got embedding for &amp;#34;,count_found,&amp;#34; words.&amp;#34;) return embedding_matrix Engineering embeddings is an essential part of getting better performance from the Deep learning models at a later stage. Generally, I revisit this part of code multiple times during the stage of a project while trying to improve my models even further. You can show up a lot of creativity here to improve coverage over your word_index and to include extra features in your embedding.
More Engineered Features   One can always add sentence specific features like sentence length, number of unique words etc. as another input layer to give extra information to the Deep Neural Network. For example: I created these extra features as part of a feature engineering pipeline for Quora Insincerity Classification Challenge.
def add_features(df): df[&amp;#39;question_text&amp;#39;] = df[&amp;#39;question_text&amp;#39;].progress_apply(lambda x:str(x)) df[&amp;#34;lower_question_text&amp;#34;] = df[&amp;#34;question_text&amp;#34;].apply(lambda x: x.lower()) df[&amp;#39;total_length&amp;#39;] = df[&amp;#39;question_text&amp;#39;].progress_apply(len) df[&amp;#39;capitals&amp;#39;] = df[&amp;#39;question_text&amp;#39;].progress_apply(lambda comment: sum(1 for c in comment if c.isupper())) df[&amp;#39;caps_vs_length&amp;#39;] = df.progress_apply(lambda row: float(row[&amp;#39;capitals&amp;#39;])/float(row[&amp;#39;total_length&amp;#39;]), axis=1) df[&amp;#39;num_words&amp;#39;] = df.question_text.str.count(&amp;#39;\S&#43;&amp;#39;) df[&amp;#39;num_unique_words&amp;#39;] = df[&amp;#39;question_text&amp;#39;].progress_apply(lambda comment: len(set(w for w in comment.split()))) df[&amp;#39;words_vs_unique&amp;#39;] = df[&amp;#39;num_unique_words&amp;#39;] / df[&amp;#39;num_words&amp;#39;] return df Conclusion: NLP is still a very interesting problem in Deep Learning space and thus I would encourage you to do a lot of experimentation to see what works and what doesn&amp;rsquo;t. I have tried to provide a wholesome perspective of the preprocessing steps for a Deep Learning Neural network for any NLP problem. But that doesn&amp;rsquo;t mean it is definitive. If you want to learn more about NLP here is an awesome course. You can start for free with the 7-day Free Trial. If you think we can add something to the flow, do mention it in the comments.
Endnotes and References This post is a result of an effort of a lot of excellent Kagglers and I will try to reference them in this section. If I leave out someone, do understand that it was not my intention to do so.
 How to: Preprocessing when using embeddings Improve your Score with some Text Preprocessing Pytorch baseline Pytorch starter  ]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>A Layman guide to moving from Keras to Pytorch</title>
      <link>https://mlwhiz.com/blog/2019/01/06/pytorch_keras_conversion/</link>
      <pubDate>Sun, 06 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2019/01/06/pytorch_keras_conversion/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.comimages/artificial-neural-network.png"></media:content>
      

      
      <description>Recently I started up with a competition on kaggle on text classification, and as a part of the competition, I had to somehow move to Pytorch to get deterministic results. Now I have always worked with Keras in the past and it has given me pretty good results, but somehow I got to know that the CuDNNGRU/CuDNNLSTM layers in keras are not deterministic, even after setting the seeds.</description>

      <content:encoded>  
        
        <![CDATA[    Recently I started up with a competition on kaggle on text classification, and as a part of the competition, I had to somehow move to Pytorch to get deterministic results. Now I have always worked with Keras in the past and it has given me pretty good results, but somehow I got to know that the CuDNNGRU/CuDNNLSTM layers in keras are not deterministic, even after setting the seeds. So Pytorch did come to rescue. And am I glad that I moved.
As a side note: if you want to know more about NLP, I would like to recommend this awesome course on Natural Language Processing in the Advanced machine learning specialization. You can start for free with the 7-day Free Trial. This course covers a wide range of tasks in Natural Language Processing from basic to advanced: Sentiment Analysis, summarization, dialogue state tracking, to name a few.
Also take a look at my other post: Text Preprocessing Methods for Deep Learning, which talks about different preprocessing techniques you can use for your NLP task and What Kagglers are using for Text Classification, which talks about various deep learning models in use in NLP.
Ok back to the task at hand. While Keras is great to start with deep learning, with time you are going to resent some of its limitations. I sort of thought about moving to Tensorflow. It seemed like a good transition as TF is the backend of Keras. But was it hard? With the whole session.run commands and tensorflow sessions, I was sort of confused. It was not Pythonic at all.
Pytorch helps in that since it seems like the python way to do things. You have things under your control and you are not losing anything on the performance front. In the words of Andrej Karpathy:
I&amp;#39;ve been using PyTorch a few months now and I&amp;#39;ve never felt better. I have more energy. My skin is clearer. My eye sight has improved.
&amp;mdash; Andrej Karpathy (@karpathy) May 26, 2017 
So without further ado let me translate Keras to Pytorch for you.
The Classy way to write your network?   Ok, let us create an example network in keras first which we will try to port into Pytorch. Here I would like to give a piece of advice too. When you try to move from Keras to Pytorch take any network you have and try porting it to Pytorch. It will make you understand Pytorch in a much better way. Here I am trying to write one of the networks that gave pretty good results in the Quora Insincere questions classification challenge for me. This model has all the bells and whistles which at least any Text Classification deep learning network could contain with its GRU, LSTM and embedding layers and also a meta input layer. And thus would serve as a good example. Also if you want to read up more on how the BiLSTM/GRU and Attention model work do visit my post here.
def get_model(features,clipvalue=1.,num_filters=40,dropout=0.1,embed_size=501): features_input = Input(shape=(features.shape[1],)) inp = Input(shape=(maxlen, )) # Layer 1: Word2Vec Embeddings. x = Embedding(max_features, embed_size, weights=[embedding_matrix], trainable=False)(inp) # Layer 2: SpatialDropout1D(0.1) x = SpatialDropout1D(dropout)(x) # Layer 3: Bidirectional CuDNNLSTM x = Bidirectional(LSTM(num_filters, return_sequences=True))(x) # Layer 4: Bidirectional CuDNNGRU x, x_h, x_c = Bidirectional(GRU(num_filters, return_sequences=True, return_state = True))(x) # Layer 5: some pooling operations avg_pool = GlobalAveragePooling1D()(x) max_pool = GlobalMaxPooling1D()(x) # Layer 6: A concatenation of the last state, maximum pool, average pool and # additional features x = concatenate([avg_pool, x_h, max_pool,features_input]) # Layer 7: A dense layer x = Dense(16, activation=&amp;#34;relu&amp;#34;)(x) # Layer 8: A dropout layer x = Dropout(0.1)(x) # Layer 9: Output dense layer with one output for our Binary Classification problem. outp = Dense(1, activation=&amp;#34;sigmoid&amp;#34;)(x) # Some keras model creation and compiling model = Model(inputs=[inp,features_input], outputs=outp) adam = optimizers.adam(clipvalue=clipvalue) model.compile(loss=&amp;#39;binary_crossentropy&amp;#39;, optimizer=adam, metrics=[&amp;#39;accuracy&amp;#39;]) return model So a model in pytorch is defined as a class(therefore a little more classy) which inherits from nn.module . Every class necessarily contains an __init__ procedure block and a block for the forward pass.
 In the __init__ part the user defines all the layers the network is going to have but doesn&amp;rsquo;t yet define how those layers would be connected to each other
 In the forward pass block, the user defines how data flows from one layer to another inside the network.
  Why is this Classy? Obviously classy because of Classes. Duh! But jokes apart, I found it beneficial due to a couple of reasons:
1) It gives you a lot of control on how your network is built.
2) You understand a lot about the network when you are building it since you have to specify input and output dimensions. So ** fewer chances of error**. (Although this one is really up to the skill level)
3) Easy to debug networks. Any time you find any problem with the network just use something like print(&amp;quot;avg_pool&amp;quot;, avg_pool.size()) in the forward pass to check the sizes of the layer and you will debug the network easily
4) You can return multiple outputs from the forward layer. This is pretty helpful in the Encoder-Decoder architecture where you can return both the encoder and decoder output. Or in the case of autoencoder where you can return the output of the model and the hidden layer embedding for the data.
5) Pytorch tensors work in a very similar manner to numpy arrays. For example, I could have used Pytorch Maxpool function to write the maxpool layer but max_pool, _ = torch.max(h_gru, 1) will also work.
6) You can set up different layers with different initialization schemes. Something you won&amp;rsquo;t be able to do in Keras. For example, in the below network I have changed the initialization scheme of my LSTM layer. The LSTM layer has different initializations for biases, input layer weights, and hidden layer weights.
7) Wait until you see the training loop in Pytorch You will be amazed at the sort of control it provides.
Now the same model in Pytorch will look like something like this. Do go through the code comments to understand more on how to port.
class Alex_NeuralNet_Meta(nn.Module): def __init__(self,hidden_size,lin_size, embedding_matrix=embedding_matrix): super(Alex_NeuralNet_Meta, self).__init__() # Initialize some parameters for your model self.hidden_size = hidden_size drp = 0.1 # Layer 1: Word2Vec Embeddings. self.embedding = nn.Embedding(max_features, embed_size) self.embedding.weight = nn.Parameter(torch.tensor(embedding_matrix, dtype=torch.float32)) self.embedding.weight.requires_grad = False # Layer 2: Dropout1D(0.1) self.embedding_dropout = nn.Dropout2d(0.1) # Layer 3: Bidirectional CuDNNLSTM self.lstm = nn.LSTM(embed_size, hidden_size, bidirectional=True, batch_first=True) for name, param in self.lstm.named_parameters(): if &amp;#39;bias&amp;#39; in name: nn.init.constant_(param, 0.0) elif &amp;#39;weight_ih&amp;#39; in name: nn.init.kaiming_normal_(param) elif &amp;#39;weight_hh&amp;#39; in name: nn.init.orthogonal_(param) # Layer 4: Bidirectional CuDNNGRU self.gru = nn.GRU(hidden_size*2, hidden_size, bidirectional=True, batch_first=True) for name, param in self.gru.named_parameters(): if &amp;#39;bias&amp;#39; in name: nn.init.constant_(param, 0.0) elif &amp;#39;weight_ih&amp;#39; in name: nn.init.kaiming_normal_(param) elif &amp;#39;weight_hh&amp;#39; in name: nn.init.orthogonal_(param) # Layer 7: A dense layer self.linear = nn.Linear(hidden_size*6 &#43; features.shape[1], lin_size) self.relu = nn.ReLU() # Layer 8: A dropout layer self.dropout = nn.Dropout(drp) # Layer 9: Output dense layer with one output for our Binary Classification problem. self.out = nn.Linear(lin_size, 1) def forward(self, x): &amp;#39;&amp;#39;&amp;#39; here x[0] represents the first element of the input that is going to be passed. We are going to pass a tuple where first one contains the sequences(x[0]) and the second one is a additional feature vector(x[1]) &amp;#39;&amp;#39;&amp;#39; h_embedding = self.embedding(x[0]) # Based on comment by Ivank to integrate spatial dropout. embeddings = h_embedding.unsqueeze(2) # (N, T, 1, K) embeddings = embeddings.permute(0, 3, 2, 1) # (N, K, 1, T) embeddings = self.embedding_dropout(embeddings) # (N, K, 1, T), some features are masked embeddings = embeddings.permute(0, 3, 2, 1) # (N, T, 1, K) h_embedding = embeddings.squeeze(2) # (N, T, K) #h_embedding = torch.squeeze(self.embedding_dropout(torch.unsqueeze(h_embedding, 0))) #print(&amp;#34;emb&amp;#34;, h_embedding.size()) h_lstm, _ = self.lstm(h_embedding) #print(&amp;#34;lst&amp;#34;,h_lstm.size()) h_gru, hh_gru = self.gru(h_lstm) hh_gru = hh_gru.view(-1, 2*self.hidden_size ) #print(&amp;#34;gru&amp;#34;, h_gru.size()) #print(&amp;#34;h_gru&amp;#34;, hh_gru.size()) # Layer 5: is defined dynamically as an operation on tensors. avg_pool = torch.mean(h_gru, 1) max_pool, _ = torch.max(h_gru, 1) #print(&amp;#34;avg_pool&amp;#34;, avg_pool.size()) #print(&amp;#34;max_pool&amp;#34;, max_pool.size()) # the extra features you want to give to the model f = torch.tensor(x[1], dtype=torch.float).cuda() #print(&amp;#34;f&amp;#34;, f.size()) # Layer 6: A concatenation of the last state, maximum pool, average pool and # additional features conc = torch.cat(( hh_gru, avg_pool, max_pool,f), 1) #print(&amp;#34;conc&amp;#34;, conc.size()) # passing conc through linear and relu ops conc = self.relu(self.linear(conc)) conc = self.dropout(conc) out = self.out(conc) # return the final output return out Hope you are still there with me. One thing I would like to emphasize here is that you need to code something up in Pytorch to really understand how it works. And know that once you do that you would be glad that you put in the effort. On to the next section.
Tailored or Readymade: The Best Fit with a highly customizable Training Loop   In the above section I wrote that you will be amazed once you saw the training loop. That was an exaggeration. On the first try you will be a little baffled/confused. But as soon as you read through the loop more than once it will make a lot of intuituve sense. Once again read up the comments and the code to gain a better understanding.
This training loop does k-fold cross-validation on your training data and outputs Out-of-fold train_preds and test_preds averaged over the runs on the test data. I apologize if the flow looks something straight out of a kaggle competition, but if you understand this you would be able to create a training loop for your own workflow. And that is the beauty of Pytorch.
So a brief summary of this loop are as follows:
 Create stratified splits using train data Loop through the splits.  Convert your train and CV data to tensor and load your data to the GPU using the X_train_fold = torch.tensor(x_train[train_idx.astype(int)], dtype=torch.long).cuda() command Load the model onto the GPU using the model.cuda() command Define Loss function, Scheduler and Optimizer create train_loader and valid_loader` to iterate through batches. Start running epochs. In each epoch  Set the model mode to train using model.train(). Go through the batches in train_loader and run the forward pass Run a scheduler step to change the learning rate Compute loss Set the existing gradients in the optimizer to zero Backpropagate the losses through the network Clip the gradients Take an optimizer step to change the weights in the whole network Set the model mode to eval using model.eval(). Get predictions for the validation data using valid_loader and store in variable valid_preds_fold Calculate Loss and print  After all epochs are done. Predict the test data and store the predictions. These predictions will be averaged at the end of the split loop to get the final test_preds Get Out-of-fold(OOF) predictions for train set using train_preds[valid_idx] = valid_preds_fold These OOF predictions can then be used to calculate the Local CV score for your model.   def pytorch_model_run_cv(x_train,y_train,features,x_test, model_obj, feats = False,clip = True): seed_everything() avg_losses_f = [] avg_val_losses_f = [] # matrix for the out-of-fold predictions train_preds = np.zeros((len(x_train))) # matrix for the predictions on the test set test_preds = np.zeros((len(x_test))) splits = list(StratifiedKFold(n_splits=n_splits, shuffle=True, random_state=SEED).split(x_train, y_train)) for i, (train_idx, valid_idx) in enumerate(splits): seed_everything(i*1000&#43;i) x_train = np.array(x_train) y_train = np.array(y_train) if feats: features = np.array(features) x_train_fold = torch.tensor(x_train[train_idx.astype(int)], dtype=torch.long).cuda() y_train_fold = torch.tensor(y_train[train_idx.astype(int), np.newaxis], dtype=torch.float32).cuda() if feats: kfold_X_features = features[train_idx.astype(int)] kfold_X_valid_features = features[valid_idx.astype(int)] x_val_fold = torch.tensor(x_train[valid_idx.astype(int)], dtype=torch.long).cuda() y_val_fold = torch.tensor(y_train[valid_idx.astype(int), np.newaxis], dtype=torch.float32).cuda() model = copy.deepcopy(model_obj) model.cuda() loss_fn = torch.nn.BCEWithLogitsLoss(reduction=&amp;#39;sum&amp;#39;) step_size = 300 base_lr, max_lr = 0.001, 0.003 optimizer = torch.optim.Adam(filter(lambda p: p.requires_grad, model.parameters()), lr=max_lr) ################################################################################################ scheduler = CyclicLR(optimizer, base_lr=base_lr, max_lr=max_lr, step_size=step_size, mode=&amp;#39;exp_range&amp;#39;, gamma=0.99994) ############################################################################################### train = MyDataset(torch.utils.data.TensorDataset(x_train_fold, y_train_fold)) valid = MyDataset(torch.utils.data.TensorDataset(x_val_fold, y_val_fold)) train_loader = torch.utils.data.DataLoader(train, batch_size=batch_size, shuffle=True) valid_loader = torch.utils.data.DataLoader(valid, batch_size=batch_size, shuffle=False) print(f&amp;#39;Fold {i &#43; 1}&amp;#39;) for epoch in range(n_epochs): start_time = time.time() model.train() avg_loss = 0. for i, (x_batch, y_batch, index) in enumerate(train_loader): if feats: f = kfold_X_features[index] y_pred = model([x_batch,f]) else: y_pred = model(x_batch) if scheduler: scheduler.batch_step() # Compute and print loss. loss = loss_fn(y_pred, y_batch) optimizer.zero_grad() loss.backward() if clip: nn.utils.clip_grad_norm_(model.parameters(),1) optimizer.step() avg_loss &#43;= loss.item() / len(train_loader) model.eval() valid_preds_fold = np.zeros((x_val_fold.size(0))) test_preds_fold = np.zeros((len(x_test))) avg_val_loss = 0. for i, (x_batch, y_batch,index) in enumerate(valid_loader): if feats: f = kfold_X_valid_features[index] y_pred = model([x_batch,f]).detach() else: y_pred = model(x_batch).detach() avg_val_loss &#43;= loss_fn(y_pred, y_batch).item() / len(valid_loader) valid_preds_fold[index] = sigmoid(y_pred.cpu().numpy())[:, 0] elapsed_time = time.time() - start_time print(&amp;#39;Epoch {}/{} \tloss={:.4f} \tval_loss={:.4f} \ttime={:.2f}s&amp;#39;.format( epoch &#43; 1, n_epochs, avg_loss, avg_val_loss, elapsed_time)) avg_losses_f.append(avg_loss) avg_val_losses_f.append(avg_val_loss) # predict all samples in the test set batch per batch for i, (x_batch,) in enumerate(test_loader): if feats: f = test_features[i * batch_size:(i&#43;1) * batch_size] y_pred = model([x_batch,f]).detach() else: y_pred = model(x_batch).detach() test_preds_fold[i * batch_size:(i&#43;1) * batch_size] = sigmoid(y_pred.cpu().numpy())[:, 0] train_preds[valid_idx] = valid_preds_fold test_preds &#43;= test_preds_fold / len(splits) print(&amp;#39;All \tloss={:.4f} \tval_loss={:.4f} \t&amp;#39;.format(np.average(avg_losses_f),np.average(avg_val_losses_f))) return train_preds, test_preds But Why? Why so much code? Okay. I get it. That was probably a handful. What you could have done with a simple.fit in keras, takes a lot of code to accomplish in Pytorch. But understand that you get a lot of power too. Some use cases for you to understand:
 While in Keras you have prespecified schedulers like ReduceLROnPlateau (and it is a task to write them), in Pytorch you can experiment like crazy. If you know how to write Python you are going to get along just fine Want to change the structure of your model between the epochs. Yeah you can do it. Changing the input size for convolution networks on the fly. And much more. It is only your imagination that will stop you.  Wanna Run it Yourself?   So another small confession here. The code above will not run as is as there are some code artifacts which I have not shown here. I did this in favor of making the post more readable. Like you see the seed_everything, MyDataset and CyclicLR (From Jeremy Howard Course) functions and classes in the code above which are not really included with Pytorch. But fret not my friend. I have tried to write a Kaggle Kernel with the whole running code. You can see the code here and include it in your projects.
If you liked this post, please don&amp;rsquo;t forget to upvote the Kernel too. I will be obliged.
Endnotes and References This post is a result of an effort of a lot of excellent Kagglers and I will try to reference them in this section. If I leave out someone, do understand that it was not my intention to do so.
 Discussion on 3rd Place winner model in Toxic comment 3rd Place model in Keras by Larry Freeman Pytorch starter Capsule model How to: Preprocessing when using embeddings Improve your Score with some Text Preprocessing Pytorch baseline Pytorch starter  ]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>What Kagglers are using for Text Classification</title>
      <link>https://mlwhiz.com/blog/2018/12/17/text_classification/</link>
      <pubDate>Mon, 17 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2018/12/17/text_classification/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.comimages/text_convolution.png"></media:content>
      

      
      <description>With the problem of Image Classification is more or less solved by Deep learning, Text Classification is the next new developing theme in deep learning. For those who don&amp;amp;rsquo;t know, Text classification is a common task in natural language processing, which transforms a sequence of text of indefinite length into a category of text. How could you use that?
 To find sentiment of a review. Find toxic comments in a platform like Facebook Find Insincere questions on Quora.</description>

      <content:encoded>  
        
        <![CDATA[  With the problem of Image Classification is more or less solved by Deep learning, Text Classification is the next new developing theme in deep learning. For those who don&amp;rsquo;t know, Text classification is a common task in natural language processing, which transforms a sequence of text of indefinite length into a category of text. How could you use that?
 To find sentiment of a review. Find toxic comments in a platform like Facebook Find Insincere questions on Quora. A current ongoing competition on kaggle Find fake reviews on websites Will a text advert get clicked or not  And much more. The whole internet is filled with text and to categorise that information algorithmically will only give us incremental benefits to say the least in the field of AI.
Here I am going to use the data from Quora&amp;rsquo;s Insincere questions to talk about the different models that people are building and sharing to perform this task. Obviously these standalone models are not going to put you on the top of the leaderboard, yet I hope that this ensuing discussion would be helpful for people who want to learn more about text classification. This is going to be a long post in that regard.
As a side note: if you want to know more about NLP, I would like to recommend this awesome course on Natural Language Processing in the Advanced machine learning specialization. You can start for free with the 7-day Free Trial. This course covers a wide range of tasks in Natural Language Processing from basic to advanced: sentiment analysis, summarization, dialogue state tracking, to name a few.
Also take a look at my other post: Text Preprocessing Methods for Deep Learning, which talks about different preprocessing techniques you can use for your NLP task and how to switch from Keras to Pytorch.
So let me try to go through some of the models which people are using to perform text classification and try to provide a brief intuition for them.
1. TextCNN: The idea of using a CNN to classify text was first presented in the paper Convolutional Neural Networks for Sentence Classification by Yoon Kim. Instead of image pixels, the input to the tasks are sentences or documents represented as a matrix. Each row of the matrix corresponds to one word vector. That is, each row is word-vector that represents a word. Thus a sequence of max length 70 gives us a image of 70(max sequence length)x300(embedding size)
  Now for some intuition. While for a image we move our conv filter horizontally also since here we have fixed our kernel size to filter_size x embed_size i.e. (3,300) we are just going to move down for the convolution taking look at three words at once since our filter size is 3 in this case.Also one can think of filter sizes as unigrams, bigrams, trigrams etc. Since we are looking at a context window of 1,2,3, and 5 words respectively. Here is the text classification network coded in Keras:
# https://www.kaggle.com/yekenot/2dcnn-textclassifier def model_cnn(embedding_matrix): filter_sizes = [1,2,3,5] num_filters = 36 inp = Input(shape=(maxlen,)) x = Embedding(max_features, embed_size, weights=[embedding_matrix])(inp) x = Reshape((maxlen, embed_size, 1))(x) maxpool_pool = [] for i in range(len(filter_sizes)): conv = Conv2D(num_filters, kernel_size=(filter_sizes[i], embed_size), kernel_initializer=&amp;#39;he_normal&amp;#39;, activation=&amp;#39;elu&amp;#39;)(x) maxpool_pool.append(MaxPool2D(pool_size=(maxlen - filter_sizes[i] &#43; 1, 1))(conv)) z = Concatenate(axis=1)(maxpool_pool) z = Flatten()(z) z = Dropout(0.1)(z) outp = Dense(1, activation=&amp;#34;sigmoid&amp;#34;)(z) model = Model(inputs=inp, outputs=outp) model.compile(loss=&amp;#39;binary_crossentropy&amp;#39;, optimizer=&amp;#39;adam&amp;#39;, metrics=[&amp;#39;accuracy&amp;#39;]) return model I have written a simplified and well commented code to run this network(taking input from a lot of other kernels) on a kaggle kernel for this competition. Do take a look there to learn the preprocessing steps, and the word to vec embeddings usage in this model. You will learn something. Please do upvote the kernel if you find it helpful. This kernel scored around 0.661 on the public leaderboard.
2. BiDirectional RNN(LSTM/GRU): TextCNN takes care of a lot of things. For example it takes care of words in close range. It is able to see &amp;ldquo;new york&amp;rdquo; together. But it still can&amp;rsquo;t take care of all the context provided in a particular text sequence. It still does not learn the seem to learn the sequential structure of the data, where every word is dependednt on the previous word. Or a word in the previous sentence.
RNN help us with that. They are able to remember previous information using hidden states and connect it to the current task.
Long Short Term Memory networks (LSTM) are a subclass of RNN, specialized in remembering information for a long period of time. More over the Bidirectional LSTM keeps the contextual information in both directions which is pretty useful in text classification task (But won&amp;rsquo;t work for a time sweries prediction task).
  For a most simplistic explanation of Bidirectional RNN, think of RNN cell as taking as input a hidden state(a vector) and the word vector and giving out an output vector and the next hidden state.
 Hidden state, Word vector -&amp;gt;(RNN Cell) -&amp;gt; Output Vector , Next Hidden state  For a sequence of length 4 like &amp;lsquo;you will never believe&amp;rsquo;, The RNN cell will give 4 output vectors. Which can be concatenated and then used as part of a dense feedforward architecture.
In the Bidirectional RNN the only change is that we read the text in the normal fashion as well in reverse. So we stack two RNNs in parallel and hence we get 8 output vectors to append.
Once we get the output vectors we send them through a series of dense layers and finally a softmax layer to build a text classifier.
Due to the limitations of RNNs like not remembering long term dependencies, in practice we almost always use LSTM/GRU to model long term dependencies. In such a case you can just think of the RNN cell being replaced by a LSTM cell or a GRU cell in the above figure. An example model is provided below. You can use CuDNNGRU interchangably with CuDNNLSTM, when you build models.
# BiDirectional LSTM def model_lstm_du(embedding_matrix): inp = Input(shape=(maxlen,)) x = Embedding(max_features, embed_size, weights=[embedding_matrix])(inp) &amp;#39;&amp;#39;&amp;#39; Here 64 is the size(dim) of the hidden state vector as well as the output vector. Keeping return_sequence we want the output for the entire sequence. So what is the dimension of output for this layer? 64*70(maxlen)*2(bidirection concat) CuDNNLSTM is fast implementation of LSTM layer in Keras which only runs on GPU &amp;#39;&amp;#39;&amp;#39; x = Bidirectional(CuDNNLSTM(64, return_sequences=True))(x) avg_pool = GlobalAveragePooling1D()(x) max_pool = GlobalMaxPooling1D()(x) conc = concatenate([avg_pool, max_pool]) conc = Dense(64, activation=&amp;#34;relu&amp;#34;)(conc) conc = Dropout(0.1)(conc) outp = Dense(1, activation=&amp;#34;sigmoid&amp;#34;)(conc) model = Model(inputs=inp, outputs=outp) model.compile(loss=&amp;#39;binary_crossentropy&amp;#39;, optimizer=&amp;#39;adam&amp;#39;, metrics=[&amp;#39;accuracy&amp;#39;]) return model I have written a simplified and well commented code to run this network(taking input from a lot of other kernels) on a kaggle kernel for this competition. Do take a look there to learn the preprocessing steps, and the word to vec embeddings usage in this model. You will learn something. Please do upvote the kernel if you find it helpful. This kernel scored around 0.671 on the public leaderboard.
3. Attention Models The concept of Attention is relatively new as it comes from Hierarchical Attention Networks for Document Classification paper written jointly by CMU and Microsoft guys in 2016.
So in the past we used to find features from text by doing a keyword extraction. Some word are more helpful in determining the category of a text than others. But in this method we sort of lost the sequential structure of text. With LSTM and deep learning methods while we are able to take case of the sequence structure we lose the ability to give higher weightage to more important words. Can we have the best of both worlds?
And that is attention for you. In the author&amp;rsquo;s words:
 Not all words contribute equally to the representation of the sentence meaning. Hence, we introduce attention mechanism to extract such words that are important to the meaning of the sentence and aggregate the representation of those informative words to form a sentence vector
   In essense we want to create scores for every word in the text, which are the attention similarity score for a word.
To do this we start with a weight matrix(W), a bias vector(b) and a context vector u. All of them will be learned by the optimmization algorithm.
Then there are a series of mathematical operations. See the figure for more clarification. We can think of u1 as non linearity on RNN word output. After that v1 is a dot product of u1 with a context vector u raised to an exponentiation. From an intuition viewpoint, the value of v1 will be high if u and u1 are similar. Since we want the sum of scores to be 1, we divide v by the sum of v’s to get the Final Scores,s
These final scores are then multiplied by RNN output for words to weight them according to their importance. After which the outputs are summed and sent through dense layers and softmax for the task of text classification.
def dot_product(x, kernel): &amp;#34;&amp;#34;&amp;#34; Wrapper for dot product operation, in order to be compatible with both Theano and Tensorflow Args: x (): input kernel (): weights Returns: &amp;#34;&amp;#34;&amp;#34; if K.backend() == &amp;#39;tensorflow&amp;#39;: return K.squeeze(K.dot(x, K.expand_dims(kernel)), axis=-1) else: return K.dot(x, kernel) class AttentionWithContext(Layer): &amp;#34;&amp;#34;&amp;#34; Attention operation, with a context/query vector, for temporal data. Supports Masking. Follows the work of Yang et al. [https://www.cs.cmu.edu/~diyiy/docs/naacl16.pdf] &amp;#34;Hierarchical Attention Networks for Document Classification&amp;#34; by using a context vector to assist the attention # Input shape 3D tensor with shape: `(samples, steps, features)`. # Output shape 2D tensor with shape: `(samples, features)`. How to use: Just put it on top of an RNN Layer (GRU/LSTM/SimpleRNN) with return_sequences=True. The dimensions are inferred based on the output shape of the RNN. Note: The layer has been tested with Keras 2.0.6 Example: model.add(LSTM(64, return_sequences=True)) model.add(AttentionWithContext()) # next add a Dense layer (for classification/regression) or whatever... &amp;#34;&amp;#34;&amp;#34; def __init__(self, W_regularizer=None, u_regularizer=None, b_regularizer=None, W_constraint=None, u_constraint=None, b_constraint=None, bias=True, **kwargs): self.supports_masking = True self.init = initializers.get(&amp;#39;glorot_uniform&amp;#39;) self.W_regularizer = regularizers.get(W_regularizer) self.u_regularizer = regularizers.get(u_regularizer) self.b_regularizer = regularizers.get(b_regularizer) self.W_constraint = constraints.get(W_constraint) self.u_constraint = constraints.get(u_constraint) self.b_constraint = constraints.get(b_constraint) self.bias = bias super(AttentionWithContext, self).__init__(**kwargs) def build(self, input_shape): assert len(input_shape) == 3 self.W = self.add_weight((input_shape[-1], input_shape[-1],), initializer=self.init, name=&amp;#39;{}_W&amp;#39;.format(self.name), regularizer=self.W_regularizer, constraint=self.W_constraint) if self.bias: self.b = self.add_weight((input_shape[-1],), initializer=&amp;#39;zero&amp;#39;, name=&amp;#39;{}_b&amp;#39;.format(self.name), regularizer=self.b_regularizer, constraint=self.b_constraint) self.u = self.add_weight((input_shape[-1],), initializer=self.init, name=&amp;#39;{}_u&amp;#39;.format(self.name), regularizer=self.u_regularizer, constraint=self.u_constraint) super(AttentionWithContext, self).build(input_shape) def compute_mask(self, input, input_mask=None): # do not pass the mask to the next layers return None def call(self, x, mask=None): uit = dot_product(x, self.W) if self.bias: uit &#43;= self.b uit = K.tanh(uit) ait = dot_product(uit, self.u) a = K.exp(ait) # apply mask after the exp. will be re-normalized next if mask is not None: # Cast the mask to floatX to avoid float64 upcasting in theano a *= K.cast(mask, K.floatx()) # in some cases especially in the early stages of training the sum may be almost zero # and this results in NaN&amp;#39;s. A workaround is to add a very small positive number ε to the sum. # a /= K.cast(K.sum(a, axis=1, keepdims=True), K.floatx()) a /= K.cast(K.sum(a, axis=1, keepdims=True) &#43; K.epsilon(), K.floatx()) a = K.expand_dims(a) weighted_input = x * a return K.sum(weighted_input, axis=1) def compute_output_shape(self, input_shape): return input_shape[0], input_shape[-1] def model_lstm_atten(embedding_matrix): inp = Input(shape=(maxlen,)) x = Embedding(max_features, embed_size, weights=[embedding_matrix], trainable=False)(inp) x = Bidirectional(CuDNNLSTM(128, return_sequences=True))(x) x = Bidirectional(CuDNNLSTM(64, return_sequences=True))(x) x = AttentionWithContext()(x) x = Dense(64, activation=&amp;#34;relu&amp;#34;)(x) x = Dense(1, activation=&amp;#34;sigmoid&amp;#34;)(x) model = Model(inputs=inp, outputs=x) model.compile(loss=&amp;#39;binary_crossentropy&amp;#39;, optimizer=&amp;#39;adam&amp;#39;, metrics=[&amp;#39;accuracy&amp;#39;]) return model I have written a simplified and well commented code to run this network(taking input from a lot of other kernels) on a kaggle kernel for this competition. Do take a look there to learn the preprocessing steps, and the word to vec embeddings usage in this model. You will learn something. Please do upvote the kernel if you find it helpful. This kernel scored around 0.682 on the public leaderboard.
Hope that Helps! Do checkout the kernels for all the networks and see the comments too. I will try to write a part 2 of this post where I would like to talk about capsule networks and more techniques as they get used in this competition.
Here are the kernel links again: TextCNN,BiLSTM/GRU,Attention
Do upvote the kenels if you find them helpful.
References:  CNN for NLP https://en.diveintodeeplearning.org/d2l-en.pdf https://gist.github.com/cbaziotis/7ef97ccf71cbc14366835198c09809d2 http://univagora.ro/jour/index.php/ijccc/article/view/3142 Shujian&amp;rsquo;s kernel on Kaggle  ]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Object Detection: An End to End Theoretical Perspective</title>
      <link>https://mlwhiz.com/blog/2018/09/22/object_detection/</link>
      <pubDate>Sat, 22 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2018/09/22/object_detection/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.comimages/id1.png"></media:content>
      

      
      <description>We all know about the image classification problem. Given an image can you find out the class the image belongs to? We can solve any new image classification problem with ConvNets and Transfer Learning using pre-trained nets. ConvNet as fixed feature extractor. Take a ConvNet pretrained on ImageNet, remove the last fully-connected layer (this layer&amp;amp;rsquo;s outputs are the 1000 class scores for a different task like ImageNet), then treat the rest of the ConvNet as a fixed feature extractor for the new dataset.</description>

      <content:encoded>  
        
        <![CDATA[  We all know about the image classification problem. Given an image can you find out the class the image belongs to? We can solve any new image classification problem with ConvNets and Transfer Learning using pre-trained nets. ConvNet as fixed feature extractor. Take a ConvNet pretrained on ImageNet, remove the last fully-connected layer (this layer&amp;rsquo;s outputs are the 1000 class scores for a different task like ImageNet), then treat the rest of the ConvNet as a fixed feature extractor for the new dataset. In an AlexNet, this would compute a 4096-D vector for every image that contains the activations of the hidden layer immediately before the classifier. We call these features CNN codes. It is important for performance that these codes are ReLUd (i.e. thresholded at zero) if they were also thresholded during the training of the ConvNet on ImageNet (as is usually the case). Once you extract the 4096-D codes for all images, train a linear classifier (e.g. Linear SVM or Softmax classifier) for the new dataset.  As a side note: if you want to know more about convnets and Transfer Learning I would like to recommend this awesome course on Deep Learning in Computer Vision in the Advanced machine learning specialization. You can start for free with the 7-day Free Trial. This course talks about various CNN architetures and covers a wide variety of problems in the image domain including detection and segmentation.
But there are a lot many interesting problems in the Image domain. The one which we are going to focus on today is the Segmentation, Localization and Detection problem. So what are these problems?
  So these problems are divided into 4 major buckets. In the next few lines I would try to explain each of these problems concisely before we take a deeper dive:
 Semantic Segmentation: Given an image, can we classify each pixel as belonging to a particular class? Classification&#43;Localization: We were able to classify an image as a cat. Great. Can we also get the location of the said cat in that image by drawing a bounding box around the cat? Here we assume that there is a fixed number(commonly 1) in the image. Object Detection: A More general case of the Classification&#43;Localization problem. In a real-world setting, we don&amp;rsquo;t know how many objects are in the image beforehand. So can we detect all the objects in the image and draw bounding boxes around them? Instance Segmentation: Can we create masks for each individual object in the image? It is different from semantic segmentation. How? If you look in the 4th image on the top, we won&amp;rsquo;t be able to distinguish between the two dogs using semantic segmentation procedure as it would sort of merge both the dogs together.  In this post, we will focus mainly on Object Detection.
Classification&#43;Localization So lets first try to understand how we can solve the problem when we have a single object in the image. The Classification&#43;Localization case. Pretty neatly said in the CS231n notes:
Treat localization as a regression problem!    Input Data: Lets first talk about what sort of data such sort of model expects. Normally in an image classification setting we used to have data in the form (X,y) where X is the image and y used to be the class labels. In the Classification&#43;Localization setting we will have data normally in the form (X,y), where X is still the image and y is a array containing (class_label, x,y,w,h) where,
x = bounding box top left corner x-coordinate
y = bounding box top left corner y-coordinate
w = width of bounding box in pixel
h = height of bounding box in pixel
Model: So in this setting we create a multi-output model which takes an image as the input and has (n_labels &#43; 4) output nodes. n_labels nodes for each of the output class and 4 nodes that give the predictions for (x,y,w,h).
Loss: In such a setting setting up the loss is pretty important. Normally the loss is a weighted sum of the Softmax Loss(from the Classification Problem) and the regression L2 loss(from the bounding box coordinates).
$$Loss = alpha*SoftmaxLoss &#43; (1-alpha)*L2Loss$$
Since these two losses would be on a different scale, the alpha hyper-parameter needs to be tuned.
There is one thing I would like to note here. We are trying to do object localization task but we still have our convnets in place here. We are just adding one more output layer to also predict the coordinates of the bounding box and tweaking our loss function. And here in lies the essence of the whole Deep Learning framework - Stack layers on top of each other, reuse components to create better models, and create architectures to solve your own problem. And that is what we are going to see a lot going forward.
Object Detection So how does this idea of localization using regression get mapped to Object Detection? It doesn&amp;rsquo;t. We don&amp;rsquo;t have a fixed number of objects. So we can&amp;rsquo;t have 4 outputs denoting, the bounding box coordinates.
One naive idea could be to apply a CNN to many different crops of the image, CNN classifies each crop as object class or background class. This is intractable. There could be a lot of such crops that you can create.
Region Proposals: If just there was a method(Normally called Region Proposal Network)which could find some cropped regions for us automatically, we could just run our convnet on those regions and be done with object detection. And that is what selective search (Uijlings et al, &amp;ldquo;Selective Search for Object Recognition&amp;rdquo;, IJCV 2013) provided for RCNN.
So what are Region Proposals:
 Find &amp;ldquo;blobby&amp;rdquo; image regions that are likely to contain objects Relatively fast to run; e.g. Selective Search gives 2000 region proposals in a few seconds on CPU  How the region proposals are being made?
Selective Search for Object Recognition: So this paper starts with a set of some initial regions using 13 Graph-based image segmentation techniques generally represent the problem in terms of a graph G = (V, E) where each node v ∈ V corresponds to a pixel in the image, and the edges in E connect certain pairs of neighboring pixels. A weight is associated with each edge based on some property of the pixels that it connects, such as their image intensities. Depending on the method, there may or may not be an edge connecting each pair of vertices.  In this paper they take an approach: Each edge (vi , vj )∈ E has a corresponding weight w((vi , vj )), which is a non-negative measure of the dissimilarity between neighboring elements vi and vj . In the case of image segmentation, the elements in V are pixels and the weight of an edge is some measure of the dissimilarity between the two pixels connected by that edge (e.g., the difference in intensity, color, motion, location or some other local attribute). In the graph-based approach, a segmentation S is a partition of V into components such that each component (or region) C ∈ S corresponds to a connected component in a graph.   
As you can see if we create bounding boxes around these masks we will be losing a lot of regions. We want to have the whole baseball player in a single bounding box/frame. We need to somehow group these initial regions. For that the authors of Selective Search for Object Recognition apply the Hierarchical Grouping algorithm to these initial regions. In this algorithm they merge most similar regions together based on different notions of similarity based on colour, texture, size and fill.
    RCNN The above selective search is the region proposal they used in RCNN paper. But what is RCNN and how does it use region proposals?
  Object detection system overview. Our system (1) takes an input image, (2) extracts around 2000 bottom-up region proposals, (3) computes features for each proposal using a large convolutional neural network (CNN), and then (4) classifies each region using class-specific linear SVM.  Along with this, the authors have also used a class specific bounding box regressor, that takes: Input : (Px,Py,Ph,Pw) - the location of the proposed region. Target: (Gx,Gy,Gh,Gw) - Ground truth labels for the region. The goal is to learn a transformation that maps the proposed region(P) to the Ground truth box(G) ### Training RCNN What is the input to an RCNN? So we have got an image, Region Proposals from the RPN strategy and the ground truths of the labels (labels, ground truth boxes) Next we treat all region proposals with ≥ 0.5 IoU(Intersection over union) overlap with a ground-truth box as positive training example for that box&#39;s class and the rest as negative. We train class specific SVM&#39;s So every region proposal becomes a training example. and the convnet gives a feature vector for that region proposal. We can then train our n-SVMs using the class specific data. ### Test Time RCNN At test time we predict detection boxes using class specific SVMs. We will be getting a lot of overlapping detection boxes at the time of testing. Non-maximum suppression is an integral part of the object detection pipeline. First, it sorts all detection boxes on the basis of their scores. The detection box M with the maximum score is selected and all other detection boxes with a significant overlap (using a pre-defined threshold) with M are suppressed. This process is recursively applied on the remaining boxes   Problems with RCNN: Training is slow. Inference (detection) is slow. 47s / image with VGG16 - Since the Convnet needs to be run many times.
Need for speed. Hence comes in picture by the same authors:
Fast RCNN So the next idea from the same authors: Why not create convolution map of input image and then just select the regions from that convolutional map? Do we really need to run so many convnets? What we can do is run just a single convnet and then apply region proposal crops on the features calculated by the convnet and use a simple SVM to classify those crops.  Something like:   From Paper: Fig. illustrates the Fast R-CNN architecture. A Fast R-CNN network takes as input an entire image and a set of object proposals. The network first processes the whole image with several convolutional (conv) and max pooling layers to produce a conv feature map. Then, for each object proposal a region of interest (RoI) pooling layer extracts a fixed-length feature vector from the feature map. Each feature vector is fed into a sequence of fully connected (fc) layers that finally branch into two sibling output layers: one that produces softmax probability estimates over K object classes plus a catch-all &#34;background&#34; class and another layer that outputs four real-valued numbers for each of the K object classes. Each set of 4 values encodes refined bounding-box positions for one of the K classes.  This idea depends a little upon the architecture of the model that get used too. Do we take the 4096 bottleneck layer from VGG16? So the architecture that the authors have proposed is: We experiment with three pre-trained ImageNet [4] networks, each with five max pooling layers and between five and thirteen conv layers (see Section 4.1 for network details). When a pre-trained network initializes a Fast R-CNN network, it undergoes three transformations. First, the last max pooling layer is replaced by a RoI pooling layer that is configured by setting H and W to be compatible with the net&#39;s first fully connected layer (e.g., H = W = 7 for VGG16). Second, the network&#39;s last fully connected layer and softmax (which were trained for 1000-way ImageNet classification) are replaced with the two sibling layers described earlier (a fully connected layer and softmax over K &#43; 1 categories and category-specific bounding-box regressors). Third, the network is modified to take two data inputs: a list of images and a list of RoIs in those images.  This obviously is a little confusing and &#34;hairy&#34;, let us break this down. But for that, we need to see the VGG16 architecture.   The last pooling layer is 7x7x512. This is the layer the network authors intend to replace by the ROI pooling layers. This pooling layer has got as input the location of the region proposal(xmin_roi,ymin_roi,h_roi,w_roi) and the previous feature map(14x14x512).
  Now the location of ROI coordinates are in the units of the input image i.e. 224x224 pixels. But the layer on which we have to apply the ROI pooling operation is 14x14x512. As we are using VGG we will transform image (224 x 224 x 3) into (14 x 14 x 512) - height and width is divided by 16. we can map ROIs coordinates onto the feature map just by dividing them by 16.
In its depth, the convolutional feature map has encoded all the information for the image while maintaining the location of the &#34;things&#34; it has encoded relative to the original image. For example, if there was a red square on the top left of the image and the convolutional layers activate for it, then the information for that red square would still be on the top left of the convolutional feature map.  How the ROI pooling is done?   In the above image our region proposal is (0,3,5,7) and we divide that area into 4 regions since we want to have a ROI pooling layer of 2x2.
How do you do ROI-Pooling on Areas smaller than the target size? if region proposal size is 5x5 and ROI pooling layer of size 7x7. If this happens, we resize to 35x35 just by copying 7 times each cell and then max-pooling back to 7x7.
After replacing the pooling layer, the authors also replaced the 1000 layer imagenet classification layer by a fully connected layer and softmax over K &#43; 1 categories(&#43;1 for Background) and category-specific bounding-box regressors.
Training Fast-RCNN What is the input to an Fast- RCNN?
Pretty much similar: So we have got an image, Region Proposals from the RPN strategy and the ground truths of the labels (labels, ground truth boxes)
Next we treat all region proposals with ≥ 0.5 IoU(Intersection over union) overlap with a ground-truth box as positive training example for that box&amp;rsquo;s class and the rest as negative. This time we have a dense layer on top, and we use multi task loss.
So every ROI becomes a training example. The main difference is that there is concept of multi-task loss:
A Fast R-CNN network has two sibling output layers. The first outputs a discrete probability distribution (per RoI), p = (p0, . . . , pK), over K &#43; 1 categories. As usual, p is computed by a softmax over the K&#43;1 outputs of a fully connected layer. The second sibling layer outputs bounding-box regression offsets, t= (tx , ty , tw, th), for each of the K object classes. Each training RoI is labeled with a ground-truth class u and a ground-truth bounding-box regression target v. We use a multi-task loss L on each labeled RoI to jointly train for classification and bounding-box regression
  Where Lcls is the softmax classification loss and Lloc is the regression loss. u=0 is for BG class and hence we add to loss only when we have a boundary box for any of the other class. Further:
  Problem:   Faster-RCNN The next question that got asked was : Can the network itself do region proposals?
The intuition is that: With FastRCNN we&#39;re already computing an Activation Map in the CNN, why not run the Activation Map through a few more layers to find the interesting regions, and then finish off the forward pass by predicting the classes &#43; bbox coordinates?    How does the Region Proposal Network work? One of the main idea in the paper is the idea of Anchors. Anchors are fixed bounding boxes that are placed throughout the image with different sizes and ratios that are going to be used for reference when first predicting object locations.
So first of all we define anchor centers on the image.
  The anchor centers are separated by 16 px in case of VGG16 network as the final convolution layer of (14x14x512) subsamples the image by a factor of 16(224&amp;frasl;14). This is how anchors look like:
   So we start with some predefined regions we think our objects could be with Anchors. Our RPN Classifies which regions have the object and the offset of the object bounding box. 1 if IOU for anchor with bounding box&amp;gt;0.5 0 otherwise. Non-Maximum suppression to reduce region proposals Fast RCNN detection network on top of proposals  Faster-RCNN Loss: The whole network is then jointly trained with 4 losses:
 RPN classify object / not object RPN regress box coordinates offset Final classification score (object classes) Final box coordinates offset  Results:   Disclaimer: This is my own understanding of these papers with inputs from many blogs and slides on the internet. Let me know if you find something wrong with my understanding. I will be sure to correct myself and post.
References:  Transfer Learning CS231 Object detection Lecture Slides Efficient Graph-Based Image Segmentation Rich feature hierarchies for accurate object detection and semantic segmentation(RCNN Paper) Selective Search for Object Recognition ROI Pooling Explanation Faster RCNN Blog StackOverflow Faster RCNN Blog Faster RCNN Blog Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks https://www.slideshare.net/WenjingChen7/deep-learning-for-object-detection  ]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Today I Learned This Part 2: Pretrained Neural Networks What are they?</title>
      <link>https://mlwhiz.com/blog/2017/04/17/deep_learning_pretrained_models/</link>
      <pubDate>Mon, 17 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2017/04/17/deep_learning_pretrained_models/</guid>
      
      
      <media:content type="image/jpeg" medium="image" width="700" height="400"
      url="https://mlwhiz.comhttps://image.slidesharecdn.com/practicaldeeplearning-160329181459/95/practical-deep-learning-16-638.jpg"></media:content>
      

      
      <description>Deeplearning is the buzz word right now. I was working on the course for deep learning by Jeremy Howard and one thing I noticed were pretrained deep Neural Networks. In the first lesson he used the pretrained NN to predict on the Dogs vs Cats competition on Kaggle to achieve very good results.
What are pretrained Neural Networks? So let me tell you about the background a little bit. There is a challenge that happens every year in the visual recognition community - The Imagenet Challenge.</description>

      <content:encoded>  
        
        <![CDATA[  Deeplearning is the buzz word right now. I was working on the course for deep learning by Jeremy Howard and one thing I noticed were pretrained deep Neural Networks. In the first lesson he used the pretrained NN to predict on the Dogs vs Cats competition on Kaggle to achieve very good results.
What are pretrained Neural Networks? So let me tell you about the background a little bit. There is a challenge that happens every year in the visual recognition community - The Imagenet Challenge. The task there is to classify the images in 1000 categories using Image training data. People train big convolutional deep learning models for this challenge.
Now what does training a neural model actually mean? It just means that they learn the weights for a NN. What if we can get the weights they learn? We can use those weights to load them into our own NN model and predict on the test dataset. Right?
But actually we can go further than that. We can add an extra layer on top of the NN they have prepared to classify our own dataset.
In a way you can think of the intermediate features created by the Pretrained neural networks to be the features for the next layer.
Why it works? We are essentially doing the image classification task only. We need to find out edges, shapes, intensities and other features from the images that are given to us. The pretrained model is already pretty good at finding these sort of features. Forget neural nets, if we plug these features into a machine learning algorithm we should be good.
What we actually do here is replace the last layer of the neural network with a new prediction/output layer and train while keeping the weights for all the layers before the second last layer constant.
Code: I assume that you understand Keras a little. If not you can look at the docs. Let us get into coding now. First of all we will create the architecture of the neural network the VGG Team created in 2014. Then we will load the weights.
Import some stuff
import numpy as np from numpy.random import random, permutation from scipy import misc, ndimage from scipy.ndimage.interpolation import zoom import keras from keras import backend as K from keras.utils.data_utils import get_file from keras.models import Sequential, Model from keras.layers.core import Flatten, Dense, Dropout, Lambda from keras.layers import Input from keras.layers.convolutional import Convolution2D, MaxPooling2D, ZeroPadding2D from keras.optimizers import SGD, RMSprop, Adam from keras.preprocessing import image VGG has just one type of convolutional block, and one type of fully connected (&amp;lsquo;dense&amp;rsquo;) block. We start by defining the building blocks of our Deep learning model.
def ConvBlock(layers, model, filters): for i in range(layers): model.add(ZeroPadding2D((1,1))) model.add(Convolution2D(filters, 3, 3, activation=&amp;#39;relu&amp;#39;)) model.add(MaxPooling2D((2,2), strides=(2,2))) def FCBlock(model): model.add(Dense(4096, activation=&amp;#39;relu&amp;#39;)) model.add(Dropout(0.5))  Now the input of the VGG Model was images. When the VGG model was trained in 2014, the creators subtracted the average of each of the three (R,G,B) channels first, so that the data for each channel had a mean of zero. Furthermore, their software that expected the channels to be in B,G,R order, whereas Python by default uses R,G,B. We need to preprocess our data to make these two changes, so that it is compatible with the VGG model. We also add some helper functions.
#Mean of each channel as provided by VGG researchers vgg_mean = np.array([123.68, 116.779, 103.939]).reshape((3,1,1)) def vgg_preprocess(x): x = x - vgg_mean # subtract mean return x[:, ::-1] # reverse axis bgr-&amp;gt;rgb def VGG_16(): model = Sequential() model.add(Lambda(vgg_preprocess, input_shape=(3,224,224))) ConvBlock(2, model, 64) ConvBlock(2, model, 128) ConvBlock(3, model, 256) ConvBlock(3, model, 512) ConvBlock(3, model, 512) model.add(Flatten()) FCBlock(model) FCBlock(model) model.add(Dense(1000, activation=&amp;#39;softmax&amp;#39;)) return model def finetune(model, num_classes): # Drop last layer model.pop() # Make all layers untrainable. i.e fix all weights for layer in model.layers: layer.trainable=False # Add a new layer which is the new output layer model.add(Dense(num_classes, activation=&amp;#39;softmax&amp;#39;)) model.compile(optimizer=Adam(lr=0.001), loss=&amp;#39;categorical_crossentropy&amp;#39;, metrics=[&amp;#39;accuracy&amp;#39;]) return model # A way to generate batches of images def get_batches(path, dirname, gen=image.ImageDataGenerator(), shuffle=True, batch_size=64, class_mode=&amp;#39;categorical&amp;#39;): return gen.flow_from_directory(path&#43;dirname, target_size=(224,224), class_mode=class_mode, shuffle=shuffle, batch_size=batch_size) The hard part is done now. Just create a VGG object and load the weights.We will need to load pretrained weights into the model too. You can download the &amp;ldquo;VGG16_weights.h5&amp;rdquo; file here
model = VGG_16() model.load_weights(&amp;#39;VGG16_weights.h5&amp;#39;) # Since our dogs vs cat dataset is binary classification model ftmodel = finetune(model,2) print ftmodel.summary()   Showing a little bit of output here. This is how the last layers of our Neural net look after training. Now we have got a architecture which we got to train. Here we are only training to get the last layer weights. As you can see from the trainable params.
path = &amp;#34;dogscats/&amp;#34; batch_size=64 # Iterators to get our images from our datasets. The datasets are folders named train and valid. Both folder contain two directories &amp;#39;dogs&amp;#39; and &amp;#39;cats&amp;#39;. In each directory the corresponding images are kept. batches = get_batches(path,&amp;#39;train&amp;#39;, batch_size=batch_size) val_batches = get_batches(path,&amp;#39;valid&amp;#39;, batch_size=batch_size) # Now run for some epochs till the validation loss stops decreasing. no_of_epochs=1 for epoch in range(no_of_epochs): print &amp;#34;Running epoch: %d&amp;#34; % epoch ftmodel.fit_generator(batches, samples_per_epoch=batches.nb_sample, nb_epoch=1, validation_data=val_batches, nb_val_samples=val_batches.nb_sample) latest_weights_filename = &amp;#39;ft%d.h5&amp;#39; % epoch ftmodel.save_weights(latest_weights_filename) #Create Predictions on test set. The test images should be in the folder dogscats/test/test_images/ , which is a single directory containing all images. test_batches = get_batches(path, &amp;#39;test&amp;#39;, batch_size=2*batch_size, class_mode=None) preds = ftmodel.predict_generator(test_batches, test_batches.nb_sample) isdog = preds[:,1] image_id = batches.filenames final_submission = np.stack([ids,isdog], axis=1) And we are done!
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Today I Learned This Part I: What are word2vec Embeddings?</title>
      <link>https://mlwhiz.com/blog/2017/04/09/word_vec_embeddings_examples_understanding/</link>
      <pubDate>Sun, 09 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2017/04/09/word_vec_embeddings_examples_understanding/</guid>
      
      

      
      <description>Recently Quora put out a Question similarity competition on Kaggle. This is the first time I was attempting an NLP problem so a lot to learn. The one thing that blew my mind away was the word2vec embeddings.
Till now whenever I heard the term word2vec I visualized it as a way to create a bag of words vector for a sentence.
For those who don&amp;amp;rsquo;t know bag of words: If we have a series of sentences(documents)</description>

      <content:encoded>  
        
        <![CDATA[  Recently Quora put out a Question similarity competition on Kaggle. This is the first time I was attempting an NLP problem so a lot to learn. The one thing that blew my mind away was the word2vec embeddings.
Till now whenever I heard the term word2vec I visualized it as a way to create a bag of words vector for a sentence.
For those who don&amp;rsquo;t know bag of words: If we have a series of sentences(documents)
 This is good - [1,1,1,0,0] This is bad - [1,1,0,1,0] This is awesome - [1,1,0,0,1]  Bag of words would encode it using 0:This 1:is 2:good 3:bad 4:awesome
But it is much more powerful than that.
What word2vec does is that it creates vectors for words. What I mean by that is that we have a 300 dimensional vector for every word(common bigrams too) in a dictionary.
How does that help? We can use this for multiple scenarios but the most common are:
A. Using word2vec embeddings we can find out similarity between words. Assume you have to answer if these two statements signify the same thing:
 President greets press in Chicago Obama speaks to media in Illinois.  If we do a sentence similarity metric or a bag of words approach to compare these two sentences we will get a pretty low score.
  But with a word encoding we can say that
 President is similar to Obama greets is similar to speaks press is similar to media Chicago is similar to Illinois  B. Encode Sentences: I read a post from Abhishek Thakur a prominent kaggler.(Must Read). What he did was he used these word embeddings to create a 300 dimensional vector for every sentence.
His Approach: Lets say the sentence is &amp;ldquo;What is this&amp;rdquo; And lets say the embedding for every word is given in 4 dimension(normally 300 dimensional encoding is given)
 what : [.25 ,.25 ,.25 ,.25] is : [ 1 , 0 , 0 , 0] this : [ .5 , 0 , 0 , .5]  Then the vector for the sentence is normalized elementwise addition of the vectors. i.e.
Elementwise addition : [.25&#43;1&#43;0.5, 0.25&#43;0&#43;0 , 0.25&#43;0&#43;0, .25&#43;0&#43;.5] = [1.75, .25, .25, .75] divided by math.sqrt(1.25^2 &#43; .25^2 &#43; .25^2 &#43; .75^2) = 1.5 gives:[1.16, .17, .17, 0.5]  Thus I can convert any sentence to a vector of a fixed dimension(decided by the embedding). To find similarity between two sentences I can use a variety of distance/similarity metrics.
C. Also It enables us to do algebraic manipulations on words which was not possible before. For example: What is king - man &#43; woman ?
Guess what it comes out to be : Queen
Application/Coding: Now lets get down to the coding part as we know a little bit of fundamentals.
First of all we download a custom word embedding from Google. There are many other embeddings too.
wget https://s3.amazonaws.com/dl4j-distribution/GoogleNews-vectors-negative300.bin.gz The above file is pretty big. Might take some time. Then moving on to coding.
from gensim.models import word2vec model = gensim.models.KeyedVectors.load_word2vec_format(&amp;#39;data/GoogleNews-vectors-negative300.bin.gz&amp;#39;, binary=True) 1. Starting simple, lets find out similar words. Want to find similar words to python? model.most_similar(&amp;#39;python&amp;#39;) [(u&#39;pythons&#39;, 0.6688377261161804),
(u&#39;Burmese_python&#39;, 0.6680364608764648),
(u&#39;snake&#39;, 0.6606293320655823),
(u&#39;crocodile&#39;, 0.6591362953186035),
(u&#39;boa_constrictor&#39;, 0.6443519592285156),
(u&#39;alligator&#39;, 0.6421656608581543),
(u&#39;reptile&#39;, 0.6387745141983032),
(u&#39;albino_python&#39;, 0.6158879995346069),
(u&#39;croc&#39;, 0.6083582639694214),
(u&#39;lizard&#39;, 0.601341724395752)]
 2. Now we can use this model to find the solution to the equation: What is king - man &#43; woman?
model.most_similar(positive = [&amp;#39;king&amp;#39;,&amp;#39;woman&amp;#39;],negative = [&amp;#39;man&amp;#39;]) [(u&#39;queen&#39;, 0.7118192315101624),
(u&#39;monarch&#39;, 0.6189674139022827),
(u&#39;princess&#39;, 0.5902431011199951),
(u&#39;crown_prince&#39;, 0.5499460697174072),
(u&#39;prince&#39;, 0.5377321839332581),
(u&#39;kings&#39;, 0.5236844420433044),
(u&#39;Queen_Consort&#39;, 0.5235946178436279),
(u&#39;queens&#39;, 0.5181134343147278),
(u&#39;sultan&#39;, 0.5098593235015869),
(u&#39;monarchy&#39;, 0.5087412595748901)]
 You can do plenty of freaky/cool things using this:
3. Lets say you wanted a girl and had a girl name like emma in mind but you got a boy. So what is the male version for emma? model.most_similar(positive = [&amp;#39;emma&amp;#39;,&amp;#39;he&amp;#39;,&amp;#39;male&amp;#39;,&amp;#39;mr&amp;#39;],negative = [&amp;#39;she&amp;#39;,&amp;#39;mrs&amp;#39;,&amp;#39;female&amp;#39;]) [(u&#39;sanchez&#39;, 0.4920658469200134),
(u&#39;kenny&#39;, 0.48300960659980774),
(u&#39;alves&#39;, 0.4684845209121704),
(u&#39;gareth&#39;, 0.4530612826347351),
(u&#39;bellamy&#39;, 0.44884198904037476),
(u&#39;gibbs&#39;, 0.445194810628891),
(u&#39;dos_santos&#39;, 0.44508373737335205),
(u&#39;gasol&#39;, 0.44387346506118774),
(u&#39;silva&#39;, 0.4424275755882263),
(u&#39;shaun&#39;, 0.44144102931022644)]
 4. Find which word doesn&amp;rsquo;t belong to a list? model.doesnt_match(&amp;#34;math shopping reading science&amp;#34;.split(&amp;#34; &amp;#34;)) I think staple doesn&amp;rsquo;t belong in this list!
Other Cool Things 1. Recommendations:   In this paper, the authors have shown that itembased CF can be cast in the same framework of word embedding.
2. Some other examples that people have seen after using their own embeddings: Library - Books = Hall
Obama &#43; Russia - USA = Putin
Iraq - Violence = Jordan
President - Power = Prime Minister (Not in India Though)
3.Seeing the above I started playing with it a little. Is this model sexist?
model.most_similar(positive = [&amp;#34;donald_trump&amp;#34;],negative = [&amp;#39;brain&amp;#39;]) [(u&#39;novak&#39;, 0.40405112504959106),
(u&#39;ozzie&#39;, 0.39440611004829407),
(u&#39;democrate&#39;, 0.39187556505203247),
(u&#39;clinton&#39;, 0.390536367893219),
(u&#39;hillary_clinton&#39;, 0.3862358033657074),
(u&#39;bnp&#39;, 0.38295692205429077),
(u&#39;klaar&#39;, 0.38228923082351685),
(u&#39;geithner&#39;, 0.380607008934021),
(u&#39;bafana_bafana&#39;, 0.3801495432853699),
(u&#39;whitman&#39;, 0.3790769875049591)]
 Whatever it is doing it surely feels like magic. Next time I will try to write more on how it works once I understand it fully.
]]>
        
      </content:encoded>
      
      
      
    </item>
    
  </channel>
</rss>