<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:content="http://purl.org/rss/1.0/modules/content" xmlns:media="http://search.yahoo.com/mrss/" >

  
  <channel>
    <title>Nlp on MLWhiz</title>
    <link>https://mlwhiz.com/tags/nlp/</link>
    <description>Recent content in Nlp on MLWhiz</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 06 Jan 2019 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://mlwhiz.com/tags/nlp/atom.xml" rel="self" type="application/rss+xml" />
    

    

    <item>
      <title>A Layman guide to moving from Keras to Pytorch</title>
      <link>https://mlwhiz.com/blog/2019/01/06/pytorch_keras_conversion/</link>
      <pubDate>Sun, 06 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2019/01/06/pytorch_keras_conversion/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.comimages/artificial-neural-network.png"></media:content>
      

      
      <description>Recently I started up with a competition on kaggle on text classification, and as a part of the competition, I had to somehow move to Pytorch to get deterministic results. Now I have always worked with Keras in the past and it has given me pretty good results, but somehow I got to know that the CuDNNGRU/CuDNNLSTM layers in keras are not deterministic, even after setting the seeds.</description>

      <content:encoded>  
        
        <![CDATA[    Recently I started up with a competition on kaggle on text classification, and as a part of the competition, I had to somehow move to Pytorch to get deterministic results. Now I have always worked with Keras in the past and it has given me pretty good results, but somehow I got to know that the CuDNNGRU/CuDNNLSTM layers in keras are not deterministic, even after setting the seeds. So Pytorch did come to rescue. And am I glad that I moved.
As a side note: if you want to know more about NLP, I would like to recommend this awesome course on Natural Language Processing in the Advanced machine learning specialization. You can start for free with the 7-day Free Trial. This course covers a wide range of tasks in Natural Language Processing from basic to advanced: Sentiment Analysis, summarization, dialogue state tracking, to name a few.
Also take a look at my other post: Text Preprocessing Methods for Deep Learning, which talks about different preprocessing techniques you can use for your NLP task and What Kagglers are using for Text Classification, which talks about various deep learning models in use in NLP.
Ok back to the task at hand. While Keras is great to start with deep learning, with time you are going to resent some of its limitations. I sort of thought about moving to Tensorflow. It seemed like a good transition as TF is the backend of Keras. But was it hard? With the whole session.run commands and tensorflow sessions, I was sort of confused. It was not Pythonic at all.
Pytorch helps in that since it seems like the python way to do things. You have things under your control and you are not losing anything on the performance front. In the words of Andrej Karpathy:
I&amp;#39;ve been using PyTorch a few months now and I&amp;#39;ve never felt better. I have more energy. My skin is clearer. My eye sight has improved.
&amp;mdash; Andrej Karpathy (@karpathy) May 26, 2017 
So without further ado let me translate Keras to Pytorch for you.
The Classy way to write your network?   Ok, let us create an example network in keras first which we will try to port into Pytorch. Here I would like to give a piece of advice too. When you try to move from Keras to Pytorch take any network you have and try porting it to Pytorch. It will make you understand Pytorch in a much better way. Here I am trying to write one of the networks that gave pretty good results in the Quora Insincere questions classification challenge for me. This model has all the bells and whistles which at least any Text Classification deep learning network could contain with its GRU, LSTM and embedding layers and also a meta input layer. And thus would serve as a good example. Also if you want to read up more on how the BiLSTM/GRU and Attention model work do visit my post here.
def get_model(features,clipvalue=1.,num_filters=40,dropout=0.1,embed_size=501): features_input = Input(shape=(features.shape[1],)) inp = Input(shape=(maxlen, )) # Layer 1: Word2Vec Embeddings. x = Embedding(max_features, embed_size, weights=[embedding_matrix], trainable=False)(inp) # Layer 2: SpatialDropout1D(0.1) x = SpatialDropout1D(dropout)(x) # Layer 3: Bidirectional CuDNNLSTM x = Bidirectional(LSTM(num_filters, return_sequences=True))(x) # Layer 4: Bidirectional CuDNNGRU x, x_h, x_c = Bidirectional(GRU(num_filters, return_sequences=True, return_state = True))(x) # Layer 5: some pooling operations avg_pool = GlobalAveragePooling1D()(x) max_pool = GlobalMaxPooling1D()(x) # Layer 6: A concatenation of the last state, maximum pool, average pool and  # additional features x = concatenate([avg_pool, x_h, max_pool,features_input]) # Layer 7: A dense layer x = Dense(16, activation=&amp;#34;relu&amp;#34;)(x) # Layer 8: A dropout layer x = Dropout(0.1)(x) # Layer 9: Output dense layer with one output for our Binary Classification problem. outp = Dense(1, activation=&amp;#34;sigmoid&amp;#34;)(x) # Some keras model creation and compiling model = Model(inputs=[inp,features_input], outputs=outp) adam = optimizers.adam(clipvalue=clipvalue) model.compile(loss=&amp;#39;binary_crossentropy&amp;#39;, optimizer=adam, metrics=[&amp;#39;accuracy&amp;#39;]) return model So a model in pytorch is defined as a class(therefore a little more classy) which inherits from nn.module . Every class necessarily contains an __init__ procedure block and a block for the forward pass.
 In the __init__ part the user defines all the layers the network is going to have but doesn&amp;rsquo;t yet define how those layers would be connected to each other
 In the forward pass block, the user defines how data flows from one layer to another inside the network.
  Why is this Classy? Obviously classy because of Classes. Duh! But jokes apart, I found it beneficial due to a couple of reasons:
1) It gives you a lot of control on how your network is built.
2) You understand a lot about the network when you are building it since you have to specify input and output dimensions. So ** fewer chances of error**. (Although this one is really up to the skill level)
3) Easy to debug networks. Any time you find any problem with the network just use something like print(&amp;quot;avg_pool&amp;quot;, avg_pool.size()) in the forward pass to check the sizes of the layer and you will debug the network easily
4) You can return multiple outputs from the forward layer. This is pretty helpful in the Encoder-Decoder architecture where you can return both the encoder and decoder output. Or in the case of autoencoder where you can return the output of the model and the hidden layer embedding for the data.
5) Pytorch tensors work in a very similar manner to numpy arrays. For example, I could have used Pytorch Maxpool function to write the maxpool layer but max_pool, _ = torch.max(h_gru, 1) will also work.
6) You can set up different layers with different initialization schemes. Something you won&amp;rsquo;t be able to do in Keras. For example, in the below network I have changed the initialization scheme of my LSTM layer. The LSTM layer has different initializations for biases, input layer weights, and hidden layer weights.
7) Wait until you see the training loop in Pytorch You will be amazed at the sort of control it provides.
Now the same model in Pytorch will look like something like this. Do go through the code comments to understand more on how to port.
class Alex_NeuralNet_Meta(nn.Module): def __init__(self,hidden_size,lin_size, embedding_matrix=embedding_matrix): super(Alex_NeuralNet_Meta, self).__init__() # Initialize some parameters for your model self.hidden_size = hidden_size drp = 0.1 # Layer 1: Word2Vec Embeddings. self.embedding = nn.Embedding(max_features, embed_size) self.embedding.weight = nn.Parameter(torch.tensor(embedding_matrix, dtype=torch.float32)) self.embedding.weight.requires_grad = False # Layer 2: Dropout1D(0.1) self.embedding_dropout = nn.Dropout2d(0.1) # Layer 3: Bidirectional CuDNNLSTM self.lstm = nn.LSTM(embed_size, hidden_size, bidirectional=True, batch_first=True) for name, param in self.lstm.named_parameters(): if &amp;#39;bias&amp;#39; in name: nn.init.constant_(param, 0.0) elif &amp;#39;weight_ih&amp;#39; in name: nn.init.kaiming_normal_(param) elif &amp;#39;weight_hh&amp;#39; in name: nn.init.orthogonal_(param) # Layer 4: Bidirectional CuDNNGRU self.gru = nn.GRU(hidden_size*2, hidden_size, bidirectional=True, batch_first=True) for name, param in self.gru.named_parameters(): if &amp;#39;bias&amp;#39; in name: nn.init.constant_(param, 0.0) elif &amp;#39;weight_ih&amp;#39; in name: nn.init.kaiming_normal_(param) elif &amp;#39;weight_hh&amp;#39; in name: nn.init.orthogonal_(param) # Layer 7: A dense layer self.linear = nn.Linear(hidden_size*6 &#43; features.shape[1], lin_size) self.relu = nn.ReLU() # Layer 8: A dropout layer  self.dropout = nn.Dropout(drp) # Layer 9: Output dense layer with one output for our Binary Classification problem. self.out = nn.Linear(lin_size, 1) def forward(self, x): &amp;#39;&amp;#39;&amp;#39; here x[0] represents the first element of the input that is going to be passed. We are going to pass a tuple where first one contains the sequences(x[0]) and the second one is a additional feature vector(x[1]) &amp;#39;&amp;#39;&amp;#39; h_embedding = self.embedding(x[0]) # Based on comment by Ivank to integrate spatial dropout.  embeddings = h_embedding.unsqueeze(2) # (N, T, 1, K) embeddings = embeddings.permute(0, 3, 2, 1) # (N, K, 1, T) embeddings = self.embedding_dropout(embeddings) # (N, K, 1, T), some features are masked embeddings = embeddings.permute(0, 3, 2, 1) # (N, T, 1, K) h_embedding = embeddings.squeeze(2) # (N, T, K) #h_embedding = torch.squeeze(self.embedding_dropout(torch.unsqueeze(h_embedding, 0))) #print(&amp;#34;emb&amp;#34;, h_embedding.size()) h_lstm, _ = self.lstm(h_embedding) #print(&amp;#34;lst&amp;#34;,h_lstm.size()) h_gru, hh_gru = self.gru(h_lstm) hh_gru = hh_gru.view(-1, 2*self.hidden_size ) #print(&amp;#34;gru&amp;#34;, h_gru.size()) #print(&amp;#34;h_gru&amp;#34;, hh_gru.size()) # Layer 5: is defined dynamically as an operation on tensors. avg_pool = torch.mean(h_gru, 1) max_pool, _ = torch.max(h_gru, 1) #print(&amp;#34;avg_pool&amp;#34;, avg_pool.size()) #print(&amp;#34;max_pool&amp;#34;, max_pool.size()) # the extra features you want to give to the model f = torch.tensor(x[1], dtype=torch.float).cuda() #print(&amp;#34;f&amp;#34;, f.size()) # Layer 6: A concatenation of the last state, maximum pool, average pool and  # additional features conc = torch.cat(( hh_gru, avg_pool, max_pool,f), 1) #print(&amp;#34;conc&amp;#34;, conc.size()) # passing conc through linear and relu ops conc = self.relu(self.linear(conc)) conc = self.dropout(conc) out = self.out(conc) # return the final output return out Hope you are still there with me. One thing I would like to emphasize here is that you need to code something up in Pytorch to really understand how it works. And know that once you do that you would be glad that you put in the effort. On to the next section.
Tailored or Readymade: The Best Fit with a highly customizable Training Loop   In the above section I wrote that you will be amazed once you saw the training loop. That was an exaggeration. On the first try you will be a little baffled/confused. But as soon as you read through the loop more than once it will make a lot of intuituve sense. Once again read up the comments and the code to gain a better understanding.
This training loop does k-fold cross-validation on your training data and outputs Out-of-fold train_preds and test_preds averaged over the runs on the test data. I apologize if the flow looks something straight out of a kaggle competition, but if you understand this you would be able to create a training loop for your own workflow. And that is the beauty of Pytorch.
So a brief summary of this loop are as follows:
 Create stratified splits using train data Loop through the splits.  Convert your train and CV data to tensor and load your data to the GPU using the X_train_fold = torch.tensor(x_train[train_idx.astype(int)], dtype=torch.long).cuda() command Load the model onto the GPU using the model.cuda() command Define Loss function, Scheduler and Optimizer create train_loader and valid_loader` to iterate through batches. Start running epochs. In each epoch  Set the model mode to train using model.train(). Go through the batches in train_loader and run the forward pass Run a scheduler step to change the learning rate Compute loss Set the existing gradients in the optimizer to zero Backpropagate the losses through the network Clip the gradients Take an optimizer step to change the weights in the whole network Set the model mode to eval using model.eval(). Get predictions for the validation data using valid_loader and store in variable valid_preds_fold Calculate Loss and print  After all epochs are done. Predict the test data and store the predictions. These predictions will be averaged at the end of the split loop to get the final test_preds Get Out-of-fold(OOF) predictions for train set using train_preds[valid_idx] = valid_preds_fold These OOF predictions can then be used to calculate the Local CV score for your model.   def pytorch_model_run_cv(x_train,y_train,features,x_test, model_obj, feats = False,clip = True): seed_everything() avg_losses_f = [] avg_val_losses_f = [] # matrix for the out-of-fold predictions train_preds = np.zeros((len(x_train))) # matrix for the predictions on the test set test_preds = np.zeros((len(x_test))) splits = list(StratifiedKFold(n_splits=n_splits, shuffle=True, random_state=SEED).split(x_train, y_train)) for i, (train_idx, valid_idx) in enumerate(splits): seed_everything(i*1000&#43;i) x_train = np.array(x_train) y_train = np.array(y_train) if feats: features = np.array(features) x_train_fold = torch.tensor(x_train[train_idx.astype(int)], dtype=torch.long).cuda() y_train_fold = torch.tensor(y_train[train_idx.astype(int), np.newaxis], dtype=torch.float32).cuda() if feats: kfold_X_features = features[train_idx.astype(int)] kfold_X_valid_features = features[valid_idx.astype(int)] x_val_fold = torch.tensor(x_train[valid_idx.astype(int)], dtype=torch.long).cuda() y_val_fold = torch.tensor(y_train[valid_idx.astype(int), np.newaxis], dtype=torch.float32).cuda() model = copy.deepcopy(model_obj) model.cuda() loss_fn = torch.nn.BCEWithLogitsLoss(reduction=&amp;#39;sum&amp;#39;) step_size = 300 base_lr, max_lr = 0.001, 0.003 optimizer = torch.optim.Adam(filter(lambda p: p.requires_grad, model.parameters()), lr=max_lr) ################################################################################################ scheduler = CyclicLR(optimizer, base_lr=base_lr, max_lr=max_lr, step_size=step_size, mode=&amp;#39;exp_range&amp;#39;, gamma=0.99994) ############################################################################################### train = MyDataset(torch.utils.data.TensorDataset(x_train_fold, y_train_fold)) valid = MyDataset(torch.utils.data.TensorDataset(x_val_fold, y_val_fold)) train_loader = torch.utils.data.DataLoader(train, batch_size=batch_size, shuffle=True) valid_loader = torch.utils.data.DataLoader(valid, batch_size=batch_size, shuffle=False) print(f&amp;#39;Fold {i &#43; 1}&amp;#39;) for epoch in range(n_epochs): start_time = time.time() model.train() avg_loss = 0. for i, (x_batch, y_batch, index) in enumerate(train_loader): if feats: f = kfold_X_features[index] y_pred = model([x_batch,f]) else: y_pred = model(x_batch) if scheduler: scheduler.batch_step() # Compute and print loss. loss = loss_fn(y_pred, y_batch) optimizer.zero_grad() loss.backward() if clip: nn.utils.clip_grad_norm_(model.parameters(),1) optimizer.step() avg_loss &#43;= loss.item() / len(train_loader) model.eval() valid_preds_fold = np.zeros((x_val_fold.size(0))) test_preds_fold = np.zeros((len(x_test))) avg_val_loss = 0. for i, (x_batch, y_batch,index) in enumerate(valid_loader): if feats: f = kfold_X_valid_features[index] y_pred = model([x_batch,f]).detach() else: y_pred = model(x_batch).detach() avg_val_loss &#43;= loss_fn(y_pred, y_batch).item() / len(valid_loader) valid_preds_fold[index] = sigmoid(y_pred.cpu().numpy())[:, 0] elapsed_time = time.time() - start_time print(&amp;#39;Epoch {}/{} \tloss={:.4f} \tval_loss={:.4f} \ttime={:.2f}s&amp;#39;.format( epoch &#43; 1, n_epochs, avg_loss, avg_val_loss, elapsed_time)) avg_losses_f.append(avg_loss) avg_val_losses_f.append(avg_val_loss) # predict all samples in the test set batch per batch for i, (x_batch,) in enumerate(test_loader): if feats: f = test_features[i * batch_size:(i&#43;1) * batch_size] y_pred = model([x_batch,f]).detach() else: y_pred = model(x_batch).detach() test_preds_fold[i * batch_size:(i&#43;1) * batch_size] = sigmoid(y_pred.cpu().numpy())[:, 0] train_preds[valid_idx] = valid_preds_fold test_preds &#43;= test_preds_fold / len(splits) print(&amp;#39;All \tloss={:.4f} \tval_loss={:.4f} \t&amp;#39;.format(np.average(avg_losses_f),np.average(avg_val_losses_f))) return train_preds, test_preds But Why? Why so much code? Okay. I get it. That was probably a handful. What you could have done with a simple.fit in keras, takes a lot of code to accomplish in Pytorch. But understand that you get a lot of power too. Some use cases for you to understand:
 While in Keras you have prespecified schedulers like ReduceLROnPlateau (and it is a task to write them), in Pytorch you can experiment like crazy. If you know how to write Python you are going to get along just fine Want to change the structure of your model between the epochs. Yeah you can do it. Changing the input size for convolution networks on the fly. And much more. It is only your imagination that will stop you.  Wanna Run it Yourself?   So another small confession here. The code above will not run as is as there are some code artifacts which I have not shown here. I did this in favor of making the post more readable. Like you see the seed_everything, MyDataset and CyclicLR (From Jeremy Howard Course) functions and classes in the code above which are not really included with Pytorch. But fret not my friend. I have tried to write a Kaggle Kernel with the whole running code. You can see the code here and include it in your projects.
If you liked this post, please don&amp;rsquo;t forget to upvote the Kernel too. I will be obliged.
Endnotes and References This post is a result of an effort of a lot of excellent Kagglers and I will try to reference them in this section. If I leave out someone, do understand that it was not my intention to do so.
 Discussion on 3rd Place winner model in Toxic comment 3rd Place model in Keras by Larry Freeman Pytorch starter Capsule model How to: Preprocessing when using embeddings Improve your Score with some Text Preprocessing Pytorch baseline Pytorch starter  ]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>What Kagglers are using for Text Classification</title>
      <link>https://mlwhiz.com/blog/2018/12/17/text_classification/</link>
      <pubDate>Mon, 17 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2018/12/17/text_classification/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.comimages/text_convolution.png"></media:content>
      

      
      <description>With the problem of Image Classification is more or less solved by Deep learning, Text Classification is the next new developing theme in deep learning. For those who don&amp;amp;rsquo;t know, Text classification is a common task in natural language processing, which transforms a sequence of text of indefinite length into a category of text. How could you use that?
 To find sentiment of a review. Find toxic comments in a platform like Facebook Find Insincere questions on Quora.</description>

      <content:encoded>  
        
        <![CDATA[  With the problem of Image Classification is more or less solved by Deep learning, Text Classification is the next new developing theme in deep learning. For those who don&amp;rsquo;t know, Text classification is a common task in natural language processing, which transforms a sequence of text of indefinite length into a category of text. How could you use that?
 To find sentiment of a review. Find toxic comments in a platform like Facebook Find Insincere questions on Quora. A current ongoing competition on kaggle Find fake reviews on websites Will a text advert get clicked or not  And much more. The whole internet is filled with text and to categorise that information algorithmically will only give us incremental benefits to say the least in the field of AI.
Here I am going to use the data from Quora&amp;rsquo;s Insincere questions to talk about the different models that people are building and sharing to perform this task. Obviously these standalone models are not going to put you on the top of the leaderboard, yet I hope that this ensuing discussion would be helpful for people who want to learn more about text classification. This is going to be a long post in that regard.
As a side note: if you want to know more about NLP, I would like to recommend this awesome course on Natural Language Processing in the Advanced machine learning specialization. You can start for free with the 7-day Free Trial. This course covers a wide range of tasks in Natural Language Processing from basic to advanced: sentiment analysis, summarization, dialogue state tracking, to name a few.
Also take a look at my other post: Text Preprocessing Methods for Deep Learning, which talks about different preprocessing techniques you can use for your NLP task and how to switch from Keras to Pytorch.
So let me try to go through some of the models which people are using to perform text classification and try to provide a brief intuition for them.
1. TextCNN: The idea of using a CNN to classify text was first presented in the paper Convolutional Neural Networks for Sentence Classification by Yoon Kim. Instead of image pixels, the input to the tasks are sentences or documents represented as a matrix. Each row of the matrix corresponds to one word vector. That is, each row is word-vector that represents a word. Thus a sequence of max length 70 gives us a image of 70(max sequence length)x300(embedding size)
  Now for some intuition. While for a image we move our conv filter horizontally also since here we have fixed our kernel size to filter_size x embed_size i.e. (3,300) we are just going to move down for the convolution taking look at three words at once since our filter size is 3 in this case.Also one can think of filter sizes as unigrams, bigrams, trigrams etc. Since we are looking at a context window of 1,2,3, and 5 words respectively. Here is the text classification network coded in Keras:
# https://www.kaggle.com/yekenot/2dcnn-textclassifier def model_cnn(embedding_matrix): filter_sizes = [1,2,3,5] num_filters = 36 inp = Input(shape=(maxlen,)) x = Embedding(max_features, embed_size, weights=[embedding_matrix])(inp) x = Reshape((maxlen, embed_size, 1))(x) maxpool_pool = [] for i in range(len(filter_sizes)): conv = Conv2D(num_filters, kernel_size=(filter_sizes[i], embed_size), kernel_initializer=&amp;#39;he_normal&amp;#39;, activation=&amp;#39;elu&amp;#39;)(x) maxpool_pool.append(MaxPool2D(pool_size=(maxlen - filter_sizes[i] &#43; 1, 1))(conv)) z = Concatenate(axis=1)(maxpool_pool) z = Flatten()(z) z = Dropout(0.1)(z) outp = Dense(1, activation=&amp;#34;sigmoid&amp;#34;)(z) model = Model(inputs=inp, outputs=outp) model.compile(loss=&amp;#39;binary_crossentropy&amp;#39;, optimizer=&amp;#39;adam&amp;#39;, metrics=[&amp;#39;accuracy&amp;#39;]) return model I have written a simplified and well commented code to run this network(taking input from a lot of other kernels) on a kaggle kernel for this competition. Do take a look there to learn the preprocessing steps, and the word to vec embeddings usage in this model. You will learn something. Please do upvote the kernel if you find it helpful. This kernel scored around 0.661 on the public leaderboard.
2. BiDirectional RNN(LSTM/GRU): TextCNN takes care of a lot of things. For example it takes care of words in close range. It is able to see &amp;ldquo;new york&amp;rdquo; together. But it still can&amp;rsquo;t take care of all the context provided in a particular text sequence. It still does not learn the seem to learn the sequential structure of the data, where every word is dependednt on the previous word. Or a word in the previous sentence.
RNN help us with that. They are able to remember previous information using hidden states and connect it to the current task.
Long Short Term Memory networks (LSTM) are a subclass of RNN, specialized in remembering information for a long period of time. More over the Bidirectional LSTM keeps the contextual information in both directions which is pretty useful in text classification task (But won&amp;rsquo;t work for a time sweries prediction task).
  For a most simplistic explanation of Bidirectional RNN, think of RNN cell as taking as input a hidden state(a vector) and the word vector and giving out an output vector and the next hidden state.
 Hidden state, Word vector -&amp;gt;(RNN Cell) -&amp;gt; Output Vector , Next Hidden state  For a sequence of length 4 like &amp;lsquo;you will never believe&amp;rsquo;, The RNN cell will give 4 output vectors. Which can be concatenated and then used as part of a dense feedforward architecture.
In the Bidirectional RNN the only change is that we read the text in the normal fashion as well in reverse. So we stack two RNNs in parallel and hence we get 8 output vectors to append.
Once we get the output vectors we send them through a series of dense layers and finally a softmax layer to build a text classifier.
Due to the limitations of RNNs like not remembering long term dependencies, in practice we almost always use LSTM/GRU to model long term dependencies. In such a case you can just think of the RNN cell being replaced by a LSTM cell or a GRU cell in the above figure. An example model is provided below. You can use CuDNNGRU interchangably with CuDNNLSTM, when you build models.
# BiDirectional LSTM def model_lstm_du(embedding_matrix): inp = Input(shape=(maxlen,)) x = Embedding(max_features, embed_size, weights=[embedding_matrix])(inp) &amp;#39;&amp;#39;&amp;#39; Here 64 is the size(dim) of the hidden state vector as well as the output vector. Keeping return_sequence we want the output for the entire sequence. So what is the dimension of output for this layer? 64*70(maxlen)*2(bidirection concat) CuDNNLSTM is fast implementation of LSTM layer in Keras which only runs on GPU &amp;#39;&amp;#39;&amp;#39; x = Bidirectional(CuDNNLSTM(64, return_sequences=True))(x) avg_pool = GlobalAveragePooling1D()(x) max_pool = GlobalMaxPooling1D()(x) conc = concatenate([avg_pool, max_pool]) conc = Dense(64, activation=&amp;#34;relu&amp;#34;)(conc) conc = Dropout(0.1)(conc) outp = Dense(1, activation=&amp;#34;sigmoid&amp;#34;)(conc) model = Model(inputs=inp, outputs=outp) model.compile(loss=&amp;#39;binary_crossentropy&amp;#39;, optimizer=&amp;#39;adam&amp;#39;, metrics=[&amp;#39;accuracy&amp;#39;]) return model I have written a simplified and well commented code to run this network(taking input from a lot of other kernels) on a kaggle kernel for this competition. Do take a look there to learn the preprocessing steps, and the word to vec embeddings usage in this model. You will learn something. Please do upvote the kernel if you find it helpful. This kernel scored around 0.671 on the public leaderboard.
3. Attention Models The concept of Attention is relatively new as it comes from Hierarchical Attention Networks for Document Classification paper written jointly by CMU and Microsoft guys in 2016.
So in the past we used to find features from text by doing a keyword extraction. Some word are more helpful in determining the category of a text than others. But in this method we sort of lost the sequential structure of text. With LSTM and deep learning methods while we are able to take case of the sequence structure we lose the ability to give higher weightage to more important words. Can we have the best of both worlds?
And that is attention for you. In the author&amp;rsquo;s words:
 Not all words contribute equally to the representation of the sentence meaning. Hence, we introduce attention mechanism to extract such words that are important to the meaning of the sentence and aggregate the representation of those informative words to form a sentence vector
   In essense we want to create scores for every word in the text, which are the attention similarity score for a word.
To do this we start with a weight matrix(W), a bias vector(b) and a context vector u. All of them will be learned by the optimmization algorithm.
Then there are a series of mathematical operations. See the figure for more clarification. We can think of u1 as non linearity on RNN word output. After that v1 is a dot product of u1 with a context vector u raised to an exponentiation. From an intuition viewpoint, the value of v1 will be high if u and u1 are similar. Since we want the sum of scores to be 1, we divide v by the sum of v’s to get the Final Scores,s
These final scores are then multiplied by RNN output for words to weight them according to their importance. After which the outputs are summed and sent through dense layers and softmax for the task of text classification.
def dot_product(x, kernel): &amp;#34;&amp;#34;&amp;#34; Wrapper for dot product operation, in order to be compatible with both Theano and Tensorflow Args: x (): input kernel (): weights Returns: &amp;#34;&amp;#34;&amp;#34; if K.backend() == &amp;#39;tensorflow&amp;#39;: return K.squeeze(K.dot(x, K.expand_dims(kernel)), axis=-1) else: return K.dot(x, kernel) class AttentionWithContext(Layer): &amp;#34;&amp;#34;&amp;#34; Attention operation, with a context/query vector, for temporal data. Supports Masking. Follows the work of Yang et al. [https://www.cs.cmu.edu/~diyiy/docs/naacl16.pdf] &amp;#34;Hierarchical Attention Networks for Document Classification&amp;#34; by using a context vector to assist the attention # Input shape 3D tensor with shape: `(samples, steps, features)`. # Output shape 2D tensor with shape: `(samples, features)`. How to use: Just put it on top of an RNN Layer (GRU/LSTM/SimpleRNN) with return_sequences=True. The dimensions are inferred based on the output shape of the RNN. Note: The layer has been tested with Keras 2.0.6 Example: model.add(LSTM(64, return_sequences=True)) model.add(AttentionWithContext()) # next add a Dense layer (for classification/regression) or whatever... &amp;#34;&amp;#34;&amp;#34; def __init__(self, W_regularizer=None, u_regularizer=None, b_regularizer=None, W_constraint=None, u_constraint=None, b_constraint=None, bias=True, **kwargs): self.supports_masking = True self.init = initializers.get(&amp;#39;glorot_uniform&amp;#39;) self.W_regularizer = regularizers.get(W_regularizer) self.u_regularizer = regularizers.get(u_regularizer) self.b_regularizer = regularizers.get(b_regularizer) self.W_constraint = constraints.get(W_constraint) self.u_constraint = constraints.get(u_constraint) self.b_constraint = constraints.get(b_constraint) self.bias = bias super(AttentionWithContext, self).__init__(**kwargs) def build(self, input_shape): assert len(input_shape) == 3 self.W = self.add_weight((input_shape[-1], input_shape[-1],), initializer=self.init, name=&amp;#39;{}_W&amp;#39;.format(self.name), regularizer=self.W_regularizer, constraint=self.W_constraint) if self.bias: self.b = self.add_weight((input_shape[-1],), initializer=&amp;#39;zero&amp;#39;, name=&amp;#39;{}_b&amp;#39;.format(self.name), regularizer=self.b_regularizer, constraint=self.b_constraint) self.u = self.add_weight((input_shape[-1],), initializer=self.init, name=&amp;#39;{}_u&amp;#39;.format(self.name), regularizer=self.u_regularizer, constraint=self.u_constraint) super(AttentionWithContext, self).build(input_shape) def compute_mask(self, input, input_mask=None): # do not pass the mask to the next layers return None def call(self, x, mask=None): uit = dot_product(x, self.W) if self.bias: uit &#43;= self.b uit = K.tanh(uit) ait = dot_product(uit, self.u) a = K.exp(ait) # apply mask after the exp. will be re-normalized next if mask is not None: # Cast the mask to floatX to avoid float64 upcasting in theano a *= K.cast(mask, K.floatx()) # in some cases especially in the early stages of training the sum may be almost zero # and this results in NaN&amp;#39;s. A workaround is to add a very small positive number ε to the sum. # a /= K.cast(K.sum(a, axis=1, keepdims=True), K.floatx()) a /= K.cast(K.sum(a, axis=1, keepdims=True) &#43; K.epsilon(), K.floatx()) a = K.expand_dims(a) weighted_input = x * a return K.sum(weighted_input, axis=1) def compute_output_shape(self, input_shape): return input_shape[0], input_shape[-1] def model_lstm_atten(embedding_matrix): inp = Input(shape=(maxlen,)) x = Embedding(max_features, embed_size, weights=[embedding_matrix], trainable=False)(inp) x = Bidirectional(CuDNNLSTM(128, return_sequences=True))(x) x = Bidirectional(CuDNNLSTM(64, return_sequences=True))(x) x = AttentionWithContext()(x) x = Dense(64, activation=&amp;#34;relu&amp;#34;)(x) x = Dense(1, activation=&amp;#34;sigmoid&amp;#34;)(x) model = Model(inputs=inp, outputs=x) model.compile(loss=&amp;#39;binary_crossentropy&amp;#39;, optimizer=&amp;#39;adam&amp;#39;, metrics=[&amp;#39;accuracy&amp;#39;]) return model I have written a simplified and well commented code to run this network(taking input from a lot of other kernels) on a kaggle kernel for this competition. Do take a look there to learn the preprocessing steps, and the word to vec embeddings usage in this model. You will learn something. Please do upvote the kernel if you find it helpful. This kernel scored around 0.682 on the public leaderboard.
Hope that Helps! Do checkout the kernels for all the networks and see the comments too. I will try to write a part 2 of this post where I would like to talk about capsule networks and more techniques as they get used in this competition.
Here are the kernel links again: TextCNN,BiLSTM/GRU,Attention
Do upvote the kenels if you find them helpful.
References:  CNN for NLP https://en.diveintodeeplearning.org/d2l-en.pdf https://gist.github.com/cbaziotis/7ef97ccf71cbc14366835198c09809d2 http://univagora.ro/jour/index.php/ijccc/article/view/3142 Shujian&amp;rsquo;s kernel on Kaggle  ]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Using XGBoost for time series prediction tasks</title>
      <link>https://mlwhiz.com/blog/2017/12/26/win_a_data_science_competition/</link>
      <pubDate>Tue, 26 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2017/12/26/win_a_data_science_competition/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.comimages/lboard.png"></media:content>
      

      
      <description>Recently Kaggle master Kazanova along with some of his friends released a &amp;amp;ldquo;How to win a data science competition&amp;amp;rdquo; Coursera course. You can start for free with the 7-day Free Trial. The Course involved a final project which itself was a time series prediction problem. Here I will describe how I got a top 10 position as of writing this article.
  Description of the Problem: In this competition we were given a challenging time-series dataset consisting of daily sales data, kindly provided by one of the largest Russian software firms - 1C Company.</description>

      <content:encoded>  
        
        <![CDATA[  Recently Kaggle master Kazanova along with some of his friends released a &amp;ldquo;How to win a data science competition&amp;rdquo; Coursera course. You can start for free with the 7-day Free Trial. The Course involved a final project which itself was a time series prediction problem. Here I will describe how I got a top 10 position as of writing this article.
  Description of the Problem: In this competition we were given a challenging time-series dataset consisting of daily sales data, kindly provided by one of the largest Russian software firms - 1C Company.
We were asked you to predict total sales for every product and store in the next month.
The evaluation metric was RMSE where True target values are clipped into [0,20] range. This target range will be a lot important in understanding the submissions that I will prepare.
The main thing that I noticed was that the data preparation aspect of this competition was by far the most important thing. I creted a variety of features. Here are the steps I took and the features I created.
1. Created a dataframe of all Date_block_num, Store and Item combinations: This is important because in the months we don&amp;rsquo;t have a data for an item store combination, the machine learning algorithm needs to be specifically told that the sales is zero.
from itertools import product # Create &amp;#34;grid&amp;#34; with columns index_cols = [&amp;#39;shop_id&amp;#39;, &amp;#39;item_id&amp;#39;, &amp;#39;date_block_num&amp;#39;] # For every month we create a grid from all shops/items combinations from that month grid = [] for block_num in sales[&amp;#39;date_block_num&amp;#39;].unique(): cur_shops = sales.loc[sales[&amp;#39;date_block_num&amp;#39;] == block_num, &amp;#39;shop_id&amp;#39;].unique() cur_items = sales.loc[sales[&amp;#39;date_block_num&amp;#39;] == block_num, &amp;#39;item_id&amp;#39;].unique() grid.append(np.array(list(product(*[cur_shops, cur_items, [block_num]])),dtype=&amp;#39;int32&amp;#39;)) grid = pd.DataFrame(np.vstack(grid), columns = index_cols,dtype=np.int32) 2. Cleaned up a little of sales data after some basic EDA: sales = sales[sales.item_price&amp;lt;100000] sales = sales[sales.item_cnt_day&amp;lt;=1000] 3. Created Mean Encodings: sales_m = sales.groupby([&amp;#39;date_block_num&amp;#39;,&amp;#39;shop_id&amp;#39;,&amp;#39;item_id&amp;#39;]).agg({&amp;#39;item_cnt_day&amp;#39;: &amp;#39;sum&amp;#39;,&amp;#39;item_price&amp;#39;: np.mean}).reset_index() sales_m = pd.merge(grid,sales_m,on=[&amp;#39;date_block_num&amp;#39;,&amp;#39;shop_id&amp;#39;,&amp;#39;item_id&amp;#39;],how=&amp;#39;left&amp;#39;).fillna(0) # adding the category id too sales_m = pd.merge(sales_m,items,on=[&amp;#39;item_id&amp;#39;],how=&amp;#39;left&amp;#39;) for type_id in [&amp;#39;item_id&amp;#39;,&amp;#39;shop_id&amp;#39;,&amp;#39;item_category_id&amp;#39;]: for column_id,aggregator,aggtype in [(&amp;#39;item_price&amp;#39;,np.mean,&amp;#39;avg&amp;#39;),(&amp;#39;item_cnt_day&amp;#39;,np.sum,&amp;#39;sum&amp;#39;),(&amp;#39;item_cnt_day&amp;#39;,np.mean,&amp;#39;avg&amp;#39;)]: mean_df = sales.groupby([type_id,&amp;#39;date_block_num&amp;#39;]).aggregate(aggregator).reset_index()[[column_id,type_id,&amp;#39;date_block_num&amp;#39;]] mean_df.columns = [type_id&#43;&amp;#39;_&amp;#39;&#43;aggtype&#43;&amp;#39;_&amp;#39;&#43;column_id,type_id,&amp;#39;date_block_num&amp;#39;] sales_m = pd.merge(sales_m,mean_df,on=[&amp;#39;date_block_num&amp;#39;,type_id],how=&amp;#39;left&amp;#39;) These above lines add the following 9 features :
 &amp;lsquo;item_id_avg_item_price&amp;rsquo; &amp;lsquo;item_id_sum_item_cnt_day&amp;rsquo; &amp;lsquo;item_id_avg_item_cnt_day&amp;rsquo; &amp;lsquo;shop_id_avg_item_price&amp;rsquo;, &amp;lsquo;shop_id_sum_item_cnt_day&amp;rsquo; &amp;lsquo;shop_id_avg_item_cnt_day&amp;rsquo; &amp;lsquo;item_category_id_avg_item_price&amp;rsquo; &amp;lsquo;item_category_id_sum_item_cnt_day&amp;rsquo; &amp;lsquo;item_category_id_avg_item_cnt_day&amp;rsquo;  4. Create Lag Features: Next we create lag features with diferent lag periods on the following features:
 &amp;lsquo;item_id_avg_item_price&amp;rsquo;, &amp;lsquo;item_id_sum_item_cnt_day&amp;rsquo; &amp;lsquo;item_id_avg_item_cnt_day&amp;rsquo; &amp;lsquo;shop_id_avg_item_price&amp;rsquo; &amp;lsquo;shop_id_sum_item_cnt_day&amp;rsquo; &amp;lsquo;shop_id_avg_item_cnt_day&amp;rsquo; &amp;lsquo;item_category_id_avg_item_price&amp;rsquo; &amp;lsquo;item_category_id_sum_item_cnt_day&amp;rsquo; &amp;lsquo;item_category_id_avg_item_cnt_day&amp;rsquo; &amp;lsquo;item_cnt_day&amp;rsquo;  lag_variables = list(sales_m.columns[7:])&#43;[&amp;#39;item_cnt_day&amp;#39;] lags = [1 ,2 ,3 ,4, 5, 12] for lag in lags: sales_new_df = sales_m.copy() sales_new_df.date_block_num&#43;=lag sales_new_df = sales_new_df[[&amp;#39;date_block_num&amp;#39;,&amp;#39;shop_id&amp;#39;,&amp;#39;item_id&amp;#39;]&#43;lag_variables] sales_new_df.columns = [&amp;#39;date_block_num&amp;#39;,&amp;#39;shop_id&amp;#39;,&amp;#39;item_id&amp;#39;]&#43; [lag_feat&#43;&amp;#39;_lag_&amp;#39;&#43;str(lag) for lag_feat in lag_variables] sales_means = pd.merge(sales_means, sales_new_df,on=[&amp;#39;date_block_num&amp;#39;,&amp;#39;shop_id&amp;#39;,&amp;#39;item_id&amp;#39;] ,how=&amp;#39;left&amp;#39;) 5. Fill NA with zeros: for feat in sales_means.columns: if &amp;#39;item_cnt&amp;#39; in feat: sales_means[feat]=sales_means[feat].fillna(0) elif &amp;#39;item_price&amp;#39; in feat: sales_means[feat]=sales_means[feat].fillna(sales_means[feat].median()) 6. Drop the columns that we are not going to use in training: cols_to_drop = lag_variables[:-1] &#43; [&amp;#39;item_name&amp;#39;,&amp;#39;item_price&amp;#39;] 7. Take a recent bit of data only: sales_means = sales_means[sales_means[&amp;#39;date_block_num&amp;#39;]&amp;gt;12] 8. Split in train and CV : X_train = sales_means[sales_means[&amp;#39;date_block_num&amp;#39;]&amp;lt;33].drop(cols_to_drop, axis=1) X_cv = sales_means[sales_means[&amp;#39;date_block_num&amp;#39;]==33].drop(cols_to_drop, axis=1) 9. THE MAGIC SAUCE: In the start I told that the clipping aspect of [0,20] will be important. In the next few lines I clipped the days to range[0,40]. You might ask me why 40. An intuitive answer is if I had clipped to range [0,20] there would be very few tree nodes that could give 20 as an answer. While if I increase it to 40 having a 20 becomes much more easier. Please note that We will clip our predictions in the [0,20] range in the end.
def clip(x): if x&amp;gt;40: return 40 elif x&amp;lt;0: return 0 else: return x train[&amp;#39;item_cnt_day&amp;#39;] = train.apply(lambda x: clip(x[&amp;#39;item_cnt_day&amp;#39;]),axis=1) cv[&amp;#39;item_cnt_day&amp;#39;] = cv.apply(lambda x: clip(x[&amp;#39;item_cnt_day&amp;#39;]),axis=1) 10: Modelling:  Created a XGBoost model to get the most important features(Top 42 features) Use hyperopt to tune xgboost Used top 10 models from tuned XGBoosts to generate predictions. clipped the predictions to [0,20] range Final solution was the average of these 10 predictions.  Learned a lot of new things from this awesome course. Most recommended.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Good Feature Building Techniques - Tricks for Kaggle -  My Kaggle Code Repository</title>
      <link>https://mlwhiz.com/blog/2017/09/14/kaggle_tricks/</link>
      <pubDate>Thu, 14 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2017/09/14/kaggle_tricks/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.comhttps://storage.googleapis.com/kaggle-organizations/4/thumbnail.png"></media:content>
      

      
      <description>Often times it happens that we fall short of creativity. And creativity is one of the basic ingredients of what we do. Creating features needs creativity. So here is the list of ideas I gather in day to day life, where people have used creativity to get great results on Kaggle leaderboards.
Take a look at the How to Win a Data Science Competition: Learn from Top Kagglers course in the Advanced machine learning specialization by Kazanova(Number 3 Kaggler at the time of writing).</description>

      <content:encoded>  
        
        <![CDATA[  Often times it happens that we fall short of creativity. And creativity is one of the basic ingredients of what we do. Creating features needs creativity. So here is the list of ideas I gather in day to day life, where people have used creativity to get great results on Kaggle leaderboards.
Take a look at the How to Win a Data Science Competition: Learn from Top Kagglers course in the Advanced machine learning specialization by Kazanova(Number 3 Kaggler at the time of writing). You can start for free with the 7-day Free Trial.
This post is inspired by a Kernel on Kaggle written by Beluga, one of the top Kagglers, for a knowledge based competition.
Some of the techniques/tricks I am sharing have been taken directly from that kernel so you could take a look yourself. Otherwise stay here and read on.
1. Don&amp;rsquo;t try predicting the future when you don&amp;rsquo;t have to: If both training/test comes from the same timeline, we can get really crafty with features. Although this is a case with Kaggle only, we can use this to our advantage. For example: In the Taxi Trip duration challenge the test data is randomly sampled from the train data. In this case we can use the target variable averaged over different categorical variable as a feature. Like in this case Beluga actually used the averaged the target variable over different weekdays. He then mapped the same averaged value as a variable by mapping it to test data too.
2. logloss clipping Technique: Something that I learned in the Neural Network course by Jeremy Howard. Its based on a very simple Idea. Logloss penalises a lot if we are very confident and wrong. So in case of Classification problems where we have to predict probabilities, it would be much better to clip our probabilities between 0.05-0.95 so that we are never very sure about our prediction.
3. kaggle submission in gzip format: A small piece of code that will help you save countless hours of uploading. Enjoy. df.to_csv(&amp;lsquo;submission.csv.gz&amp;rsquo;, index=False, compression=&amp;lsquo;gzip&amp;rsquo;)
4. How best to use Latitude and Longitude features - Part 1: One of the best things that I liked about the Beluga Kernel is how he used the Lat/Lon Data. So in the example we had pickup Lat/Lon and Dropoff Lat/Lon. We created features like:
A. Haversine Distance Between the Two Lat/Lons: def haversine_array(lat1, lng1, lat2, lng2): lat1, lng1, lat2, lng2 = map(np.radians, (lat1, lng1, lat2, lng2)) AVG_EARTH_RADIUS = 6371 # in km lat = lat2 - lat1 lng = lng2 - lng1 d = np.sin(lat * 0.5) ** 2 &#43; np.cos(lat1) * np.cos(lat2) * np.sin(lng * 0.5) ** 2 h = 2 * AVG_EARTH_RADIUS * np.arcsin(np.sqrt(d)) return h B. Manhattan Distance Between the two Lat/Lons: def dummy_manhattan_distance(lat1, lng1, lat2, lng2): a = haversine_array(lat1, lng1, lat1, lng2) b = haversine_array(lat1, lng1, lat2, lng1) return a &#43; b C. Bearing Between the two Lat/Lons: def bearing_array(lat1, lng1, lat2, lng2): AVG_EARTH_RADIUS = 6371 # in km lng_delta_rad = np.radians(lng2 - lng1) lat1, lng1, lat2, lng2 = map(np.radians, (lat1, lng1, lat2, lng2)) y = np.sin(lng_delta_rad) * np.cos(lat2) x = np.cos(lat1) * np.sin(lat2) - np.sin(lat1) * np.cos(lat2) * np.cos(lng_delta_rad) return np.degrees(np.arctan2(y, x)) D. Center Latitude and Longitude between Pickup and Dropoff: train.loc[:, &amp;#39;center_latitude&amp;#39;] = (train[&amp;#39;pickup_latitude&amp;#39;].values &#43; train[&amp;#39;dropoff_latitude&amp;#39;].values) / 2 train.loc[:, &amp;#39;center_longitude&amp;#39;] = (train[&amp;#39;pickup_longitude&amp;#39;].values &#43; train[&amp;#39;dropoff_longitude&amp;#39;].values) / 2 5. How best to use Latitude and Longitude features - Part 2: The Second way he used the Lat/Lon Feats was to create clusters for Pickup and Dropoff Lat/Lons. The way it worked was it created sort of Boroughs in the data by design.
from sklearn.cluster import MiniBatchKMeans coords = np.vstack((train[[&amp;#39;pickup_latitude&amp;#39;, &amp;#39;pickup_longitude&amp;#39;]].values, train[[&amp;#39;dropoff_latitude&amp;#39;, &amp;#39;dropoff_longitude&amp;#39;]].values, test[[&amp;#39;pickup_latitude&amp;#39;, &amp;#39;pickup_longitude&amp;#39;]].values, test[[&amp;#39;dropoff_latitude&amp;#39;, &amp;#39;dropoff_longitude&amp;#39;]].values)) sample_ind = np.random.permutation(len(coords))[:500000] kmeans = MiniBatchKMeans(n_clusters=100, batch_size=10000).fit(coords[sample_ind]) train.loc[:, &amp;#39;pickup_cluster&amp;#39;] = kmeans.predict(train[[&amp;#39;pickup_latitude&amp;#39;, &amp;#39;pickup_longitude&amp;#39;]]) train.loc[:, &amp;#39;dropoff_cluster&amp;#39;] = kmeans.predict(train[[&amp;#39;dropoff_latitude&amp;#39;, &amp;#39;dropoff_longitude&amp;#39;]]) test.loc[:, &amp;#39;pickup_cluster&amp;#39;] = kmeans.predict(test[[&amp;#39;pickup_latitude&amp;#39;, &amp;#39;pickup_longitude&amp;#39;]]) test.loc[:, &amp;#39;dropoff_cluster&amp;#39;] = kmeans.predict(test[[&amp;#39;dropoff_latitude&amp;#39;, &amp;#39;dropoff_longitude&amp;#39;]]) He then used these Clusters to create features like counting no of trips going out and coming in on a particular day.
6. How best to use Latitude and Longitude features - Part 3 He used PCA to transform longitude and latitude coordinates. In this case it is not about dimension reduction since he transformed 2D-&amp;gt; 2D. The rotation could help for decision tree splits, and it did actually.
pca = PCA().fit(coords) train[&amp;#39;pickup_pca0&amp;#39;] = pca.transform(train[[&amp;#39;pickup_latitude&amp;#39;, &amp;#39;pickup_longitude&amp;#39;]])[:, 0] train[&amp;#39;pickup_pca1&amp;#39;] = pca.transform(train[[&amp;#39;pickup_latitude&amp;#39;, &amp;#39;pickup_longitude&amp;#39;]])[:, 1] train[&amp;#39;dropoff_pca0&amp;#39;] = pca.transform(train[[&amp;#39;dropoff_latitude&amp;#39;, &amp;#39;dropoff_longitude&amp;#39;]])[:, 0] train[&amp;#39;dropoff_pca1&amp;#39;] = pca.transform(train[[&amp;#39;dropoff_latitude&amp;#39;, &amp;#39;dropoff_longitude&amp;#39;]])[:, 1] test[&amp;#39;pickup_pca0&amp;#39;] = pca.transform(test[[&amp;#39;pickup_latitude&amp;#39;, &amp;#39;pickup_longitude&amp;#39;]])[:, 0] test[&amp;#39;pickup_pca1&amp;#39;] = pca.transform(test[[&amp;#39;pickup_latitude&amp;#39;, &amp;#39;pickup_longitude&amp;#39;]])[:, 1] test[&amp;#39;dropoff_pca0&amp;#39;] = pca.transform(test[[&amp;#39;dropoff_latitude&amp;#39;, &amp;#39;dropoff_longitude&amp;#39;]])[:, 0] test[&amp;#39;dropoff_pca1&amp;#39;] = pca.transform(test[[&amp;#39;dropoff_latitude&amp;#39;, &amp;#39;dropoff_longitude&amp;#39;]])[:, 1] 7. Lets not forget the Normal Things you can do with your features:  Scaling by Max-Min Normalization using Standard Deviation Log based feature/Target: use log based features or log based target function. One Hot Encoding  8. Creating Intuitive Additional Features: A) Date time Features: Time based Features like &amp;ldquo;Evening&amp;rdquo;, &amp;ldquo;Noon&amp;rdquo;, &amp;ldquo;Night&amp;rdquo;, &amp;ldquo;Purchases_last_month&amp;rdquo;, &amp;ldquo;Purchases_last_week&amp;rdquo; etc.
B) Thought Features: Suppose you have shopping cart data and you want to categorize TripType (See Walmart Recruiting: Trip Type Classification on Kaggle for some background).
You could think of creating a feature like &amp;ldquo;Stylish&amp;rdquo; where you create this variable by adding together number of items that belong to category Men&amp;rsquo;s Fashion, Women&amp;rsquo;s Fashion, Teens Fashion.
You could create a feature like &amp;ldquo;Rare&amp;rdquo; which is created by tagging some items as rare, based on the data we have and then counting the number of those rare items in the shopping cart. Such features might work or might not work. From what I have observed they normally provide a lot of value.
I feel this is the way that Target&amp;rsquo;s &amp;ldquo;Pregnant Teen model&amp;rdquo; was made. They would have had a variable in which they kept all the items that a pregnant teen could buy and put it into a classification algorithm.
9 . The not so Normal Things which people do: These features are highly unintuitive and should not be created where the machine learning model needs to be interpretable.
A) Interaction Features: If you have features A and B create features A*B, A&#43;B, A/B, A-B. This explodes the feature space. If you have 10 features and you are creating two variable interactions you will be adding 10C2 * 4 features = 180 features to your model. And most of us have a lot more than 10 features.
B) Bucket Feature Using Hashing: Suppose you have a lot of features. In the order of Thousands but you don&amp;rsquo;t want to use all the thousand features because of the training times of algorithms involved. People bucket their features using some hashing algorithm to achieve this.Mostly done for text classification tasks. For example: If we have 6 features A,B,C,D,E,F. And the row of data is: A:1,B:1,C:1,D:0,E:1,F:0 I may decide to use a hashing function so that these 6 features correspond to 3 buckets and create the data using this feature hashing vector. After processing my data might look like: Bucket1:2,Bucket2:2,Bucket3:0 Which happened because A and B fell in bucket1, C and E fell in bucket2 and D and F fell in bucket 3. I summed up the observations here, but you could substitute addition with any math function you like. Now i would use Bucket1,Bucket2,Bucket3 as my variables for machine learning.
Will try to keep on expanding. Wait for more&amp;hellip;.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Today I Learned This Part I: What are word2vec Embeddings?</title>
      <link>https://mlwhiz.com/blog/2017/04/09/word_vec_embeddings_examples_understanding/</link>
      <pubDate>Sun, 09 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2017/04/09/word_vec_embeddings_examples_understanding/</guid>
      
      

      
      <description>Recently Quora put out a Question similarity competition on Kaggle. This is the first time I was attempting an NLP problem so a lot to learn. The one thing that blew my mind away was the word2vec embeddings.
Till now whenever I heard the term word2vec I visualized it as a way to create a bag of words vector for a sentence.
For those who don&amp;amp;rsquo;t know bag of words: If we have a series of sentences(documents)</description>

      <content:encoded>  
        
        <![CDATA[  Recently Quora put out a Question similarity competition on Kaggle. This is the first time I was attempting an NLP problem so a lot to learn. The one thing that blew my mind away was the word2vec embeddings.
Till now whenever I heard the term word2vec I visualized it as a way to create a bag of words vector for a sentence.
For those who don&amp;rsquo;t know bag of words: If we have a series of sentences(documents)
 This is good - [1,1,1,0,0] This is bad - [1,1,0,1,0] This is awesome - [1,1,0,0,1]  Bag of words would encode it using 0:This 1:is 2:good 3:bad 4:awesome
But it is much more powerful than that.
What word2vec does is that it creates vectors for words. What I mean by that is that we have a 300 dimensional vector for every word(common bigrams too) in a dictionary.
How does that help? We can use this for multiple scenarios but the most common are:
A. Using word2vec embeddings we can find out similarity between words. Assume you have to answer if these two statements signify the same thing:
 President greets press in Chicago Obama speaks to media in Illinois.  If we do a sentence similarity metric or a bag of words approach to compare these two sentences we will get a pretty low score.
  But with a word encoding we can say that
 President is similar to Obama greets is similar to speaks press is similar to media Chicago is similar to Illinois  B. Encode Sentences: I read a post from Abhishek Thakur a prominent kaggler.(Must Read). What he did was he used these word embeddings to create a 300 dimensional vector for every sentence.
His Approach: Lets say the sentence is &amp;ldquo;What is this&amp;rdquo; And lets say the embedding for every word is given in 4 dimension(normally 300 dimensional encoding is given)
 what : [.25 ,.25 ,.25 ,.25] is : [ 1 , 0 , 0 , 0] this : [ .5 , 0 , 0 , .5]  Then the vector for the sentence is normalized elementwise addition of the vectors. i.e.
Elementwise addition : [.25&#43;1&#43;0.5, 0.25&#43;0&#43;0 , 0.25&#43;0&#43;0, .25&#43;0&#43;.5] = [1.75, .25, .25, .75] divided by math.sqrt(1.25^2 &#43; .25^2 &#43; .25^2 &#43; .75^2) = 1.5 gives:[1.16, .17, .17, 0.5]  Thus I can convert any sentence to a vector of a fixed dimension(decided by the embedding). To find similarity between two sentences I can use a variety of distance/similarity metrics.
C. Also It enables us to do algebraic manipulations on words which was not possible before. For example: What is king - man &#43; woman ?
Guess what it comes out to be : Queen
Application/Coding: Now lets get down to the coding part as we know a little bit of fundamentals.
First of all we download a custom word embedding from Google. There are many other embeddings too.
wget https://s3.amazonaws.com/dl4j-distribution/GoogleNews-vectors-negative300.bin.gz The above file is pretty big. Might take some time. Then moving on to coding.
from gensim.models import word2vec model = gensim.models.KeyedVectors.load_word2vec_format(&amp;#39;data/GoogleNews-vectors-negative300.bin.gz&amp;#39;, binary=True) 1. Starting simple, lets find out similar words. Want to find similar words to python? model.most_similar(&amp;#39;python&amp;#39;) [(u&#39;pythons&#39;, 0.6688377261161804),
(u&#39;Burmese_python&#39;, 0.6680364608764648),
(u&#39;snake&#39;, 0.6606293320655823),
(u&#39;crocodile&#39;, 0.6591362953186035),
(u&#39;boa_constrictor&#39;, 0.6443519592285156),
(u&#39;alligator&#39;, 0.6421656608581543),
(u&#39;reptile&#39;, 0.6387745141983032),
(u&#39;albino_python&#39;, 0.6158879995346069),
(u&#39;croc&#39;, 0.6083582639694214),
(u&#39;lizard&#39;, 0.601341724395752)]
 2. Now we can use this model to find the solution to the equation: What is king - man &#43; woman?
model.most_similar(positive = [&amp;#39;king&amp;#39;,&amp;#39;woman&amp;#39;],negative = [&amp;#39;man&amp;#39;]) [(u&#39;queen&#39;, 0.7118192315101624),
(u&#39;monarch&#39;, 0.6189674139022827),
(u&#39;princess&#39;, 0.5902431011199951),
(u&#39;crown_prince&#39;, 0.5499460697174072),
(u&#39;prince&#39;, 0.5377321839332581),
(u&#39;kings&#39;, 0.5236844420433044),
(u&#39;Queen_Consort&#39;, 0.5235946178436279),
(u&#39;queens&#39;, 0.5181134343147278),
(u&#39;sultan&#39;, 0.5098593235015869),
(u&#39;monarchy&#39;, 0.5087412595748901)]
 You can do plenty of freaky/cool things using this:
3. Lets say you wanted a girl and had a girl name like emma in mind but you got a boy. So what is the male version for emma? model.most_similar(positive = [&amp;#39;emma&amp;#39;,&amp;#39;he&amp;#39;,&amp;#39;male&amp;#39;,&amp;#39;mr&amp;#39;],negative = [&amp;#39;she&amp;#39;,&amp;#39;mrs&amp;#39;,&amp;#39;female&amp;#39;]) [(u&#39;sanchez&#39;, 0.4920658469200134),
(u&#39;kenny&#39;, 0.48300960659980774),
(u&#39;alves&#39;, 0.4684845209121704),
(u&#39;gareth&#39;, 0.4530612826347351),
(u&#39;bellamy&#39;, 0.44884198904037476),
(u&#39;gibbs&#39;, 0.445194810628891),
(u&#39;dos_santos&#39;, 0.44508373737335205),
(u&#39;gasol&#39;, 0.44387346506118774),
(u&#39;silva&#39;, 0.4424275755882263),
(u&#39;shaun&#39;, 0.44144102931022644)]
 4. Find which word doesn&amp;rsquo;t belong to a list? model.doesnt_match(&amp;#34;math shopping reading science&amp;#34;.split(&amp;#34; &amp;#34;)) I think staple doesn&amp;rsquo;t belong in this list!
Other Cool Things 1. Recommendations:   In this paper, the authors have shown that itembased CF can be cast in the same framework of word embedding.
2. Some other examples that people have seen after using their own embeddings: Library - Books = Hall
Obama &#43; Russia - USA = Putin
Iraq - Violence = Jordan
President - Power = Prime Minister (Not in India Though)
3.Seeing the above I started playing with it a little. Is this model sexist?
model.most_similar(positive = [&amp;#34;donald_trump&amp;#34;],negative = [&amp;#39;brain&amp;#39;]) [(u&#39;novak&#39;, 0.40405112504959106),
(u&#39;ozzie&#39;, 0.39440611004829407),
(u&#39;democrate&#39;, 0.39187556505203247),
(u&#39;clinton&#39;, 0.390536367893219),
(u&#39;hillary_clinton&#39;, 0.3862358033657074),
(u&#39;bnp&#39;, 0.38295692205429077),
(u&#39;klaar&#39;, 0.38228923082351685),
(u&#39;geithner&#39;, 0.380607008934021),
(u&#39;bafana_bafana&#39;, 0.3801495432853699),
(u&#39;whitman&#39;, 0.3790769875049591)]
 Whatever it is doing it surely feels like magic. Next time I will try to write more on how it works once I understand it fully.
]]>
        
      </content:encoded>
      
      
      
    </item>
    
  </channel>
</rss>