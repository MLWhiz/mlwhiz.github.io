<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:content="http://purl.org/rss/1.0/modules/content" xmlns:media="http://search.yahoo.com/mrss/" >

  
  <channel>
    <title>Big Data on MLWhiz</title>
    <link>https://mlwhiz.com/tags/big-data/</link>
    <description>Recent content in Big Data on MLWhiz</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 24 Jun 2020 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://mlwhiz.com/tags/big-data/atom.xml" rel="self" type="application/rss+xml" />
    

    

    <item>
      <title>Accelerating Spark 3.0 Google DataProc Project with NVIDIA GPUs in 6 simple steps</title>
      <link>https://mlwhiz.com/blog/2020/08/04/spark_dataproc/</link>
      <pubDate>Tue, 04 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2020/08/04/spark_dataproc/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/spark_dataproc/main.png"></media:content>
      

      
      <description>Data Exploration is a key part of Data Science. And does it take long? Ahh. Don’t even ask. Preparing a data set for ML not only requires understanding the data set, cleaning, and creating new features, it also involves doing these steps repeatedly until we have a fine-tuned system.
As we moved towards bigger datasets, Apache Spark came as a ray of hope. It gave us a scalable and distributed in-memory system to work with Big Data.</description>

      <content:encoded>  
        
        <![CDATA[  Data Exploration is a key part of Data Science. And does it take long? Ahh. Don’t even ask. Preparing a data set for ML not only requires understanding the data set, cleaning, and creating new features, it also involves doing these steps repeatedly until we have a fine-tuned system.
As we moved towards bigger datasets, Apache Spark came as a ray of hope. It gave us a scalable and distributed in-memory system to work with Big Data. By the by, we also saw frameworks like Pytorch and Tensorflow that inherently parallelized matrix computations using thousands of GPU cores.
But never did we see these two systems working in tandem in the past. We continued to use Spark for Big Data ETL tasks and GPUs for matrix intensive problems in Deep Learning.
And that is where Spark 3.0 comes. It provides us with a way to add NVIDIA GPUs to our Spark cluster nodes. The work done by these nodes can now be parallelized using both the CPU&#43;GPU using the software platform for GPU computing, RAPIDS.
 Spark &#43; GPU &#43; RAPIDS = Spark 3.0  As per NVIDIA, the early adopters of Spark 3.0 already see a significantly faster performance with their current data loads. Such reductions in processing times can allow Data Scientists to perform more iterations on much bigger datasets, allowing Retailers to improve their forecasting, finance companies to enhance their credit models, and ad tech firms to improve their ability to predict click-through rates.
Excited yet. So how can you start using Spark 3.0? Luckily, Google Cloud, Spark, and NVIDIA have come together and simplified the cluster creation process for us. With Dataproc on Google Cloud, we can have a fully-managed Apache Spark cluster with GPUs in a few minutes.
This post is about setting up your own Dataproc Spark Cluster with NVIDIA GPUs on Google Cloud.
1. Create a New GCP Project After the initial signup on the Google Cloud Platform, we can start a new project. Here I begin by creating a new project namedSparkDataProc.
Create a New Project
2. Enable the APIs in the GCP Project Once we add this project, we can go to our new project and start a Cloud Shell instance by clicking the “Activate Cloud Shell” button at the top right corner. Doing so will open up a terminal window at the bottom of our screen where we can run our next commands to set up a data proc cluster:
After this, we will need to run some commands to set up our project in the cloud shell. We start by enabling dataproc services within your project. Enable the Compute and Dataproc APIs to access Dataproc, and enable the Storage API as you’ll need a Google Cloud Storage bucket to house your data. We also set our default region. This may take several minutes:
gcloud services enable compute.googleapis.com gcloud services enable dataproc.googleapis.com gcloud services enable storage-api.googleapis.com gcloud config set dataproc/region us-central1  3. Create and Put some data in GCS Bucket Once done, we can create a new Google Cloud Storage Bucket, where we will keep all our data in the Cloud Shell:
#You might need to change this name as this needs to be unique across all the users export BUCKET_NAME=rahulsparktest #Create the Bucket gsutil mb gs://${BUCKET_NAME}  We can also put some data in the bucket for later run purposes when we are running our spark cluster.
# Get data in cloudshell terminal git clone https://github.com/caroljmcdonald/spark3-book mkdir -p ~/data/cal_housing tar -xzf spark3-book/data/cal_housing.tgz -C ~/data # Put data into Bucket using gsutil gsutil cp ~/data/CaliforniaHousing/cal_housing.data gs://${BUCKET_NAME}/data/cal_housing/cal_housing.csv  4. Setup the DataProc Rapids Cluster To create a DataProc RAPIDS cluster that uses NVIDIA T4 GPUs, we need to get some initialization scripts that are used to instantiate our cluster. These scripts will install the GPU drivers(install_gpu_driver.sh) and create the Rapids conda environment(rapids.sh) automatically for us. Since these scripts are in the development phase, the best way is to get the scripts from the GitHub source. We can do this using the below commands in our cloud shell in which we get the initialization scripts and copy them into our GS Bucket:
wget https://raw.githubusercontent.com/GoogleCloudDataproc/initialization-actions/master/rapids/rapids.sh wget https://raw.githubusercontent.com/GoogleCloudDataproc/initialization-actions/master/gpu/install_gpu_driver.sh gsutil cp rapids.sh gs://$BUCKET_NAME gsutil cp install_gpu_driver.sh gs://$BUCKET_NAME  We can now create our cluster using the below command in the Cloud Shell. In the below command, we are using a predefined image version(2.0.0-RC2-ubuntu18) which has Spark 3.0 and python 3.7 to create our dataproc cluster. I am using a previous version of this image since the newest version has some issues with running Jupyter and Jupyter Lab. You can get a list of all versions here.
CLUSTER_NAME=sparktestcluster REGION=us-central1 gcloud beta dataproc clusters create ${CLUSTER_NAME} \ --image-version 2.0.0-RC2-ubuntu18 \ --master-machine-type n1-standard-8 \ --worker-machine-type n1-highmem-32 \ --worker-accelerator type=nvidia-tesla-t4,count=2 \ --optional-components ANACONDA,JUPYTER,ZEPPELIN \ --initialization-actions gs://$BUCKET_NAME/install_gpu_driver.sh,gs://$BUCKET_NAME/rapids.sh \ --metadata rapids-runtime=SPARK \ --metadata gpu-driver-provider=NVIDIA \ --bucket ${BUCKET_NAME} \ --subnet default \ --enable-component-gateway \ --properties=&amp;quot;^#^spark:spark.task.resource.gpu.amount=0.125#spark:spark.executor. cores=8#spark:spark.task.cpus=1#spark:spark.yarn.unmanagedAM.enabled=false&amp;quot;  Our resulting Dataproc cluster has:
 One 8-core master node and two 32-core worker nodes
 Two NVIDIA T4 GPUs attached to each worker node
 Anaconda, Jupyter, and Zeppelin enabled
 Component gateway enabled for accessing Web UIs hosted on the cluster
 Extra Spark config tuning suitable for a notebook environment set using the properties flag. Specifically, we set spark.executor.cores=8 for improved parallelization and spark.yarn.unmanagedAM.enabled=false since it currently breaks SparkUI.
  Troubleshooting: If you get errors regarding limits after this command, you might want to change some of the quotas in your default Google Console Quotas Page. The limits I ended up changing were:
 GPUs (all regions) to 12 (Minimum:4)
 CPUs (all regions) to 164 (Minimum:72)
 NVIDIA T4 GPUs in us-central1 to 12 (Minimum:4)
 CPUs in us-central1 to 164 (Minimum:72)
  I actually requested more limits than I required as the limit increase process might take a little longer and I will spin up some larger clusters later.
5. Run JupyterLab on DataProc Rapids Cluster Once your command succeeds(It might take 10–15 mins) you will be able to see your Dataproc cluster at https://console.cloud.google.com/dataproc/clusters. Or you can go to the Google Cloud Platform console on your browser and search for “Dataproc” and click on the “Dataproc” icon(It looks like three connected circles). This will navigate you to the Dataproc clusters page.
Now, you would be able to open a web interface(Jupyter/JupyterLab/Zeppelin) if you click on the sparktestcluster and then “Web Interfaces”.
After opening up your Jupyter Pyspark Notebook, here is some example code for you to run if you are following along with this tutorial. In this code, we load a small dataset, and we see that the df.count() function ran in 252ms which is indeed fast for Spark, but I would do a much detailed benchmarking post later so keep tuned.
file = &amp;quot;gs://rahulsparktest/data/cal_housing/cal_housing.csv&amp;quot; df = spark.read.load(file,format=&amp;quot;csv&amp;quot;, sep=&amp;quot;,&amp;quot;, inferSchema=&amp;quot;true&amp;quot;, header=&amp;quot;false&amp;quot;) colnames = [&amp;quot;longitude&amp;quot;,&amp;quot;latitude&amp;quot;,&amp;quot;medage&amp;quot;,&amp;quot;totalrooms&amp;quot;,&amp;quot;totalbdrms&amp;quot;,&amp;quot;population&amp;quot;,&amp;quot;houshlds&amp;quot;,&amp;quot;medincome&amp;quot;,&amp;quot;medhvalue&amp;quot;] df = df.toDF(*colnames) df.count()  6. Access the Spark UI That is all well and done, but one major problem I faced was that I was not able to access the Spark UI using the link provided in the notebook. I found out that there were two ways to access the Spark UI for debugging purposes:
A. Using the Web Interface option:
We can access Spark UI by clicking first on Yarn Resource Manager Link on the Web Interface and then on Application Master on the corresponding page:
And, you will arrive at the Spark UI Page:
B. Using the SSH Tunneling option:
Another option to access the Spark UI is using Tunneling. To do this, you need to go to the Web Interface Page and click on “Create an SSH tunnel to connect to a web interface”.
This will give you two commands that you want to run on your local machine and not on Cloud shell. But before running them, you need to install google cloud SDK to your machine and set it up for your current project:
sudo snap install google-cloud-sdk --classic # This Below command will open the browser where you can authenticate by selecting your own google account. gcloud auth login # Set up the project as sparkdataproc (project ID) gcloud config set project sparkdataproc  Once done with this, we can simply run the first command:
gcloud compute ssh sparktestcluster-m --project=sparkdataproc --zone=us-central1-b -- -D 1080 -N  And then the second one in another tab/window. This command will open up a new chrome window where you can access the Spark UI by clicking on Application Master the same as before.
/usr/bin/google-chrome --proxy-server=&amp;quot;socks5://localhost:1080&amp;quot; --user-data-dir=&amp;quot;/tmp/sparktestcluster-m&amp;quot; [http://sparktestcluster-m:8088](http://sparktestcluster-m:8088)  And that is it for setting up a Spark3.0 Cluster accelerated by GPUs.
It took me around 30 mins to go through all these steps if I don’t count the debugging time and the quota increase requests.
I am totally amazed by the concept of using a GPU on Spark and the different streams of experiments it opens up. Will be working on a lot of these in the coming weeks not only to benchmark but also because it is fun. So stay tuned.
Continue Learning Also, if you want to learn more about Spark and Spark DataFrames, I would like to call out these excellent courses on Big Data Essentials: HDFS, MapReduce, and Spark RDD and Big Data Analysis: Hive, Spark SQL, DataFrames and GraphFrames by Yandex on Coursera.
I am going to be writing more of such posts in the future too. Let me know what you think about them. Follow me up at Medium or Subscribe to my blog.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>The Most Complete Guide to pySpark DataFrames</title>
      <link>https://mlwhiz.com/blog/2020/06/06/spark_df_complete_guide/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2020/06/06/spark_df_complete_guide/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/spark_df_complete_guide/main.png"></media:content>
      

      
      <description>Big Data has become synonymous with Data engineering. But the line between Data Engineering and Data scientists is blurring day by day. At this point in time, I think that Big Data must be in the repertoire of all data scientists.
Reason: Too much data is getting generated day by day
And that brings us to Spark which is one of the most used tools when it comes to working with Big Data.</description>

      <content:encoded>  
        
        <![CDATA[  Big Data has become synonymous with Data engineering. But the line between Data Engineering and Data scientists is blurring day by day. At this point in time, I think that Big Data must be in the repertoire of all data scientists.
Reason: Too much data is getting generated day by day
And that brings us to Spark which is one of the most used tools when it comes to working with Big Data.
While once upon a time Spark used to be heavily reliant on RDD manipulations, Spark has now provided a DataFrame API for us Data Scientists to work with. Here is the documentation for the adventurous folks. But while the documentation is good, it does not explain it from the perspective of a Data Scientist. Neither does it properly document the most common use cases for Data Science.
In this post, I will talk about installing Spark, standard Spark functionalities you will need to work with DataFrames, and finally some tips to handle the inevitable errors you will face.
This post is going to be quite long. Actually one of my longest posts on medium, so go on and pick up a Coffee.
Also here is the Table of Contents, if you want to skip to a specific section:
 Installation Data 1. Basic Functions  Read See a few rows in the file Change Column Names Select Columns Sort Cast Filter GroupBy Joins  2. Broadcast/Map Side Joins 3. Use SQL with DataFrames 4. Create New Columns  Using Spark Native Functions Using Spark UDFs Using RDDs Using Pandas UDF  5. Spark Window Functions  Ranking Lag Variables Rolling Aggregations  6. Pivot Dataframes 7. Unpivot/Stack Dataframes 8. Salting Some More Tips and Tricks  Caching Save and Load from an intermediate step Repartitioning Reading Parquet File in Local  Conclusion  Installation I am working on installing Spark on Ubuntu 18.04, but the steps should remain the same for MAC too. I am assuming that you already have Anaconda and Python3 installed. After that, you can just go through these steps:
 Download the Spark Binary from Apache Spark Website. And click on the Download Spark link to download Spark.  Once you have downloaded the above file, you can start with unzipping the file in your home directory. Just Open up the terminal and put these commands in.
cd ~ cp Downloads/spark-2.4.5-bin-hadoop2.7.tgz ~ tar -zxvf spark-2.4.5-bin-hadoop2.7.tgz  Check your Java Version. As of version 2.4 Spark works with Java 8. You can check your Java Version using the command java -version on the terminal window.
I had Java 11 in my machine, so I had to run the following commands on my terminal to install and change default Java to Java 8:
sudo apt install openjdk-8-jdk sudo update-alternatives --config java  You will need to manually select the Java version 8 by typing the selection number.
Rechecking Java version should give something like:
Edit your ~/.bashrc file and add the following lines at the end of the file:
function pysparknb () { #Spark path SPARK_PATH=~/spark-2.4.5-bin-hadoop2.7 export PYSPARK_DRIVER_PYTHON=&amp;quot;jupyter&amp;quot; export PYSPARK_DRIVER_PYTHON_OPTS=&amp;quot;notebook&amp;quot; # For pyarrow 0.15 users, you have to add the line below or you will get an error while using pandas_udf export ARROW_PRE_0_15_IPC_FORMAT=1 **# Change the local[10] to local[numCores in your machine]** $SPARK_PATH/bin/pyspark --master **local[10]** }  Source ~/.bashrc
source ~/.bashrc  Run the pysparknb function in the terminal and you will be able to access the notebook. You will be able to open a new notebook as well as the sparkcontext will be loaded automatically.
pysparknb  Data With the installation out of the way, we can move to the more interesting part of this post. I will be working with the Data Science for COVID-19 in South Korea, which is one of the most detailed datasets on the internet for COVID.
Please note that I will be using this dataset to showcase some of the most useful functionalities of Spark, but this should not be in any way considered a data exploration exercise for this amazing dataset.
I will mainly work with the following three tables only in this post:
 Cases
 Region
 TimeProvince
  You can find all the code at the GitHub repository.
1. Basic Functions Read We can start by loading the files in our dataset using the spark.read.load command. This command reads parquet files, which is the default file format for spark, but you can add the parameter format to read .csv files using it.
cases = spark.read.load(&amp;quot;/home/rahul/projects/sparkdf/coronavirusdataset/Case.csv&amp;quot;,format=&amp;quot;csv&amp;quot;, sep=&amp;quot;,&amp;quot;, inferSchema=&amp;quot;true&amp;quot;, header=&amp;quot;true&amp;quot;)  See a few rows in the file cases.show()  This file contains the cases grouped by way of the infection spread. This might have helped in the rigorous tracking of Corona Cases in South Korea.
The way this file looks is great right now, but sometimes as we increase the number of columns, the formatting becomes not too great. I have noticed that the following trick helps in displaying in pandas format in my Jupyter Notebook. The .toPandas() function converts a spark dataframe into a pandas Dataframe which is easier to show.
cases.limit(10).toPandas()  Change Column Names Sometimes we would like to change the name of columns in our Spark Dataframes. We can do this simply using the below command to change a single column:
cases = cases.withColumnRenamed(&amp;quot;infection_case&amp;quot;,&amp;quot;infection_source&amp;quot;)  Or for all columns:
cases = cases.toDF(*[&#39;case_id&#39;, &#39;province&#39;, &#39;city&#39;, &#39;group&#39;, &#39;infection_case&#39;, &#39;confirmed&#39;, &#39;latitude&#39;, &#39;longitude&#39;])  Select Columns We can select a subset of columns using the select keyword.
cases = cases.select(&#39;province&#39;,&#39;city&#39;,&#39;infection_case&#39;,&#39;confirmed&#39;) cases.show()  Sort We can sort by the number of confirmed cases. Here note that the cases data frame will not change after performing this command as we don’t assign it to any variable.
cases.sort(&amp;quot;confirmed&amp;quot;).show()  But that is inverted. We want to see the most cases at the top. We can do this using the F.desc function:
# descending Sort from pyspark.sql import functions as F cases.sort(F.desc(&amp;quot;confirmed&amp;quot;)).show()  We can see the most cases in a logical area in South Korea originated from Shincheonji Church.
Cast Though we don’t face it in this dataset, there might be scenarios where Pyspark reads a double as integer or string, In such cases, you can use the cast function to convert types.
from pyspark.sql.types import DoubleType, IntegerType, StringType cases = cases.withColumn(&#39;confirmed&#39;, F.col(&#39;confirmed&#39;).cast(IntegerType())) cases = cases.withColumn(&#39;city&#39;, F.col(&#39;city&#39;).cast(StringType()))  Filter We can filter a data frame using multiple conditions using AND(&amp;amp;), OR(|) and NOT(~) conditions. For example, we may want to find out all the different infection_case in Daegu Province with more than 10 confirmed cases.
cases.filter((cases.confirmed&amp;gt;10) &amp;amp; (cases.province==&#39;Daegu&#39;)).show()  GroupBy We can use groupBy function with a spark DataFrame too. Pretty much same as the pandas groupBy with the exception that you will need to import pyspark.sql.functions. Here is the list of functions you can use with this function module.
from pyspark.sql import functions as F cases.groupBy([&amp;quot;province&amp;quot;,&amp;quot;city&amp;quot;]).agg(F.sum(&amp;quot;confirmed&amp;quot;) ,F.max(&amp;quot;confirmed&amp;quot;)).show()  If you don’t like the new column names, you can use the alias keyword to rename columns in the agg command itself.
cases.groupBy([&amp;quot;province&amp;quot;,&amp;quot;city&amp;quot;]).agg( F.sum(&amp;quot;confirmed&amp;quot;).alias(&amp;quot;TotalConfirmed&amp;quot;),\ F.max(&amp;quot;confirmed&amp;quot;).alias(&amp;quot;MaxFromOneConfirmedCase&amp;quot;)\ ).show()  Joins To Start with Joins we will need to introduce one more CSV file. We will go with the region file which contains region information such as elementary_school_count, elderly_population_ratio, etc.
regions = spark.read.load(&amp;quot;/home/rahul/projects/sparkdf/coronavirusdataset/Region.csv&amp;quot;,format=&amp;quot;csv&amp;quot;, sep=&amp;quot;,&amp;quot;, inferSchema=&amp;quot;true&amp;quot;, header=&amp;quot;true&amp;quot;) regions.limit(10).toPandas()  We want to get this information in our cases file by joining the two DataFrames. We can do this by using:
cases = cases.join(regions, [&#39;province&#39;,&#39;city&#39;],how=&#39;left&#39;) cases.limit(10).toPandas()  2. Broadcast/Map Side Joins Sometimes you might face a scenario where you need to join a very big table(~1B Rows) with a very small table(~100–200 rows). The scenario might also involve increasing the size of your database like in the example below.
Such sort of operations is aplenty in Spark where you might want to apply multiple operations to a particular key. But assuming that the data for each key in the Big table is large, it will involve a lot of data movement. And sometimes so much that the application itself breaks. A small optimization then you can do when joining on such big tables(assuming the other table is small) is to broadcast the small table to each machine/node when you perform a join. You can do this easily using the broadcast keyword. This has been a lifesaver many times with Spark when everything else fails.
from pyspark.sql.functions import broadcast cases = cases.join(broadcast(regions), [&#39;province&#39;,&#39;city&#39;],how=&#39;left&#39;)  3. Use SQL with DataFrames If you want, you can also use SQL with data frames. Let us try to run some SQL on the cases table.
We first register the cases dataframe to a temporary table cases_table on which we can run SQL operations. As you can see, the result of the SQL select statement is again a Spark Dataframe.
cases.registerTempTable(&#39;cases_table&#39;) newDF = sqlContext.sql(&#39;select * from cases_table where confirmed&amp;gt;100&#39;) newDF.show()  I have shown a minimal example above, but you can use pretty much complex SQL queries involving GROUP BY, HAVING, AND ORDER BY clauses as well as aliases in the above query.
4. Create New Columns There are many ways that you can use to create a column in a PySpark Dataframe. I will try to show the most usable of them.
Using Spark Native Functions The most pysparkish way to create a new column in a PySpark DataFrame is by using built-in functions. This is the most performant programmatical way to create a new column, so this is the first place I go whenever I want to do some column manipulation.
We can use .withcolumn along with PySpark SQL functions to create a new column. In essence, you can find String functions, Date functions, and Math functions already implemented using Spark functions. Our first function, the F.col function gives us access to the column. So if we wanted to add 100 to a column, we could use F.col as:
import pyspark.sql.functions as F casesWithNewConfirmed = cases.withColumn(&amp;quot;NewConfirmed&amp;quot;, 100 &#43; F.col(&amp;quot;confirmed&amp;quot;)) casesWithNewConfirmed.show()  We can also use math functions like F.exp function:
casesWithExpConfirmed = cases.withColumn(&amp;quot;ExpConfirmed&amp;quot;, F.exp(&amp;quot;confirmed&amp;quot;)) casesWithExpConfirmed.show()  There are a lot of other functions provided in this module, which are enough for most simple use cases. You can check out the functions list here.
Using Spark UDFs Sometimes we want to do complicated things to a column or multiple columns. This could be thought of as a map operation on a PySpark Dataframe to a single column or multiple columns. While Spark SQL functions do solve many use cases when it comes to column creation, I use Spark UDF whenever I need more matured Python functionality.
To use Spark UDFs, we need to use the F.udf function to convert a regular python function to a Spark UDF. We also need to specify the return type of the function. In this example the return type is StringType()
import pyspark.sql.functions as F from pyspark.sql.types import * def casesHighLow(confirmed): if confirmed &amp;lt; 50: return &#39;low&#39; else: return &#39;high&#39; #convert to a UDF Function by passing in the function and return type of function casesHighLowUDF = F.udf(casesHighLow, StringType()) CasesWithHighLow = cases.withColumn(&amp;quot;HighLow&amp;quot;, casesHighLowUDF(&amp;quot;confirmed&amp;quot;)) CasesWithHighLow.show()  Using RDDs This might seem a little odd, but sometimes both the spark UDFs and SQL functions are not enough for a particular use-case. I have observed the RDDs being much more performant in some use-cases in real life. You might want to utilize the better partitioning that you get with spark RDDs. Or you may want to use group functions in Spark RDDs.
Whatever the case be, I find this way of using RDD to create new columns pretty useful for people who have experience working with RDDs that is the basic building block in the Spark ecosystem. Don’t worry much if you don’t understand it. It is just here for completion.
The process below makes use of the functionality to convert between Row and pythondict objects. We convert a row object to a dictionary. Work with the dictionary as we are used to and convert that dictionary back to row again. This might come in handy in a lot of situations.
import math from pyspark.sql import Row def rowwise_function(row): # convert row to python dictionary: row_dict = row.asDict() # Add a new key in the dictionary with the new column name and value. # This might be a big complex function. row_dict[&#39;expConfirmed&#39;] = float(np.exp(row_dict[&#39;confirmed&#39;])) # convert dict to row back again: newrow = Row(**row_dict) # return new row return newrow # convert cases dataframe to RDD cases_rdd = cases.rdd # apply our function to RDD cases_rdd_new = cases_rdd.map(lambda row: rowwise_function(row)) # Convert RDD Back to DataFrame casesNewDf = sqlContext.createDataFrame(cases_rdd_new) casesNewDf.show()  Using Pandas UDF This functionality was introduced in the Spark version 2.3.1. And this allows you to use pandas functionality with Spark. I generally use it when I have to run a groupBy operation on a Spark dataframe or whenever I need to create rolling features and want to use Pandas rolling functions/window functions rather than Spark window functions which we will go through later in this post.
The way we use it is by using the F.pandas_udf decorator. We assume here that the input to the function will be a pandas data frame. And we need to return a pandas dataframe in turn from this function.
The only complexity here is that we have to provide a schema for the output Dataframe. We can use the original schema of a dataframe to create the outSchema.
cases.printSchema()  Here I am using Pandas UDF to get normalized confirmed cases grouped by infection_case. The main advantage here is that I get to work with pandas dataframes in Spark.
from pyspark.sql.types import IntegerType, StringType, DoubleType, BooleanType from pyspark.sql.types import StructType, StructField # Declare the schema for the output of our function outSchema = StructType([StructField(&#39;case_id&#39;,IntegerType(),True), StructField(&#39;province&#39;,StringType(),True), StructField(&#39;city&#39;,StringType(),True), StructField(&#39;group&#39;,BooleanType(),True), StructField(&#39;infection_case&#39;,StringType(),True), StructField(&#39;confirmed&#39;,IntegerType(),True), StructField(&#39;latitude&#39;,StringType(),True), StructField(&#39;longitude&#39;,StringType(),True), StructField(&#39;normalized_confirmed&#39;,DoubleType(),True) ]) # decorate our function with pandas_udf decorator @F.pandas_udf(outSchema, F.PandasUDFType.GROUPED_MAP) def subtract_mean(pdf): # pdf is a pandas.DataFrame v = pdf.confirmed v = v - v.mean() pdf[&#39;normalized_confirmed&#39;] = v return pdf confirmed_groupwise_normalization = cases.groupby(&amp;quot;infection_case&amp;quot;).apply(subtract_mean) confirmed_groupwise_normalization.limit(10).toPandas()  5. Spark Window Functions Window functions may make a whole blog post in itself. Here I will talk about some of the most important window functions available in spark.
For this, I will also use one more data CSV, which has dates present as that will help with understanding Window functions much better. I will use the TimeProvince dataframe which contains daily case information for each province.
Ranking You can get rank as well as dense_rank on a group using this function. For example, you may want to have a column in your cases table that provides the rank of infection_case based on the number of infection_case in a province. We can do this by:
from pyspark.sql.window import Window windowSpec = Window().partitionBy([&#39;province&#39;]).orderBy(F.desc(&#39;confirmed&#39;)) cases.withColumn(&amp;quot;rank&amp;quot;,F.rank().over(windowSpec)).show()  Lag Variables Sometimes our data science models may need lag based features. For example, a model might have variables like the price last week or sales quantity the previous day. We can create such features using the lag function with window functions. Here I am trying to get the confirmed cases 7 days before. I am filtering to show the results as the first few days of corona cases were zeros. You can see here that the lag_7 day feature is shifted by 7 days.
from pyspark.sql.window import Window windowSpec = Window().partitionBy([&#39;province&#39;]).orderBy(&#39;date&#39;) timeprovinceWithLag = timeprovince.withColumn(&amp;quot;lag_7&amp;quot;,F.lag(&amp;quot;confirmed&amp;quot;, 7).over(windowSpec)) timeprovinceWithLag.filter(timeprovinceWithLag.date&amp;gt;&#39;2020-03-10&#39;).show()  Rolling Aggregations Sometimes it helps to provide rolling averages to our models. For example, we might want to have a rolling 7-day sales sum/mean as a feature for our sales regression model. Let us calculate the rolling mean of confirmed cases for the last 7 days here. This is what a lot of the people are already doing with this dataset to see the real trends.
from pyspark.sql.window import Window windowSpec = Window().partitionBy([&#39;province&#39;]).orderBy(&#39;date&#39;).rowsBetween(-6,0) timeprovinceWithRoll = timeprovince.withColumn(&amp;quot;roll_7_confirmed&amp;quot;,F.mean(&amp;quot;confirmed&amp;quot;).over(windowSpec)) timeprovinceWithRoll.filter(timeprovinceWithLag.date&amp;gt;&#39;2020-03-10&#39;).show()  There are a few things here to understand. First is the rowsBetween(-6,0) function that we are using here. This function has a form of rowsBetween(start,end) with both start and end inclusive. Using this we only look at the past 7 days in a particular window including the current_day. Here 0 specifies the current_row and -6 specifies the seventh row previous to current_row. Remember we count starting from 0.
So to get roll_7_confirmed for date 2020–03–22 we look at the confirmed cases for dates 2020–03–22 to 2020–03–16 and take their mean.
If we had used rowsBetween(-7,-1) we would just have looked at past 7 days of data and not the current_day.
One could also find a use for rowsBetween(Window.unboundedPreceding, Window.currentRow) where we take the rows between the first row in a window and the current_row to get running totals. I am calculating cumulative_confirmed here.
from pyspark.sql.window import Window windowSpec = Window().partitionBy([&#39;province&#39;]).orderBy(&#39;date&#39;).rowsBetween(Window.unboundedPreceding,Window.currentRow) timeprovinceWithRoll = timeprovince.withColumn(&amp;quot;cumulative_confirmed&amp;quot;,F.sum(&amp;quot;confirmed&amp;quot;).over(windowSpec)) timeprovinceWithRoll.filter(timeprovinceWithLag.date&amp;gt;&#39;2020-03-10&#39;).show()  6. Pivot Dataframes Sometimes we may need to have the dataframe in flat format. This happens frequently in movie data where we may want to show genres as columns instead of rows. We can use pivot to do this. Here I am trying to get one row for each date and getting the province names as columns.
pivotedTimeprovince = timeprovince.groupBy(&#39;date&#39;).pivot(&#39;province&#39;).agg(F.sum(&#39;confirmed&#39;).alias(&#39;confirmed&#39;) , F.sum(&#39;released&#39;).alias(&#39;released&#39;)) pivotedTimeprovince.limit(10).toPandas()  One thing to note here is that we need to provide an aggregation always with the pivot function even if the data has a single row for a date.
7. Unpivot/Stack Dataframes This is just the opposite of the pivot. Given a pivoted dataframe like above, can we go back to the original?
Yes, we can. But the way is not that straightforward. For one we will need to replace - with _ in the column names as it interferes with what we are about to do. We can simply rename the columns:
newColnames = [x.replace(&amp;quot;-&amp;quot;,&amp;quot;_&amp;quot;) for x in pivotedTimeprovince.columns] pivotedTimeprovince = pivotedTimeprovince.toDF(*newColnames)  Now we will need to create an expression which looks like the below:
&amp;quot;stack(34, &#39;Busan_confirmed&#39; , Busan_confirmed,&#39;Busan_released&#39; , Busan_released,&#39;Chungcheongbuk_do_confirmed&#39; , . . . &#39;Seoul_released&#39; , Seoul_released,&#39;Ulsan_confirmed&#39; , Ulsan_confirmed,&#39;Ulsan_released&#39; , Ulsan_released) as (Type,Value)&amp;quot;  The general format is as follows:
&amp;quot;stack(&amp;lt;cnt of columns you want to put in one column&amp;gt;, &#39;firstcolname&#39;, firstcolname , &#39;secondcolname&#39; ,secondcolname ......) as (Type, Value)&amp;quot;  It may seem daunting, but we can create such an expression using our programming skills.
expression = &amp;quot;&amp;quot; cnt=0 for column in pivotedTimeprovince.columns: if column!=&#39;date&#39;: cnt &#43;=1 expression &#43;= f&amp;quot;&#39;{column}&#39; , {column},&amp;quot; expression = f&amp;quot;stack({cnt}, {expression[:-1]}) as (Type,Value)&amp;quot;  And we can unpivot using:
unpivotedTimeprovince = pivotedTimeprovince.select(&#39;date&#39;,F.expr(exprs))  And voila! we have got our dataframe in a vertical format. There are quite a few column creations, filters, and join operations needed to get exactly the same format as before, but I will not get into those.
8. Salting Sometimes it might happen that a lot of data goes to a single executor since the same key is assigned for a lot of rows in our data. Salting is another way that helps you to manage data skewness.
So assuming we want to do the sum operation when we have skewed keys. We can start by creating the Salted Key and then doing a double aggregation on that key as the sum of a sum still equals sum. To understand this assume we need the sum of confirmed infection_cases on the cases table and assume that the key infection_cases is skewed. We can do the required operation in two steps.
1. Create a Salting Key
We first create a salting key using a concatenation of infection_case column and a random_number between 0 to 9. In case your key is even more skewed, you can split it in even more than 10 parts.
cases = cases.withColumn(&amp;quot;salt_key&amp;quot;, F.concat(F.col(&amp;quot;infection_case&amp;quot;), F.lit(&amp;quot;_&amp;quot;), F.monotonically_increasing_id() % 10))  This is how the table looks after the operation:
2. First Groupby on salt key
cases_temp = cases.groupBy([&amp;quot;infection_case&amp;quot;,&amp;quot;salt_key&amp;quot;]).agg(F.sum(&amp;quot;confirmed&amp;quot;)).show()  3. Second Group On the original Key
Here we saw how the sum of sum can be used to get the final sum. You can also make use of facts like:
 min of min is min
 max of max is max
 sum of count is count
  You can think about ways in which salting as an idea could be applied to joins too.
Some More Tips and Tricks Caching Spark works on the lazy execution principle. What that means is that nothing really gets executed until you use an action function like the .count() on a dataframe. And if you do a .count function, it generally helps to cache at this step. So I have made it a point to cache() my dataframes whenever I do a .count() operation.
df.cache().count()  Save and Load from an intermediate step df.write.parquet(&amp;quot;data/df.parquet&amp;quot;) df.unpersist() spark.read.load(&amp;quot;data/df.parquet&amp;quot;)  When you work with Spark you will frequently run with memory and storage issues. While in some cases such issues might be resolved using techniques like broadcasting, salting or cache, sometimes just interrupting the workflow and saving and reloading the whole dataframe at a crucial step has helped me a lot. This helps spark to let go of a lot of memory that gets utilized for storing intermediate shuffle data and unused caches.
Repartitioning You might want to repartition your data if you feel your data has been skewed while working with all the transformations and joins. The simplest way to do it is by using:
df = df.repartition(1000)  Sometimes you might also want to repartition by a known scheme as this scheme might be used by a certain join or aggregation operation later on. You can use multiple columns to repartition using:
df = df.repartition(&#39;cola&#39;, &#39;colb&#39;,&#39;colc&#39;,&#39;cold&#39;)  You can get the number of partitions in a data frame using:
df.rdd.getNumPartitions()  You can also check out the distribution of records in a partition by using the glom function. This helps in understanding the skew in the data that happens while working with various transformations.
df.glom().map(len).collect()  Reading Parquet File in Local Sometimes you might want to read the parquet files in a system where Spark is not available. In such cases, I normally use the below code:
from glob import glob def load_df_from_parquet(parquet_directory): df = pd.DataFrame() for file in glob(f&amp;quot;{parquet_directory}/*&amp;quot;): df = pd.concat([df,pd.read_parquet(file)]) return df  Conclusion This was a big post and congratulations on you reaching the end. These are the most common functionalities I end up using in my day to day job.
Hopefully, I’ve covered the Dataframe basics well enough to pique your interest and help you get started with Spark. If you want to learn more about how Spark Started or RDD basics take a look at this post
You can find all the code at this GitHub repository where I keep code for all my posts.
Continue Learning Also, if you want to learn more about Spark and Spark DataFrames, I would like to call out these excellent courses on Big Data Essentials: HDFS, MapReduce and Spark RDD and Big Data Analysis: Hive, Spark SQL, DataFrames and GraphFrames by Yandex on Coursera.
I am going to be writing more of such posts in the future too. Let me know what you think about the series. Follow me up at Medium or Subscribe to my blog.
Also, a small disclaimer — There might be some affiliate links in this post to relevant resources, as sharing knowledge is never a bad idea.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Practical Spark Tips for Data Scientists</title>
      <link>https://mlwhiz.com/blog/2020/03/20/practicalspark/</link>
      <pubDate>Fri, 20 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2020/03/20/practicalspark/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/practicalspark/main.png"></media:content>
      

      
      <description>I know — Spark is sometimes frustrating to work with.
Although sometimes we can manage our big data using tools like Rapids or Parallelization, there is no way around using Spark if you are working with Terabytes of data.
In my last few posts on Spark, I explained how to work with PySpark RDDs and Dataframes. Although these posts explain a lot on how to work with RDDs and Dataframe operations, they still are not quite enough.</description>

      <content:encoded>  
        
        <![CDATA[  I know — Spark is sometimes frustrating to work with.
Although sometimes we can manage our big data using tools like Rapids or Parallelization, there is no way around using Spark if you are working with Terabytes of data.
In my last few posts on Spark, I explained how to work with PySpark RDDs and Dataframes. Although these posts explain a lot on how to work with RDDs and Dataframe operations, they still are not quite enough.
Why? Because Spark gives memory errors a lot of times, and it is only when you genuinely work on big datasets with spark, would you be able to truly work with Spark.
This post is going to be about — “Practical Spark and memory management tips for Data Scientists.”
1. Map Side Joins The syntax of joins in Spark is pretty similar to pandas:
df3 = df1.join(df2, df1.column == df2.column,how=&#39;left&#39;)  But I faced a problem. The df1 had around 1Billion rows while df2 had around 100 Rows. When I tried the above join, it didn’t work and failed with memory exhausted errors after running for 20 minutes.
I was writing this code on a pretty big cluster with more than 400 executors with each executor having more than 4GB RAM. I was stumped as I tried to repartition my data frames using multiple schemes, but nothing seemed to work.
So what should I do? Is Spark not able to work with a mere billion rows? Not Really. I just needed to use Map-side joins or broadcasting in Spark terminology.
from pyspark.sql.functions import broadcast df3 = df1.join(broadcast(df2), df1.column == df2.column,how=&#39;left&#39;)  Using the simple broadcasting code above, I was able to send the smaller df2 to all the nodes, and this didn’t take a lot of time or memory. What happens in the backend is that a copy of df2 is sent to all the partitions and each partition uses that copy to do the join. That means that there is no data movement when it comes to df1, which is a lot bigger than df2.
2. Spark Cluster Configurations Set the Parallelism and worker nodes based on your task size
What also made my life difficult while I was starting work with Spark was the way the Spark cluster needs to be configured. Your spark cluster might need a lot of custom configuration ad tuning based on the job you want to run.
Some of the most important configurations and options are as follows:
a. spark.sql.shuffle.partitions and spark.default.parallelism: spark.sql.shuffle.partitions configures the number of partitions to use when shuffling data for joins or aggregations. The spark.default.parallelism is the default number of partitions in RDDs returned by transformations like join, reduceByKey, and parallelize when not set by the user. The default value for these is 200.
In simple words, these set the degree of parallelism you want to have in your cluster.
If you don’t have a lot of data, the value of 200 is fine, but if you have huge data, you might want to increase these numbers. It also depends on the number of executors you have. My cluster was pretty big with 400 executors, so I kept this at 1200. A rule of thumb is to keep it as a multiple of the number of executors so that each executor ends up with multiple jobs.
sqlContext.setConf( &amp;quot;spark.sql.shuffle.partitions&amp;quot;, 800) sqlContext.setConf( &amp;quot;spark.default.parallelism&amp;quot;, 800)  b. spark.sql.parquet.binaryAsString I was working with .parquet files in Spark, and most of my data columns were strings. But somehow whenever I loaded the data in Spark, the string columns got converted into binary format on which I was not able to use any string manipulation functions. The way I solved this was by using:
sqlContext.setConf(&amp;quot;spark.sql.parquet.binaryAsString&amp;quot;,&amp;quot;true&amp;quot;)  The above configuration converts the binary format to string while loading parquet files. Now it is a default configuration I set whenever I work with Spark.
c. Yarn Configurations: There are other configurations that you might need to tune that define your cluster. But these need to be set up when the cluster is starting and are not as dynamic as the above ones. The few I want to put down here are for managing memory spills on the executor nodes. Sometimes the executor core gets a lot of work.
 spark.yarn.executor.memoryOverhead: 8192
 yarn.nodemanager.vmem-check-enabled: False
  There are a lot of configurations that you might want to tune while setting up your spark cluster. You can take a look at them in the official docs.
3. Repartitioning Keeping the workers happy by having them handle an equal amount of data
You might want to repartition your data if you feel your data has been skewed while working with all the transformations and joins. The simplest way to do it is by using:
df = df.repartition(1000)  Sometimes you might also want to repartition by a known scheme as this scheme might be used by a certain join or aggregation operation later on. You can use multiple columns to repartition using:
df = df.repartition(&#39;cola&#39;, &#39;colb&#39;,&#39;colc&#39;,&#39;cold&#39;)  You can get the number of partitions in a data frame using:
df.rdd.getNumPartitions()  You can also check out the distribution of records in a partition by using the glom function. This helps in understanding the skew in the data that happens while working with various transformations.
df.glom().map(len).collect()  Conclusion There are a lot of things we don’t know, we don’t know. These are called unknown unknowns. It is only by multiple code failures and reading up on multiple stack overflow threads that we understand what we need.
Here I have tried to summarize a few of the problems that I faced around memory issues and configurations while working with Spark and how to solve them. There are a lot of other configuration options in Spark, which I have not covered, but I hope this post gave you some clarity on how to set these and use them.
Now, if you need to learn Spark basics, take a look at my previous post: The Hitchhikers guide to handle Big Data using Spark *Not just an Introduction*towardsdatascience.com
Also, if you want to learn more about Spark and Spark DataFrames, I would like to call out these excellent courses on Big Data Essentials: HDFS, MapReduce and Spark RDD and Big Data Analysis: Hive, Spark SQL, DataFrames and GraphFrames by Yandex on Coursera.
Thanks for the read. I am going to be writing more beginner-friendly posts in the future too. Follow me up at Medium or Subscribe to my blog
Also, a small disclaimer — There might be some affiliate links in this post to relevant resources, as sharing knowledge is never a bad idea.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>5 Ways to add a new column in a PySpark Dataframe</title>
      <link>https://mlwhiz.com/blog/2020/02/24/sparkcolumns/</link>
      <pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2020/02/24/sparkcolumns/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/sparkcolumns/main.png"></media:content>
      

      
      <description>Too much data is getting generated day by day.
Although sometimes we can manage our big data using tools like Rapids or Parallelization, Spark is an excellent tool to have in your repertoire if you are working with Terabytes of data.
In my last post on Spark, I explained how to work with PySpark RDDs and Dataframes.
Although this post explains a lot on how to work with RDDs and basic Dataframe operations, I missed quite a lot when it comes to working with PySpark Dataframes.</description>

      <content:encoded>  
        
        <![CDATA[  Too much data is getting generated day by day.
Although sometimes we can manage our big data using tools like Rapids or Parallelization, Spark is an excellent tool to have in your repertoire if you are working with Terabytes of data.
In my last post on Spark, I explained how to work with PySpark RDDs and Dataframes.
Although this post explains a lot on how to work with RDDs and basic Dataframe operations, I missed quite a lot when it comes to working with PySpark Dataframes.
And it is only when I required more functionality that I read up and came up with multiple solutions to do one single thing.
How to create a new column in spark?
Now, this might sound trivial, but believe me, it isn’t. With so much you might want to do with your data, I am pretty sure you will end up using most of these column creation processes in your workflow. Sometimes to utilize Pandas functionality, or occasionally to use RDDs based partitioning or sometimes to make use of the mature python ecosystem.
This post is going to be about — “Multiple ways to create a new column in Pyspark Dataframe.”
If you have PySpark installed, you can skip the Getting Started section below.
Getting Started with Spark I know that a lot of you won’t have spark installed in your system to try and learn. But installing Spark is a headache of its own.
Since we want to understand how it works and work with it, I would suggest that you use Spark on Databricks here online with the community edition. Don’t worry, it is free, albeit fewer resources, but that works for us right now for learning purposes.
Once you register and login will be presented with the following screen.
You can start a new notebook here.
Select the Python notebook and give any name to your notebook.
Once you start a new notebook and try to execute any command, the notebook will ask you if you want to start a new cluster. Do it.
The next step will be to check if the sparkcontext is present. To check if the sparkcontext is present, you have to run this command:
sc  This means that we are set up with a notebook where we can run Spark.
Data Here, I will work on the Movielens ml-100k.zip dataset. 100,000 ratings from 1000 users on 1700 movies. In this zipped folder, the file we will specifically work with is the rating file. This filename is kept as “u.data”
If you want to upload this data or any data, you can click on the Data tab in the left and then Add Data by using the GUI provided.
We can then load the data using the following commands:
ratings = spark.read.load(&amp;quot;/FileStore/tables/u.data&amp;quot;,format=&amp;quot;csv&amp;quot;, sep=&amp;quot;\t&amp;quot;, inferSchema=&amp;quot;true&amp;quot;, header=&amp;quot;false&amp;quot;) ratings = ratings.toDF(*[&#39;user_id&#39;, &#39;movie_id&#39;, &#39;rating&#39;, &#39;unix_timestamp&#39;])  Here is how it looks:
ratings.show()  Ok, so now we are set up to begin the part we are interested in finally. How to create a new column in PySpark Dataframe?
1. Using Spark Native Functions The most pysparkish way to create a new column in a PySpark DataFrame is by using built-in functions. This is the most performant programmatical way to create a new column, so this is the first place I go whenever I want to do some column manipulation.
We can use .withcolumn along with PySpark SQL functions to create a new column. In essence, you can find String functions, Date functions, and Math functions already implemented using Spark functions. We can import spark functions as:
import pyspark.sql.functions as F  Our first function, the F.col function gives us access to the column. So if we wanted to multiply a column by 2, we could use F.col as:
ratings_with_scale10 = ratings.withColumn(&amp;quot;ScaledRating&amp;quot;, 2*F.col(&amp;quot;rating&amp;quot;)) ratings_with_scale10.show()  We can also use math functions like F.exp function:
ratings_with_exp = ratings.withColumn(&amp;quot;expRating&amp;quot;, 2*F.exp(&amp;quot;rating&amp;quot;)) ratings_with_exp.show()  There are a lot of other functions provided in this module, which are enough for most simple use cases. You can check out the functions list here.
2. Spark UDFs Sometimes we want to do complicated things to a column or multiple columns. This could be thought of as a map operation on a PySpark Dataframe to a single column or multiple columns. While Spark SQL functions do solve many use cases when it comes to column creation, I use Spark UDF whenever I want to use the more matured Python functionality.
To use Spark UDFs, we need to use the F.udf function to convert a regular python function to a Spark UDF. We also need to specify the return type of the function. In this example the return type is StringType()
import pyspark.sql.functions as F from pyspark.sql.types import * def somefunc(value): if value &amp;lt; 3: return &#39;low&#39; else: return &#39;high&#39; #convert to a UDF Function by passing in the function and return type of function udfsomefunc = F.udf(somefunc, StringType()) ratings_with_high_low = ratings.withColumn(&amp;quot;high_low&amp;quot;, udfsomefunc(&amp;quot;rating&amp;quot;)) ratings_with_high_low.show()  3. Using RDDs Sometimes both the spark UDFs and SQL Functions are not enough for a particular use-case. You might want to utilize the better partitioning that you get with spark RDDs. Or you may want to use group functions in Spark RDDs. You can use this one, mainly when you need access to all the columns in the spark data frame inside a python function.
Whatever the case be, I find this way of using RDD to create new columns pretty useful for people who have experience working with RDDs that is the basic building block in the Spark ecosystem.
The process below makes use of the functionality to convert between Row and pythondict objects. We convert a row object to a dictionary. Work with the dictionary as we are used to and convert that dictionary back to row again.
import math from pyspark.sql import Row def rowwise_function(row): # convert row to dict: row_dict = row.asDict() # Add a new key in the dictionary with the new column name and value. row_dict[&#39;Newcol&#39;] = math.exp(row_dict[&#39;rating&#39;]) # convert dict to row: newrow = Row(**row_dict) # return new row return newrow # convert ratings dataframe to RDD ratings_rdd = ratings.rdd # apply our function to RDD ratings_rdd_new = ratings_rdd.map(lambda row: rowwise_function(row)) # Convert RDD Back to DataFrame ratings_new_df = sqlContext.createDataFrame(ratings_rdd_new) ratings_new_df.show()  4. Pandas UDF This functionality was introduced in the Spark version 2.3.1. And this allows you to use pandas functionality with Spark. I generally use it when I have to run a groupby operation on a Spark dataframe or whenever I need to create rolling features and want to use Pandas rolling functions/window functions.
The way we use it is by using the F.pandas_udf decorator. We assume here that the input to the function will be a pandas data frame. And we need to return a pandas dataframe in turn from this function.
The only complexity here is that we have to provide a schema for the output Dataframe. We can make that using the format below.
# Declare the schema for the output of our function outSchema = StructType([StructField(&#39;user_id&#39;,IntegerType(),True),StructField(&#39;movie_id&#39;,IntegerType(),True),StructField(&#39;rating&#39;,IntegerType(),True),StructField(&#39;unix_timestamp&#39;,IntegerType(),True),StructField(&#39;normalized_rating&#39;,DoubleType(),True)]) # decorate our function with pandas_udf decorator [@F](http://twitter.com/F).pandas_udf(outSchema, F.PandasUDFType.GROUPED_MAP) def subtract_mean(pdf): # pdf is a pandas.DataFrame v = pdf.rating v = v - v.mean() pdf[&#39;normalized_rating&#39;] =v return pdf rating_groupwise_normalization = ratings.groupby(&amp;quot;movie_id&amp;quot;).apply(subtract_mean) rating_groupwise_normalization.show()  We can also make use of this to train multiple individual models on each spark node. For that, we replicate our data and give each replication a key and some training params like max_depth, etc. Our function then takes the pandas Dataframe, runs the required model, and returns the result. The structure would look something like below.
# 0. Declare the schema for the output of our function outSchema = StructType([StructField(&#39;replication_id&#39;,IntegerType(),True),StructField(&#39;RMSE&#39;,DoubleType(),True)]) # decorate our function with pandas_udf decorator [@F](http://twitter.com/F).pandas_udf(outSchema, F.PandasUDFType.GROUPED_MAP) def run_model(pdf): # 1. Get hyperparam values num_trees = pdf.num_trees.values[0] depth = pdf.depth.values[0] replication_id = pdf.replication_id.values[0] # 2. Train test split Xtrain,Xcv,ytrain,ycv = train_test_split..... # 3. Create model using the pandas dataframe clf = RandomForestRegressor(max_depth = depth, num_trees=num_trees,....) clf.fit(Xtrain,ytrain) # 4. Evaluate the model rmse = RMSE(clf.predict(Xcv,ycv) # 5. return results as pandas DF res =pd.DataFrame({&#39;replication_id&#39;:replication_id,&#39;RMSE&#39;:rmse}) return res results = replicated_data.groupby(&amp;quot;replication_id&amp;quot;).apply(run_model)  Above is just an idea and not a working code. Though it should work with minor modifications.
5. Using SQL For people who like SQL, there is a way even to create columns using SQL. For this, we need to register a temporary SQL table and then use simple select queries with an additional column. One might also use it to do joins.
ratings.registerTempTable(&#39;ratings_table&#39;) newDF = sqlContext.sql(&#39;select *, 2*rating as newCol from ratings_table&#39;) newDF.show()  Conclusion And that is the end of this column(pun intended)
Hopefully, I’ve covered the column creation process well to help you with your Spark problems. If you need to learn more of spark basics, take a look at:
The Hitchhikers guide to handle Big Data using Spark
You can find all the code for this post at the GitHub repository or the published notebook on databricks.
Also, if you want to learn more about Spark and Spark DataFrames, I would like to call out an excellent course on Big Data Essentials, which is part of the Big Data Specialization provided by Yandex.
Thanks for the read. I am going to be writing more beginner-friendly posts in the future too. Follow me up at Medium or Subscribe to my blog
Also, a small disclaimer — There might be some affiliate links in this post to relevant resources, as sharing knowledge is never a bad idea.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>100x faster Hyperparameter Search Framework with Pyspark</title>
      <link>https://mlwhiz.com/blog/2020/02/22/hyperspark/</link>
      <pubDate>Sat, 22 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2020/02/22/hyperspark/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/hyperspark/main.png"></media:content>
      

      
      <description>Recently I was working on tuning hyperparameters for a huge Machine Learning model.
Manual tuning was not an option since I had to tweak a lot of parameters. Hyperopt was also not an option as it works serially i.e. at a time, only a single model is being built. So it was taking up a lot of time to train each model and I was pretty short on time.</description>

      <content:encoded>  
        
        <![CDATA[  Recently I was working on tuning hyperparameters for a huge Machine Learning model.
Manual tuning was not an option since I had to tweak a lot of parameters. Hyperopt was also not an option as it works serially i.e. at a time, only a single model is being built. So it was taking up a lot of time to train each model and I was pretty short on time.
I had to come up with a better more efficient approach if I were to meet the deadline. So I thought of the one thing that helps us data scientists in many such scenarios — Parallelization.
Can I parallelize my model hyperparameter search process?
As you would have guessed, the answer is Yes.
This post is about setting up a hyperparameter tuning framework for Data Science using scikit-learn/xgboost/lightgbm and pySpark.
Grid vs Randomized? Before we get to implementing the hyperparameter search, we have two options to set up the hyperparameter search — Grid Search or Random search.
Starting with a 3×3 grid of parameters, we can see that Random search ends up doing more searches for the important parameter.
The figure above gives a definitive answer as to why Random search is better.
Let’s say we have to tune two hyperparameters for our Machine Learning model. One is not important, and one is very important. In a grid search, we look at three settings for the important parameter. While in a randomized search, we search through 9 settings for the important parameter. And the amount of time we spent is the same.
Since, Randomized search, searches more thoroughly through the whole space and provides us with better hyperparameters, we will go with it in our example.
Setting Up Our Example At my workplace, I have access to a pretty darn big cluster with 100s of nodes. It is a data Scientist’s dream. But in this post, I am going to be using the Databricks Community Edition Free server with a toy example. If you want to set up this small server for yourself for practice, check out my post on Spark.
You can choose to load your data using Spark, but here I start by creating our own classification data to set up a minimal example which we can work with.
X,y = datasets.make_classification(n_samples=10000, n_features=4, n_informative=2, n_classes=2, random_state=1,shuffle=True) train = pd.DataFrame(X) train[&#39;target&#39;] = y # Convert this pandas Data to spark Dataframe. train_sp = spark.createDataFrame(train) # Change the column names. train_sp = train_sp.toDF(*[&#39;c0&#39;, &#39;c1&#39;, &#39;c2&#39;, &#39;c3&#39;, &#39;target&#39;])  The train_sp spark dataset looks like:
The Idea — Replicate and Apply Photo by Frank Vessia on Unsplash
So now we have got our training dataset in Spark. And we want to run multiple models on this DataFrame.
Spark is inherently good with Key-Value pairs. That is all data with a particular key could be sent to a single machine. And we can apply functions to that data.
But we want all our data on every machine. How do we do that?
We replicate our data n times and add a replication_id to our data so that each key has all the data.
Ok, now we can send the whole data to multiple machines using groupby on replication_id. But how do we use pandas and scikit learn on that data?
The answer is: we use pandas_udf. This functionality was introduced in the Spark version 2.3.1. And this allows you to utilise pandas functionality with Spark.
If you don’t understand this yet, do look at the code as sometimes it is easier to understand the code.
The Code We first replicate our train dataframe 100 times here by using cross_join with a data frame that contains a column with 1–100 replication_id.
# replicate the spark dataframe into multiple copies replication_df = spark.createDataFrame(pd.DataFrame(list(range(1,100)),columns=[&#39;replication_id&#39;])) replicated_train_df = train_sp.crossJoin(replication_df)  We also define a function that takes as input a pandas dataframe, gets random hyperparameters using the python random module, runs a model on data(Here I am training a scikit model, but you can replace it with any model like XGBoost or Lightgbm as well) and returns the result in the form of a Pandas Dataframe. Do take a look at the function and the comments.
# 0. Declare the schema for the output of our function outSchema = StructType([StructField(&amp;#39;replication_id&amp;#39;,IntegerType(),True),StructField(&amp;#39;Accuracy&amp;#39;,DoubleType(),True),StructField(&amp;#39;num_trees&amp;#39;,IntegerType(),True),StructField(&amp;#39;depth&amp;#39;,IntegerType(),True),StructField(&amp;#39;criterion&amp;#39;,StringType(),True)]) # decorate our function with pandas_udf decorator @F.pandas_udf(outSchema, F.PandasUDFType.GROUPED_MAP) def run_model(pdf): # 1. Get randomized hyperparam values num_trees = random.choice(list(range(50,500))) depth = random.choice(list(range(2,10))) criterion = random.choice([&amp;#39;gini&amp;#39;,&amp;#39;entropy&amp;#39;]) replication_id = pdf.replication_id.values[0] # 2. Train test split X = pdf[[&amp;#39;c0&amp;#39;, &amp;#39;c1&amp;#39;, &amp;#39;c2&amp;#39;, &amp;#39;c3&amp;#39;]] y = pdf[&amp;#39;target&amp;#39;] Xtrain,Xcv,ytrain,ycv = train_test_split(X, y, test_size=0.33, random_state=42) # 3. Create model using the pandas dataframe clf = RandomForestClassifier(n_estimators=num_trees, max_depth = depth, criterion =criterion) clf.fit(Xtrain,ytrain) # 4. Evaluate the model accuracy = accuracy_score(clf.predict(Xcv),ycv) # 5. return results as pandas DF res =pd.DataFrame({&amp;#39;replication_id&amp;#39;:replication_id,&amp;#39;Accuracy&amp;#39;:accuracy, &amp;#39;num_trees&amp;#39;:num_trees,&amp;#39;depth&amp;#39;:depth,&amp;#39;criterion&amp;#39;:criterion}, index=[0]) return res We can now apply this pandas_udf function to our replicated dataframe using:
results = replicated_train_df.groupby(&amp;quot;replication_id&amp;quot;).apply(run_model)  What the above code does is that it sends all the data with the same replication id to a single machine and applies the function run_model to the data. The above call happens lazily so you won’t be able to see the results till you run the below action call.
results.sort(F.desc(&amp;quot;Accuracy&amp;quot;)).show()  For this toy example, the accuracy results may look pretty close to one another, but they will differ in the case of noisy real-world datasets. Since all of these 100 models run in parallel on different nodes, we can save a lot of time when doing random hyperparameter search.
The speedup factor certainly depends on how many nodes you have in your cluster. For me, I had 100 machines at my disposal, so I got ~ 100x speedup.
You can get the full code in this Databricks Notebook or get it from my GitHub repository where I keep codes for all my posts.
Continue Learning If you want to learn more about practical data science, do take a look at the “How to win a data science competition” Coursera course. I learned a lot of new things from this course taught by one of the most prolific Kaggler.
Thanks for the read. I am going to be writing more beginner-friendly posts in the future too. Follow me up at Medium or Subscribe to my blog.
Also, a small disclaimer — There might be some affiliate links in this post to relevant resources as sharing knowledge is never a bad idea.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Data Scientists, The 5 Graph Algorithms that you should know</title>
      <link>https://mlwhiz.com/blog/2019/09/02/graph_algs/</link>
      <pubDate>Mon, 02 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2019/09/02/graph_algs/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/graphs/1.png"></media:content>
      

      
      <description>We as data scientists have gotten quite comfortable with Pandas or SQL or any other relational database.
We are used to seeing our users in rows with their attributes as columns. But does the real world really behave like that?
In a connected world, users cannot be considered as independent entities. They have got certain relationships between each other and we would sometimes like to include such relationships while building our machine learning models.</description>

      <content:encoded>  
        
        <![CDATA[  We as data scientists have gotten quite comfortable with Pandas or SQL or any other relational database.
We are used to seeing our users in rows with their attributes as columns. But does the real world really behave like that?
In a connected world, users cannot be considered as independent entities. They have got certain relationships between each other and we would sometimes like to include such relationships while building our machine learning models.
Now while in a relational database, we cannot use such relations between different rows(users), in a graph database it is fairly trivial to do that.
In this post, I am going to be talking about some of the most important graph algorithms you should know and how to implement them using Python.
Also, here is a Graph Analytics for Big Data course on Coursera by UCSanDiego which I highly recommend to learn the basics of graph theory.
1. Connected Components We all know how clustering works?
You can think of Connected Components in very layman’s terms as a sort of a hard clustering algorithm which finds clusters/islands in related/connected data.
As a concrete example: Say you have data about roads joining any two cities in the world. And you need to find out all the continents in the world and which city they contain.*
How will you achieve that? Come on give some thought.
The connected components algorithm that we use to do this is based on a special case of BFS/DFS. I won’t talk much about how it works here, but we will see how to get the code up and running using Networkx.
Applications From a Retail Perspective: Let us say, we have a lot of customers using a lot of accounts. One way in which we can use the Connected components algorithm is to find out distinct families in our dataset.
We can assume edges(roads) between CustomerIDs based on same credit card usage, or same address or same mobile number, etc. Once we have those connections, we can then run the connected component algorithm on the same to create individual clusters to which we can then assign a family ID.
We can then use these family IDs to provide personalized recommendations based on family needs. We can also use this family ID to fuel our classification algorithms by creating grouped features based on family.
From a Finance Perspective: Another use case would be to capture fraud using these family IDs. If an account has done fraud in the past, it is highly probable that the connected accounts are also susceptible to fraud.
The possibilities are only limited by your own imagination.
Code We will be using the Networkx module in Python for creating and analyzing our graphs.
Let us start with an example graph which we are using for our purpose. Contains cities and distance information between them.
We first start by creating a list of edges along with the distances which we will add as the weight of the edge:
edgelist = [[&amp;#39;Mannheim&amp;#39;, &amp;#39;Frankfurt&amp;#39;, 85], [&amp;#39;Mannheim&amp;#39;, &amp;#39;Karlsruhe&amp;#39;, 80], [&amp;#39;Erfurt&amp;#39;, &amp;#39;Wurzburg&amp;#39;, 186], [&amp;#39;Munchen&amp;#39;, &amp;#39;Numberg&amp;#39;, 167], [&amp;#39;Munchen&amp;#39;, &amp;#39;Augsburg&amp;#39;, 84], [&amp;#39;Munchen&amp;#39;, &amp;#39;Kassel&amp;#39;, 502], [&amp;#39;Numberg&amp;#39;, &amp;#39;Stuttgart&amp;#39;, 183], [&amp;#39;Numberg&amp;#39;, &amp;#39;Wurzburg&amp;#39;, 103], [&amp;#39;Numberg&amp;#39;, &amp;#39;Munchen&amp;#39;, 167], [&amp;#39;Stuttgart&amp;#39;, &amp;#39;Numberg&amp;#39;, 183], [&amp;#39;Augsburg&amp;#39;, &amp;#39;Munchen&amp;#39;, 84], [&amp;#39;Augsburg&amp;#39;, &amp;#39;Karlsruhe&amp;#39;, 250], [&amp;#39;Kassel&amp;#39;, &amp;#39;Munchen&amp;#39;, 502], [&amp;#39;Kassel&amp;#39;, &amp;#39;Frankfurt&amp;#39;, 173], [&amp;#39;Frankfurt&amp;#39;, &amp;#39;Mannheim&amp;#39;, 85], [&amp;#39;Frankfurt&amp;#39;, &amp;#39;Wurzburg&amp;#39;, 217], [&amp;#39;Frankfurt&amp;#39;, &amp;#39;Kassel&amp;#39;, 173], [&amp;#39;Wurzburg&amp;#39;, &amp;#39;Numberg&amp;#39;, 103], [&amp;#39;Wurzburg&amp;#39;, &amp;#39;Erfurt&amp;#39;, 186], [&amp;#39;Wurzburg&amp;#39;, &amp;#39;Frankfurt&amp;#39;, 217], [&amp;#39;Karlsruhe&amp;#39;, &amp;#39;Mannheim&amp;#39;, 80], [&amp;#39;Karlsruhe&amp;#39;, &amp;#39;Augsburg&amp;#39;, 250],[&amp;#34;Mumbai&amp;#34;, &amp;#34;Delhi&amp;#34;,400],[&amp;#34;Delhi&amp;#34;, &amp;#34;Kolkata&amp;#34;,500],[&amp;#34;Kolkata&amp;#34;, &amp;#34;Bangalore&amp;#34;,600],[&amp;#34;TX&amp;#34;, &amp;#34;NY&amp;#34;,1200],[&amp;#34;ALB&amp;#34;, &amp;#34;NY&amp;#34;,800]] Let us create a graph using Networkx:
g = nx.Graph() for edge in edgelist: g.add_edge(edge[0],edge[1], weight = edge[2]) Now we want to find out distinct continents and their cities from this graph.
We can now do this using the connected components algorithm as:
for i, x in enumerate(nx.connected_components(g)): print(&amp;#34;cc&amp;#34;&#43;str(i)&#43;&amp;#34;:&amp;#34;,x) cc0: {&#39;Frankfurt&#39;, &#39;Kassel&#39;, &#39;Munchen&#39;, &#39;Numberg&#39;, &#39;Erfurt&#39;, &#39;Stuttgart&#39;, &#39;Karlsruhe&#39;, &#39;Wurzburg&#39;, &#39;Mannheim&#39;, &#39;Augsburg&#39;} cc1: {&#39;Kolkata&#39;, &#39;Bangalore&#39;, &#39;Mumbai&#39;, &#39;Delhi&#39;} cc2: {&#39;ALB&#39;, &#39;NY&#39;, &#39;TX&#39;}  As you can see we are able to find distinct components in our data. Just by using Edges and Vertices. This algorithm could be run on different data to satisfy any use case that I presented above.
2. Shortest Path Continuing with the above example only, we are given a graph with the cities of Germany and the respective distance between them.
You want to find out how to go from Frankfurt (The starting node) to Munchen by covering the shortest distance.
The algorithm that we use for this problem is called Dijkstra. In Dijkstra’s own words:
 What is the shortest way to travel from Rotterdam to Groningen, in general: from given city to given city. It is the algorithm for the shortest path, which I designed in about twenty minutes. One morning I was shopping in Amsterdam with my young fiancée, and tired, we sat down on the café terrace to drink a cup of coffee and I was just thinking about whether I could do this, and I then designed the algorithm for the shortest path. As I said, it was a twenty-minute invention. In fact, it was published in ’59, three years later. The publication is still readable, it is, in fact, quite nice. One of the reasons that it is so nice was that I designed it without pencil and paper. I learned later that one of the advantages of designing without pencil and paper is that you are almost forced to avoid all avoidable complexities. Eventually that algorithm became, to my great amazement, one of the cornerstones of my fame. — Edsger Dijkstra, in an interview with Philip L. Frana, Communications of the ACM, 2001[3]
 Applications  Variations of the Dijkstra algorithm is used extensively in Google Maps to find the shortest routes.
 You are in a Walmart Store. You have different Aisles and distance between all the aisles. You want to provide the shortest pathway to the customer from Aisle A to Aisle D.
   You have seen how LinkedIn shows up 1st-degree connections, 2nd-degree connections. What goes on behind the scenes?  Code print(nx.shortest_path(g, &amp;#39;Stuttgart&amp;#39;,&amp;#39;Frankfurt&amp;#39;,weight=&amp;#39;weight&amp;#39;)) print(nx.shortest_path_length(g, &amp;#39;Stuttgart&amp;#39;,&amp;#39;Frankfurt&amp;#39;,weight=&amp;#39;weight&amp;#39;)) [&#39;Stuttgart&#39;, &#39;Numberg&#39;, &#39;Wurzburg&#39;, &#39;Frankfurt&#39;] 503  You can also find Shortest paths between all pairs using:
for x in nx.all_pairs_dijkstra_path(g,weight=&amp;#39;weight&amp;#39;): print(x) (&#39;Mannheim&#39;, {&#39;Mannheim&#39;: [&#39;Mannheim&#39;], &#39;Frankfurt&#39;: [&#39;Mannheim&#39;, &#39;Frankfurt&#39;], &#39;Karlsruhe&#39;: [&#39;Mannheim&#39;, &#39;Karlsruhe&#39;], &#39;Augsburg&#39;: [&#39;Mannheim&#39;, &#39;Karlsruhe&#39;, &#39;Augsburg&#39;], &#39;Kassel&#39;: [&#39;Mannheim&#39;, &#39;Frankfurt&#39;, &#39;Kassel&#39;], &#39;Wurzburg&#39;: [&#39;Mannheim&#39;, &#39;Frankfurt&#39;, &#39;Wurzburg&#39;], &#39;Munchen&#39;: [&#39;Mannheim&#39;, &#39;Karlsruhe&#39;, &#39;Augsburg&#39;, &#39;Munchen&#39;], &#39;Erfurt&#39;: [&#39;Mannheim&#39;, &#39;Frankfurt&#39;, &#39;Wurzburg&#39;, &#39;Erfurt&#39;], &#39;Numberg&#39;: [&#39;Mannheim&#39;, &#39;Frankfurt&#39;, &#39;Wurzburg&#39;, &#39;Numberg&#39;], &#39;Stuttgart&#39;: [&#39;Mannheim&#39;, &#39;Frankfurt&#39;, &#39;Wurzburg&#39;, &#39;Numberg&#39;, &#39;Stuttgart&#39;]}) (&#39;Frankfurt&#39;, {&#39;Frankfurt&#39;: [&#39;Frankfurt&#39;], &#39;Mannheim&#39;: [&#39;Frankfurt&#39;, &#39;Mannheim&#39;], &#39;Kassel&#39;: [&#39;Frankfurt&#39;, &#39;Kassel&#39;], &#39;Wurzburg&#39;: [&#39;Frankfurt&#39;, &#39;Wurzburg&#39;], &#39;Karlsruhe&#39;: [&#39;Frankfurt&#39;, &#39;Mannheim&#39;, &#39;Karlsruhe&#39;], &#39;Augsburg&#39;: [&#39;Frankfurt&#39;, &#39;Mannheim&#39;, &#39;Karlsruhe&#39;, &#39;Augsburg&#39;], &#39;Munchen&#39;: [&#39;Frankfurt&#39;, &#39;Wurzburg&#39;, &#39;Numberg&#39;, &#39;Munchen&#39;], &#39;Erfurt&#39;: [&#39;Frankfurt&#39;, &#39;Wurzburg&#39;, &#39;Erfurt&#39;], &#39;Numberg&#39;: [&#39;Frankfurt&#39;, &#39;Wurzburg&#39;, &#39;Numberg&#39;], &#39;Stuttgart&#39;: [&#39;Frankfurt&#39;, &#39;Wurzburg&#39;, &#39;Numberg&#39;, &#39;Stuttgart&#39;]}) ....  3. Minimum Spanning Tree Now we have another problem. We work for a water pipe laying company or an internet fiber company. We need to connect all the cities in the graph we have using the minimum amount of wire/pipe. How do we do this?
Applications  Minimum spanning trees have direct applications in the design of networks, including computer networks, telecommunications networks, transportation networks, water supply networks, and electrical grids (which they were first invented for)
 MST is used for approximating the traveling salesman problem
 Clustering — First construct MST and then determine a threshold value for breaking some edges in the MST using Intercluster distances and Intracluster distances.
 Image Segmentation — It was used for Image segmentation where we first construct an MST on a graph where pixels are nodes and distances between pixels are based on some similarity measure(color, intensity, etc.)
  Code # nx.minimum_spanning_tree(g) returns a instance of type graph nx.draw_networkx(nx.minimum_spanning_tree(g)) As you can see the above is the wire we gotta lay.
4. Pagerank This is the page sorting algorithm that powered google for a long time. It assigns scores to pages based on the number and quality of incoming and outgoing links.
Applications Pagerank can be used anywhere where we want to estimate node importance in any network.
 It has been used for finding the most influential papers using citations.
 Has been used by Google to rank pages
 It can be used to rank tweets- User and Tweets as nodes. Create Link between user if user A follows user B and Link between user and Tweets if user tweets/retweets a tweet.
 Recommendation engines
  Code For this exercise, we are going to be using Facebook data. We have a file of edges/links between facebook users. We first create the FB graph using:
# reading the dataset fb = nx.read_edgelist(&amp;#39;../input/facebook-combined.txt&amp;#39;, create_using = nx.Graph(), nodetype = int) This is how it looks:
pos = nx.spring_layout(fb) import warnings warnings.filterwarnings(&amp;#39;ignore&amp;#39;) plt.style.use(&amp;#39;fivethirtyeight&amp;#39;) plt.rcParams[&amp;#39;figure.figsize&amp;#39;] = (20, 15) plt.axis(&amp;#39;off&amp;#39;) nx.draw_networkx(fb, pos, with_labels = False, node_size = 35) plt.show() Now we want to find the users having high influence capability.
Intuitively, the Pagerank algorithm will give a higher score to a user who has a lot of friends who in turn have a lot of FB Friends.
pageranks = nx.pagerank(fb) print(pageranks) {0: 0.006289602618466542, 1: 0.00023590202311540972, 2: 0.00020310565091694562, 3: 0.00022552359869430617, 4: 0.00023849264701222462, ........}  We can get the sorted PageRank or most influential users using:
import operator sorted_pagerank = sorted(pagerank.items(), key=operator.itemgetter(1),reverse = True) print(sorted_pagerank) [(3437, 0.007614586844749603), (107, 0.006936420955866114), (1684, 0.0063671621383068295), (0, 0.006289602618466542), (1912, 0.0038769716008844974), (348, 0.0023480969727805783), (686, 0.0022193592598000193), (3980, 0.002170323579009993), (414, 0.0018002990470702262), (698, 0.0013171153138368807), (483, 0.0012974283300616082), (3830, 0.0011844348977671688), (376, 0.0009014073664792464), (2047, 0.000841029154597401), (56, 0.0008039024292749443), (25, 0.000800412660519768), (828, 0.0007886905420662135), (322, 0.0007867992190291396),......]  The above IDs are for the most influential users.
We can see the subgraph for the most influential user:
first_degree_connected_nodes = list(fb.neighbors(3437)) second_degree_connected_nodes = [] for x in first_degree_connected_nodes: second_degree_connected_nodes&#43;=list(fb.neighbors(x)) second_degree_connected_nodes.remove(3437) second_degree_connected_nodes = list(set(second_degree_connected_nodes)) subgraph_3437 = nx.subgraph(fb,first_degree_connected_nodes&#43;second_degree_connected_nodes) pos = nx.spring_layout(subgraph_3437) node_color = [&amp;#39;yellow&amp;#39; if v == 3437 else &amp;#39;red&amp;#39; for v in subgraph_3437] node_size = [1000 if v == 3437 else 35 for v in subgraph_3437] plt.style.use(&amp;#39;fivethirtyeight&amp;#39;) plt.rcParams[&amp;#39;figure.figsize&amp;#39;] = (20, 15) plt.axis(&amp;#39;off&amp;#39;) nx.draw_networkx(subgraph_3437, pos, with_labels = False, node_color=node_color,node_size=node_size ) plt.show() 5. Centrality Measures There are a lot of centrality measures which you can use as features to your machine learning models. I will talk about two of them. You can look at other measures here.
Betweenness Centrality: It is not only the users who have the most friends that are important, the users who connect one geography to another are also important as that lets users see content from diverse geographies. Betweenness centrality quantifies how many times a particular node comes in the shortest chosen path between two other nodes.
Degree Centrality: It is simply the number of connections for a node.
Applications Centrality measures can be used as a feature in any machine learning model.
Code Here is the code for finding the Betweenness centrality for the subgraph.
pos = nx.spring_layout(subgraph_3437) betweennessCentrality = **nx.betweenness_centrality(**subgraph_3437**,normalized=True, endpoints=True)** node_size = [v * 10000 for v in betweennessCentrality.values()] plt.figure(figsize=(20,20)) nx.draw_networkx(subgraph_3437, pos=pos, with_labels=False, node_size=node_size ) plt.axis(&amp;#39;off&amp;#39;) You can see the nodes sized by their betweenness centrality values here. They can be thought of as information passers. Breaking any of the nodes with a high betweenness Centrality will break the graph into many parts.
Conclusion In this post, I talked about some of the most influential graph algorithms that have changed the way we live.
With the advent of so much social data, network analysis could help a lot in improving our models and generating value.
And even understanding a little more about the world.
There are a lot of graph algorithms out there, but these are the ones I like the most. Do look into the algorithms in more detail if you like. In this post, I just wanted to get the required breadth into the area.
Let me know if you feel I have left your favorite algorithm in the comments.
Here is the Kaggle Kernel with the whole code.
If you want to read up more on Graph Algorithms here is a Graph Analytics for Big Data course on Coursera by UCSanDiego which I highly recommend to learn the basics of graph theory.
Thanks for the read. I am going to be writing more beginner-friendly posts in the future too. Follow me up at Medium or Subscribe to my blog.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>How did I learn Data Science?</title>
      <link>https://mlwhiz.com/blog/2019/08/12/resources/</link>
      <pubDate>Mon, 12 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2019/08/12/resources/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/resources/1.png"></media:content>
      

      
      <description>I am a Mechanical engineer by education. And I started my career with a core job in the steel industry.
But I didn’t like it and so I left that.
I made it my goal to move into the analytics and data science space somewhere around in 2013. From then on, it has taken me a lot of failures and a lot of efforts to shift.
Now, people on social networks ask me how I got started in the data science field.</description>

      <content:encoded>  
        
        <![CDATA[  I am a Mechanical engineer by education. And I started my career with a core job in the steel industry.
But I didn’t like it and so I left that.
I made it my goal to move into the analytics and data science space somewhere around in 2013. From then on, it has taken me a lot of failures and a lot of efforts to shift.
Now, people on social networks ask me how I got started in the data science field. So I thought of giving a definitive answer.
 It is not really impossible to do this but it will take a lot of time and effort. Fortunately, I had an ample supply of both.
 Given below is the way that I took, and any aspiring person could choose to become a self-trained data scientist.
Some of the courses are not the same I did since some of them don’t exist and some have been merged into bigger specializations. But I have tried to keep it as similar to my experience as possible.
Also, I hope that you don’t lose hope after seeing the long list. You have to start with one or two courses. The rest will follow with time. Remember we have ample time.
Follow in order. I have tried to include everything that comes to my mind, including some post links which I think could be beneficial.
Introduction to Probability and Statistics Stat 110: The quintessential Probability and Statistics course you gotta take. All the lectures and notes are available on Youtube and his site for free.
If not for the content then for Prof. Joseph Blitzstein sense of humor. The above picture is a testament to that.
I took this course to enhance my understanding of probability distributions and statistics, but this course taught me a lot more than that.
Apart from Learning to think conditionally, this also taught me how to explain difficult concepts with a story.
This is a challenging class for a beginner but most definitely fun. The focus was not only on getting Mathematical proofs but also on understanding the intuition behind them and how intuition can help in deriving the proofs quickly. Sometimes the same proof was done in different ways to facilitate the learning of a concept.
One of the things I liked most about this course is the focus on concrete examples while explaining abstract concepts.
The inclusion of Gambler’s Ruin Problem, Matching Problem, Birthday Problem, Monty Hall, Simpsons Paradox, St. Petersberg Paradox, etc. made this course much much more exciting and enjoyable than any ordinary Statistics Course.
It will help you understand Discrete (Bernoulli, Binomial, Hypergeometric, Geometric, Negative Binomial, FS, Poisson) and Continuous (Uniform, Normal, expo, Beta, Gamma) Distributions.
He has also got a textbook based on this course, which is an excellent text and a must for any bookshelf.
 
Introduction to Python and Data Science:  Do first, understand later
 We need to get a taste of machine learning before understanding it fully. This segment is made up of three parts. These are not the exact courses I took to learn Python and getting an intro to data science. But they are quite similar and they serve the purpose.
a) Introduction to Data Science in Python This course is about learning to use Python and creating things on your own. You will learn about Python Libraries like Numpy, Pandas for data science.
You might also like my posts on Minimal Pandas for Data Scientists and small shorts on advanced python while going through this course.
Course description from Website:
 This course will introduce the learner to the basics of the python programming environment, including fundamental python programming techniques such as lambdas, reading and manipulating csv files, and the numpy library. The course will introduce data manipulation and cleaning techniques using the popular python pandas data science library and introduce the abstraction of the Series and DataFrame as the central data structures for data analysis, along with tutorials on how to use functions such as groupby, merge, and pivot tables effectively. By the end of this course, students will be able to take tabular data, clean it, manipulate it, and run basic inferential statistical analyses.
 b) Applied Machine Learning in Python This course gives an intro to many modern machine learning methods that you should know about. Not a thorough grinding but you will get the tools to build your own models. You will learn scikit-learn, which is the python library to create all sorts of models.
The focus here is to start creating things as soon as possible. No one likes to wait too long to get something useful, and you will become useful after this course.
 This course will introduce the learner to applied machine learning, focusing more on the techniques and methods than on the statistics behind these methods. The course will start with a discussion of how machine learning is different than descriptive statistics, and introduce the scikit learn toolkit through a tutorial.
 c) Visualizations  A well made visualization is worth more than any PPT
 One thing you also need to learn about is Visualizations. This is an area which is constantly evolving with a lot of new libraries coming frequently. The libraries I use most are Seaborn and Plotly.
You could take a look at the below posts to get started with both basic and advanced visualizations.
Python’s One-Liner graph creation library with animations Hans Rosling Style
3 Awesome Visualization Techniques for every dataset
Machine Learning Fundamentals After doing these above courses, you will gain the status of what I would like to call a “Beginner.”
Congrats!!!. You know stuff; you know how to implement things.
Yet you do not fully understand all the math and grind that goes behind all these models.
You need to understand what goes behind the clf.fit
 If you don’t understand it you won’t be able to improve it
 Here comes the Game Changer Machine Learning course. Contains the maths behind many of the Machine Learning algorithms.
I will put this course as the one course you gotta take as this course motivated me into getting in this field, and Andrew Ng is a great instructor. Also, this was the first course that I took myself when I started.
This course has a little of everything — Regression, Classification, Anomaly Detection, Recommender systems, Neural networks, plus a lot of great advice.
After this one, you are done with the three musketeers of the trade.
You know Python, you understand Statistics, and you have gotten the taste of the math behind ML approaches. Now it is time for the new kid on the block. D’artagnan. This kid has skills. While the three musketeers are masters in their trade, this guy brings qualities that add a new freshness to our data science journey.
Here comes Big Data for you.
Big Data Analytics Using Spark  Big Data is omnipresent. Deal with it.
 The whole big data ecosystem has changed a lot since the time I learned Hadoop. And Spark was the new kid on the block at that time. Those days…
The courses I took are pretty redundant as of now so I would try to recommend something suitable for this era. The best course I could find that embodies most of what I learned through scattered sources is Big Data Analytics Using Spark.
From the course website, after doing this course, you will learn:
 Programming Spark using Pyspark Identifying the computational tradeoffs in a Spark application Performing data loading and cleaning using Spark and Parquet Modeling data through statistical and machine learning methods  You could also take a look at my recent post on Spark.
The Hitchhikers guide to handle Big Data using Spark
Understand Linux Shell Not a hard requirement but a good to have skill. Shell is a big friend of data scientists. It allows you to do simple data-related tasks in the terminal itself. I couldn’t emphasize how much time shell saves for me every day.
You can read the below post by me to know about this: Impress Onlookers with your newly acquired Shell Skills
If you would like to take a course, you can look at The UNIX workbench course on Coursera.
Congrats you are a “Hacker” now.
 You have got all the main tools in your belt to be a data scientist.
 On to more advanced topics. From here, it depends on you what you want to learn.
You may want to take a totally different approach than what I took going from here. There is no particular order. “All Roads Lead to Rome” as long as you are moving.
Learn Statistical Inference Mine Çetinkaya-Rundel teaches this course on Inferential Statistics. And it cannot get simpler than this one.
She is a great instructor and explains the fundamentals of Statistical inference nicely — a must-take course.
You will learn about hypothesis testing, confidence intervals, and statistical inference methods for numerical and categorical data.
Deep Learning  It is all about layers
 Intro — Making neural nets uncool again. This is a code-first class for neural nets. An excellent Deep learning class from Kaggle Master Jeremy Howard. Entertaining and enlightening at the same time.
Advanced — You can try out this Deep Learning Specialization by Andrew Ng again. Pure Gold.
Advanced Math Book — A math-intensive book by Yoshua Bengio &amp;amp; Ian Goodfellow
Take a look at below post if you want to learn Pytorch.
Moving from Keras to Pytorch
Learn NLP, Use Deep Learning with Text and create Chatbots  Reading is overrated. Let the machine do it.
 Natural Language Processing is something which captured my attention a while back.
I wrote a series of 6 posts on it. If you want, you can take a look.
NLP Learning Series — Towards Data Science
Algorithms, Graph Algorithms, and More  Algorithms. Yes, you need them.
 Apart from that if you want to learn about Python and the underlying intricacies of the language you can take the Computer Science Mini Specialization from RICE university too.
This is a series of 6 short but good courses.
I worked on these courses as Data science will require you to do a lot of programming. And the best way to learn to program is by doing it.
The lectures are good, but the problems and assignments are awesome. If you work on this, you will learn Object-Oriented Programming, Graph algorithms, and creating games in Python. Pretty cool stuff.
You could also take a look at:
The 5 Feature Selection Algorithms every Data Scientist should know
The 5 Sampling Algorithms every Data Scientist need to know
Some Advanced Math Topics  Math — The power behind it all
 I am writing it last here but don’t underestimate the importance of Math in Data Science. You might want to look a little into these courses if you want to refresh your concepts.
Linear Algebra By Gilbert Strang— A Great Class by a great Teacher. I would definitely recommend this class to anyone who wants to learn Linear Algebra.
Multivariate Calculus — MIT Open Courseware
Convex Optimization — a MOOC on optimization from Stanford, by Steven Boyd, an authority on the subject.
Conclusion The Machine learning field is evolving, and new advancements are made every day. That’s why I didn’t put the third tier.
 The maximum I can call myself is a “Hacker,” and my learning continues.
 Everyone has their own path, and here I provided mine to become a data scientist. And this is in no way perfect as obviously, a lot of things can be added to it.
Though I did not complete any professional training, I consider myself more of a Computer science engineer than a mechanical engineer now due to the above courses.
I hope they help you too.
Thanks for the read. I am going to be writing more beginner-friendly posts in the future too. Follow me up at Medium or Subscribe to my blog.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>The Hitchhikers guide to handle Big Data using Spark</title>
      <link>https://mlwhiz.com/blog/2019/07/07/spark_hitchhiker/</link>
      <pubDate>Sun, 07 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2019/07/07/spark_hitchhiker/</guid>
      
      
      <media:content type="image/jpeg" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/spark/spark.jpeg"></media:content>
      

      
      <description>Big Data has become synonymous with Data engineering.
But the line between Data Engineering and Data scientists is blurring day by day.
At this point in time, I think that Big Data must be in the repertoire of all data scientists.
Reason: Too much data is getting generated day by day
And that brings us to Spark.
Now most of the Spark documentation, while good, did not explain it from the perspective of a data scientist.</description>

      <content:encoded>  
        
        <![CDATA[    Big Data has become synonymous with Data engineering.
But the line between Data Engineering and Data scientists is blurring day by day.
At this point in time, I think that Big Data must be in the repertoire of all data scientists.
Reason: Too much data is getting generated day by day
And that brings us to Spark.
Now most of the Spark documentation, while good, did not explain it from the perspective of a data scientist.
So I thought of giving it a shot.
This post is going to be about — “How to make Spark work?”
This post is going to be quite long. Actually my longest post on medium, so go pick up a Coffee.
How it all started?-MapReduce   Suppose you are tasked with cutting all the trees in the forest. Perhaps not a good business with all the global warming, but here it serves our purpose and we are talking hypothetically, so I will continue. You have two options:
 Get Batista with an electric powered chainsaw to do your work and make him cut each tree one by one.
 Get 500 normal guys with normal axes and make them work on different trees.
  Which would you prefer?
Although Option 1 is still the way some people would go, the need for option 2 led to the emergence of MapReduce.
In Bigdata speak, we call the Batista solution as scaling vertically/scaling-upas in we add/stuff a lot of RAM and hard disk in a single worker.
And the second solution is called scaling horizontally/scaling-sideways. As in you connect a lot of ordinary machines(with less RAM) together and use them in parallel.
Now, vertical scaling has certain benefits over Horizontal scaling:
 It is fast if the size of the problem is small: Think 2 trees. Batista would be through with both of them with his awesome chainsaw while our two guys would be still hacking with their axes.
 It is easy to understand. This is how we have always done things. We normally think about things in a sequential pattern and that is how our whole computer architecture and design has evolved.
  But, Horizontal Scaling is
 Less Expensive: Getting 50 normal guys itself is much cheaper than getting a single guy like Batista. Apart from that Batista needs a lot of care and maintenance to keep him cool and he is very sensitive to even small things just like machines with a high amount of RAM.
 Faster when the size of the problem is big: Now imagine 1000 trees and 1000 workers vs a single Batista. With Horizontal Scaling, if we face a very large problem we will just hire 100 or maybe 1000 more cheap workers. It doesn’t work like that with Batista. You have to increase RAM and that means more cooling infrastructure and more maintenance costs.
    MapReduce is what makes the second option possible by letting us use a cluster of computers for parallelization.
Now, MapReduce looks like a fairly technical term. But let us break it a little. MapReduce is made up of two terms:
Map: It is basically the apply/map function. We split our data into n chunks and send each chunk to a different worker(Mapper). If there is any function we would like to apply over the rows of Data our worker does that.
Reduce: Aggregate the data using some function based on a groupby key. It is basically a groupby.
Of course, there is a lot going in the background to make the system work as intended.
Don’t worry, if you don’t understand it yet. Just keep reading. Maybe you will understand it when we use MapReduce ourselves in the examples I am going to provide.
Why Spark?   Hadoop was the first open source system that introduced us to the MapReduce paradigm of programming and Spark is the system that made it faster, much much faster(100x).
There used to be a lot of data movement in Hadoop as it used to write intermediate results to the file system.
This affected the speed at which you could do analysis.
Spark provided us with an in-memory model, so Spark doesn’t write too much to the disk while working.
Simply, Spark is faster than Hadoop and a lot of people use Spark now.
So without further ado let us get started.
Getting Started with Spark Installing Spark is actually a headache of its own.
Since we want to understand how it works and really work with it, I would suggest that you use Sparks on Databricks here online with the community edition. Don’t worry it is free.
  Once you register and login will be presented with the following screen.
  You can start a new notebook here.
Select the Python notebook and give any name to your notebook.
Once you start a new notebook and try to execute any command, the notebook will ask you if you want to start a new cluster. Do it.
The next step will be to check if the sparkcontext is present. To check if the sparkcontext is present you just have to run this command:
sc   This means that we are set up with a notebook where we can run Spark.
Load Some Data The next step is to upload some data we will use to learn Spark. Just click on ‘Import and Explore Data’ on the home tab.
I will end up using multiple datasets by the end of this post but let us start with something very simple.
Let us add the file shakespeare.txt which you can download from here.
  You can see that the file is loaded to /FileStore/tables/shakespeare.txt location.
Our First Spark Program I like to learn by examples so let’s get done with the “Hello World” of Distributed computing: The WordCount Program.
# Distribute the data - Create a RDD lines = sc.textFile(&amp;#34;/FileStore/tables/shakespeare.txt&amp;#34;) # Create a list with all words, Create tuple (word,1), reduce by key i.e. the word counts = (lines.flatMap(lambda x: x.split(&amp;#39; &amp;#39;)) .map(lambda x: (x, 1)) .reduceByKey(lambda x,y : x &#43; y)) # get the output on local output = counts.take(10) # print output for (word, count) in output: print(&amp;#34;%s: %i&amp;#34; % (word, count))   So that is a small example which counts the number of words in the document and prints 10 of them.
And most of the work gets done in the second command.
Don’t worry if you are not able to follow this yet as I still need to tell you about the things that make Spark work.
But before we get into Spark basics, Let us refresh some of our Python Basics. Understanding Spark becomes a lot easier if you have used functional programming with Python.
For those of you who haven’t used it, below is a brief intro.
A functional approach to programming in Python   1. Map map is used to map a function to an array or a list. Say you want to apply some function to every element in a list.
You can do this by simply using a for loop but python lambda functions let you do this in a single line in Python.
my_list = [1,2,3,4,5,6,7,8,9,10] # Lets say I want to square each term in my_list. squared_list = map(lambda x:x**2,my_list) print(list(squared_list)) ------------------------------------------------------------ [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] In the above example, you could think of map as a function which takes two arguments — A function and a list.
It then applies the function to every element of the list.
What lambda allows you to do is write an inline function. In here the part lambda x:x**2 defines a function that takes x as input and returns x².
You could have also provided a proper function in place of lambda. For example:
def squared(x): return x**2 my_list = [1,2,3,4,5,6,7,8,9,10] # Lets say I want to square each term in my_list. squared_list = map(squared,my_list) print(list(squared_list)) ------------------------------------------------------------ [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] The same result, but the lambda expressions make the code compact and a lot more readable.
2. Filter The other function that is used extensively is the filter function. This function takes two arguments — A condition and the list to filter.
If you want to filter your list using some condition you use filter.
my_list = [1,2,3,4,5,6,7,8,9,10] # Lets say I want only the even numbers in my list. filtered_list = filter(lambda x:x%2==0,my_list) print(list(filtered_list)) --------------------------------------------------------------- [2, 4, 6, 8, 10] 3. Reduce The next function I want to talk about is the reduce function. This function will be the workhorse in Spark.
This function takes two arguments — a function to reduce that takes two arguments, and a list over which the reduce function is to be applied.
import functools my_list = [1,2,3,4,5] # Lets say I want to sum all elements in my list. sum_list = functools.reduce(lambda x,y:x&#43;y,my_list) print(sum_list) In python2 reduce used to be a part of Python, now we have to use reduce as a part of functools.
Here the lambda function takes in two values x, y and returns their sum. Intuitively you can think that the reduce function works as:
 Reduce function first sends 1,2 ; the lambda function returns 3 Reduce function then sends 3,3 ; the lambda function returns 6 Reduce function then sends 6,4 ; the lambda function returns 10 Reduce function finally sends 10,5 ; the lambda function returns 15  A condition on the lambda function we use in reduce is that it must be:
 commutative that is a &#43; b = b &#43; a and
 associative that is (a &#43; b) &#43; c == a &#43; (b &#43; c).
  In the above case, we used sum which is commutative as well as associative. Other functions that we could have used: max, min, * etc.
Moving Again to Spark As we have now got the fundamentals of Python Functional Programming out of the way, lets again head to Spark.
But first, let us delve a little bit into how spark works. Spark actually consists of two things a driver and workers.
Workers normally do all the work and the driver makes them do that work.
RDD An RDD(Resilient Distributed Dataset) is a parallelized data structure that gets distributed across the worker nodes. They are the basic units of Spark programming.
In our wordcount example, in the first line
lines = sc.textFile(&amp;quot;/FileStore/tables/shakespeare.txt&amp;quot;)  We took a text file and distributed it across worker nodes so that they can work on it in parallel. We could also parallelize lists using the function sc.parallelize
For example:
data = [1,2,3,4,5,6,7,8,9,10] new_rdd = sc.parallelize(data,4) new_rdd --------------------------------------------------------------- ParallelCollectionRDD[22] at parallelize at PythonRDD.scala:267 In Spark, we can do two different types of operations on RDD: Transformations and Actions.
 Transformations: Create new datasets from existing RDDs
 Actions: Mechanism to get results out of Spark
  Transformation Basics   So let us say you have got your data in the form of an RDD.
To requote your data is now accessible to the worker machines. You want to do some transformations on the data now.
You may want to filter, apply some function, etc.
In Spark, this is done using Transformation functions.
Spark provides many transformation functions. You can see a comprehensive list here. Some of the main ones that I use frequently are:
1. Map: Applies a given function to an RDD.
Note that the syntax is a little bit different from Python, but it necessarily does the same thing. Don’t worry about collect yet. For now, just think of it as a function that collects the data in squared_rdd back to a list.
data = [1,2,3,4,5,6,7,8,9,10] rdd = sc.parallelize(data,4) squared_rdd = rdd.map(lambda x:x**2) squared_rdd.collect() ------------------------------------------------------ [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 2. Filter: Again no surprises here. Takes as input a condition and keeps only those elements that fulfill that condition.
data = [1,2,3,4,5,6,7,8,9,10] rdd = sc.parallelize(data,4) filtered_rdd = rdd.filter(lambda x:x%2==0) filtered_rdd.collect() ------------------------------------------------------ [2, 4, 6, 8, 10] 3. distinct: Returns only distinct elements in an RDD.
data = [1,2,2,2,2,3,3,3,3,4,5,6,7,7,7,8,8,8,9,10] rdd = sc.parallelize(data,4) distinct_rdd = rdd.distinct() distinct_rdd.collect() ------------------------------------------------------ [8, 4, 1, 5, 9, 2, 10, 6, 3, 7]  4. flatmap: Similar to map, but each input item can be mapped to 0 or more output items.
data = [1,2,3,4] rdd = sc.parallelize(data,4) flat_rdd = rdd.flatMap(lambda x:[x,x**3]) flat_rdd.collect() ------------------------------------------------------ [1, 1, 2, 8, 3, 27, 4, 64] 5. Reduce By Key: The parallel to the reduce in Hadoop MapReduce.
Now Spark cannot provide the value if it just worked with Lists.
In Spark, there is a concept of pair RDDs that makes it a lot more flexible. Let&amp;rsquo;s assume we have a data in which we have a product, its category, and its selling price. We can still parallelize the data.
data = [(&amp;#39;Apple&amp;#39;,&amp;#39;Fruit&amp;#39;,200),(&amp;#39;Banana&amp;#39;,&amp;#39;Fruit&amp;#39;,24),(&amp;#39;Tomato&amp;#39;,&amp;#39;Fruit&amp;#39;,56),(&amp;#39;Potato&amp;#39;,&amp;#39;Vegetable&amp;#39;,103),(&amp;#39;Carrot&amp;#39;,&amp;#39;Vegetable&amp;#39;,34)] rdd = sc.parallelize(data,4) Right now our RDD rdd holds tuples.
Now we want to find out the total sum of revenue that we got from each category.
To do that we have to transform our rdd to a pair rdd so that it only contains key-value pairs/tuples.
category_price_rdd = rdd.map(lambda x: (x[1],x[2])) category_price_rdd.collect() ----------------------------------------------------------------- [(‘Fruit’, 200), (‘Fruit’, 24), (‘Fruit’, 56), (‘Vegetable’, 103), (‘Vegetable’, 34)] Here we used the map function to get it in the format we wanted. When working with textfile, the RDD that gets formed has got a lot of strings. We use map to convert it into a format that we want.
So now our category_price_rdd contains the product category and the price at which the product sold.
Now we want to reduce on the key category and sum the prices. We can do this by:
category_total_price_rdd = category_price_rdd.reduceByKey(lambda x,y:x&#43;y) category_total_price_rdd.collect() --------------------------------------------------------- [(‘Vegetable’, 137), (‘Fruit’, 280)] 6. Group By Key: Similar to reduceByKey but does not reduces just puts all the elements in an iterator. For example, if we wanted to keep as key the category and as the value all the products we would use this function.
Let us again use map to get data in the required form.
data = [(&amp;#39;Apple&amp;#39;,&amp;#39;Fruit&amp;#39;,200),(&amp;#39;Banana&amp;#39;,&amp;#39;Fruit&amp;#39;,24),(&amp;#39;Tomato&amp;#39;,&amp;#39;Fruit&amp;#39;,56),(&amp;#39;Potato&amp;#39;,&amp;#39;Vegetable&amp;#39;,103),(&amp;#39;Carrot&amp;#39;,&amp;#39;Vegetable&amp;#39;,34)] rdd = sc.parallelize(data,4) category_product_rdd = rdd.map(lambda x: (x[1],x[0])) category_product_rdd.collect() ------------------------------------------------------------ [(&amp;#39;Fruit&amp;#39;, &amp;#39;Apple&amp;#39;), (&amp;#39;Fruit&amp;#39;, &amp;#39;Banana&amp;#39;), (&amp;#39;Fruit&amp;#39;, &amp;#39;Tomato&amp;#39;), (&amp;#39;Vegetable&amp;#39;, &amp;#39;Potato&amp;#39;), (&amp;#39;Vegetable&amp;#39;, &amp;#39;Carrot&amp;#39;)] We then use groupByKey as:
grouped_products_by_category_rdd = category_product_rdd.groupByKey() findata = grouped_products_by_category_rdd.collect() for data in findata: print(data[0],list(data[1])) ------------------------------------------------------------ Vegetable [&amp;#39;Potato&amp;#39;, &amp;#39;Carrot&amp;#39;] Fruit [&amp;#39;Apple&amp;#39;, &amp;#39;Banana&amp;#39;, &amp;#39;Tomato&amp;#39;] Here the groupByKey function worked and it returned the category and the list of products in that category.
Action Basics   You have filtered your data, mapped some functions on it. Done your computation.
Now you want to get the data on your local machine or save it to a file or show the results in the form of some graphs in excel or any visualization tool.
You will need actions for that. A comprehensive list of actions is provided here.
Some of the most common actions that I tend to use are:
1. collect: We have already used this action many times. It takes the whole RDD and brings it back to the driver program.
2. reduce: Aggregate the elements of the dataset using a function func (which takes two arguments and returns one). The function should be commutative and associative so that it can be computed correctly in parallel.
rdd = sc.parallelize([1,2,3,4,5]) rdd.reduce(lambda x,y : x&#43;y) --------------------------------- 15 3. take: Sometimes you will need to see what your RDD contains without getting all the elements in memory itself. take returns a list with the first n elements of the RDD.
rdd = sc.parallelize([1,2,3,4,5]) rdd.take(3) --------------------------------- [1, 2, 3] 4. takeOrdered: takeOrdered returns the first n elements of the RDD using either their natural order or a custom comparator.
rdd = sc.parallelize([5,3,12,23]) # descending order rdd.takeOrdered(3,lambda s:-1*s) ---- [23, 12, 5] rdd = sc.parallelize([(5,23),(3,34),(12,344),(23,29)]) # descending order rdd.takeOrdered(3,lambda s:-1*s[1]) --- [(12, 344), (3, 34), (23, 29)] We have our basics covered finally. Let us get back to our wordcount example
Understanding The WordCount Example   Now we sort of understand the transformations and the actions provided to us by Spark.
It should not be difficult to understand the wordcount program now. Let us go through the program line by line.
The first line creates an RDD and distributes it to the workers.
lines = sc.textFile(&amp;quot;/FileStore/tables/shakespeare.txt&amp;quot;)  This RDD lines contains a list of sentences in the file. You can see the rdd content using take
lines.take(5) -------------------------------------------- [&#39;The Project Gutenberg EBook of The Complete Works of William Shakespeare, by &#39;, &#39;William Shakespeare&#39;, &#39;&#39;, &#39;This eBook is for the use of anyone anywhere at no cost and with&#39;, &#39;almost no restrictions whatsoever. You may copy it, give it away or&#39;]  This RDD is of the form:
[&#39;word1 word2 word3&#39;,&#39;word4 word3 word2&#39;]  This next line is actually the workhorse function in the whole script.
counts = (lines.flatMap(lambda x: x.split(&#39; &#39;)) .map(lambda x: (x, 1)) .reduceByKey(lambda x,y : x &#43; y))  It contains a series of transformations that we do to the lines RDD. First of all, we do a flatmap transformation.
The flatmap transformation takes as input the lines and gives words as output. So after the flatmap transformation, the RDD is of the form:
[&#39;word1&#39;,&#39;word2&#39;,&#39;word3&#39;,&#39;word4&#39;,&#39;word3&#39;,&#39;word2&#39;]  Next, we do a map transformation on the flatmap output which converts the RDD to :
[(&#39;word1&#39;,1),(&#39;word2&#39;,1),(&#39;word3&#39;,1),(&#39;word4&#39;,1),(&#39;word3&#39;,1),(&#39;word2&#39;,1)]  Finally, we do a reduceByKey transformation which counts the number of time each word appeared.
After which the RDD approaches the final desirable form.
[(&#39;word1&#39;,1),(&#39;word2&#39;,2),(&#39;word3&#39;,2),(&#39;word4&#39;,1)]  This next line is an action that takes the first 10 elements of the resulting RDD locally.
output = counts.take(10)  This line just prints the output
for (word, count) in output: print(&amp;quot;%s: %i&amp;quot; % (word, count))  And that is it for the wordcount program. Hope you understand it now.
So till now, we talked about the Wordcount example and the basic transformations and actions that you could use in Spark. But we don’t do wordcount in real life.
We have to work on bigger problems which are much more complex. Worry not! Whatever we have learned till now will let us do that and more.
Spark in Action with Example   Let us work with a concrete example which takes care of some usual transformations.
We will work on Movielens ml-100k.zip dataset which is a stable benchmark dataset. 100,000 ratings from 1000 users on 1700 movies. Released 4&amp;frasl;1998.
The Movielens dataset contains a lot of files but we are going to be working with 3 files only:
1) Users: This file name is kept as “u.user”, The columns in this file are:
[&#39;user_id&#39;, &#39;age&#39;, &#39;sex&#39;, &#39;occupation&#39;, &#39;zip_code&#39;]  2) Ratings: This file name is kept as “u.data”, The columns in this file are:
[&#39;user_id&#39;, &#39;movie_id&#39;, &#39;rating&#39;, &#39;unix_timestamp&#39;]  3) Movies: This file name is kept as “u.item”, The columns in this file are:
[&#39;movie_id&#39;, &#39;title&#39;, &#39;release_date&#39;, &#39;video_release_date&#39;, &#39;imdb_url&#39;, and 18 more columns.....]  Let us start by importing these 3 files into our spark instance using ‘Import and Explore Data’ on the home tab.
  Our business partner now comes to us and asks us to find out the 25 most rated movie titles from this data. How many times a movie has been rated?
Let us load the data in different RDDs and see what the data contains.
userRDD = sc.textFile(&amp;#34;/FileStore/tables/u.user&amp;#34;) ratingRDD = sc.textFile(&amp;#34;/FileStore/tables/u.data&amp;#34;) movieRDD = sc.textFile(&amp;#34;/FileStore/tables/u.item&amp;#34;) print(&amp;#34;userRDD:&amp;#34;,userRDD.take(1)) print(&amp;#34;ratingRDD:&amp;#34;,ratingRDD.take(1)) print(&amp;#34;movieRDD:&amp;#34;,movieRDD.take(1)) ----------------------------------------------------------- userRDD: [&amp;#39;1|24|M|technician|85711&amp;#39;] ratingRDD: [&amp;#39;196\t242\t3\t881250949&amp;#39;] movieRDD: [&amp;#39;1|Toy Story (1995)|01-Jan-1995||http://us.imdb.com/M/title-exact?Toy%20Story%20(1995)|0|0|0|1|1|1|0|0|0|0|0|0|0|0|0|0|0|0|0&amp;#39;] We note that to answer this question we will need to use the ratingRDD. But the ratingRDD does not have the movie name.
So we would have to merge movieRDD and ratingRDD using movie_id.
How we would do that in Spark?
Below is the code. We also use a new transformation leftOuterJoin. Do read the docs and comments in the below code.
# Create a RDD from RatingRDD that only contains the two columns of interest i.e. movie_id,rating. RDD_movid_rating = ratingRDD.map(lambda x : (x.split(&amp;#34;\t&amp;#34;)[1],x.split(&amp;#34;\t&amp;#34;)[2])) print(&amp;#34;RDD_movid_rating:&amp;#34;,RDD_movid_rating.take(4)) # Create a RDD from MovieRDD that only contains the two columns of interest i.e. movie_id,title. RDD_movid_title = movieRDD.map(lambda x : (x.split(&amp;#34;|&amp;#34;)[0],x.split(&amp;#34;|&amp;#34;)[1])) print(&amp;#34;RDD_movid_title:&amp;#34;,RDD_movid_title.take(2)) # merge these two pair RDDs based on movie_id. For this we will use the transformation leftOuterJoin(). See the transformation document. rdd_movid_title_rating = RDD_movid_rating.leftOuterJoin(RDD_movid_title) print(&amp;#34;rdd_movid_title_rating:&amp;#34;,rdd_movid_title_rating.take(1)) # use the RDD in previous step to create (movie,1) tuple pair RDD rdd_title_rating = rdd_movid_title_rating.map(lambda x: (x[1][1],1 )) print(&amp;#34;rdd_title_rating:&amp;#34;,rdd_title_rating.take(2)) # Use the reduceByKey transformation to reduce on the basis of movie_title rdd_title_ratingcnt = rdd_title_rating.reduceByKey(lambda x,y: x&#43;y) print(&amp;#34;rdd_title_ratingcnt:&amp;#34;,rdd_title_ratingcnt.take(2)) # Get the final answer by using takeOrdered Transformation print &amp;#34;#####################################&amp;#34; print &amp;#34;25 most rated movies:&amp;#34;,rdd_title_ratingcnt.takeOrdered(25,lambda x:-x[1]) print &amp;#34;#####################################&amp;#34; OUTPUT: --------------------------------------------------------------------RDD_movid_rating: [(&#39;242&#39;, &#39;3&#39;), (&#39;302&#39;, &#39;3&#39;), (&#39;377&#39;, &#39;1&#39;), (&#39;51&#39;, &#39;2&#39;)] RDD_movid_title: [(&#39;1&#39;, &#39;Toy Story (1995)&#39;), (&#39;2&#39;, &#39;GoldenEye (1995)&#39;)] rdd_movid_title_rating: [(&#39;1440&#39;, (&#39;3&#39;, &#39;Above the Rim (1994)&#39;))] rdd_title_rating: [(&#39;Above the Rim (1994)&#39;, 1), (&#39;Above the Rim (1994)&#39;, 1)] rdd_title_ratingcnt: [(&#39;Mallrats (1995)&#39;, 54), (&#39;Michael Collins (1996)&#39;, 92)] ##################################### 25 most rated movies: [(&#39;Star Wars (1977)&#39;, 583), (&#39;Contact (1997)&#39;, 509), (&#39;Fargo (1996)&#39;, 508), (&#39;Return of the Jedi (1983)&#39;, 507), (&#39;Liar Liar (1997)&#39;, 485), (&#39;English Patient, The (1996)&#39;, 481), (&#39;Scream (1996)&#39;, 478), (&#39;Toy Story (1995)&#39;, 452), (&#39;Air Force One (1997)&#39;, 431), (&#39;Independence Day (ID4) (1996)&#39;, 429), (&#39;Raiders of the Lost Ark (1981)&#39;, 420), (&#39;Godfather, The (1972)&#39;, 413), (&#39;Pulp Fiction (1994)&#39;, 394), (&#39;Twelve Monkeys (1995)&#39;, 392), (&#39;Silence of the Lambs, The (1991)&#39;, 390), (&#39;Jerry Maguire (1996)&#39;, 384), (&#39;Chasing Amy (1997)&#39;, 379), (&#39;Rock, The (1996)&#39;, 378), (&#39;Empire Strikes Back, The (1980)&#39;, 367), (&#39;Star Trek: First Contact (1996)&#39;, 365), (&#39;Back to the Future (1985)&#39;, 350), (&#39;Titanic (1997)&#39;, 350), (&#39;Mission: Impossible (1996)&#39;, 344), (&#39;Fugitive, The (1993)&#39;, 336), (&#39;Indiana Jones and the Last Crusade (1989)&#39;, 331)] #####################################  Star Wars is the most rated movie in the Movielens Dataset.
Now we could have done all this in a single command using the below command but the code is a little messy now.
I did this to show that you can use chaining functions with Spark and you could bypass the process of variable creation.
print(((ratingRDD.map(lambda x : (x.split(&amp;#34;\t&amp;#34;)[1],x.split(&amp;#34;\t&amp;#34;)[2]))). leftOuterJoin(movieRDD.map(lambda x : (x.split(&amp;#34;|&amp;#34;)[0],x.split(&amp;#34;|&amp;#34;)[1])))). map(lambda x: (x[1][1],1)). reduceByKey(lambda x,y: x&#43;y). takeOrdered(25,lambda x:-x[1])) Let us do one more. For practice:
Now we want to find the most highly rated 25 movies using the same dataset. We actually want only those movies which have been rated at least 100 times.
# We already have the RDD rdd_movid_title_rating: [(u&amp;#39;429&amp;#39;, (u&amp;#39;5&amp;#39;, u&amp;#39;Day the Earth Stood Still, The (1951)&amp;#39;))] # We create an RDD that contains sum of all the ratings for a particular movie rdd_title_ratingsum = (rdd_movid_title_rating. map(lambda x: (x[1][1],int(x[1][0]))). reduceByKey(lambda x,y:x&#43;y)) print(&amp;#34;rdd_title_ratingsum:&amp;#34;,rdd_title_ratingsum.take(2)) # Merge this data with the RDD rdd_title_ratingcnt we created in the last step # And use Map function to divide ratingsum by rating count. rdd_title_ratingmean_rating_count = (rdd_title_ratingsum. leftOuterJoin(rdd_title_ratingcnt). map(lambda x:(x[0],(float(x[1][0])/x[1][1],x[1][1])))) print(&amp;#34;rdd_title_ratingmean_rating_count:&amp;#34;,rdd_title_ratingmean_rating_count.take(1)) # We could use take ordered here only but we want to only get the movies which have count # of ratings more than or equal to 100 so lets filter the data RDD. rdd_title_rating_rating_count_gt_100 = (rdd_title_ratingmean_rating_count. filter(lambda x: x[1][1]&amp;gt;=100)) print(&amp;#34;rdd_title_rating_rating_count_gt_100:&amp;#34;,rdd_title_rating_rating_count_gt_100.take(1)) # Get the final answer by using takeOrdered Transformation print(&amp;#34;#####################################&amp;#34;) print (&amp;#34;25 highly rated movies:&amp;#34;) print(rdd_title_rating_rating_count_gt_100.takeOrdered(25,lambda x:-x[1][0])) print(&amp;#34;#####################################&amp;#34;) OUTPUT: ------------------------------------------------------------ rdd_title_ratingsum: [(&#39;Mallrats (1995)&#39;, 186), (&#39;Michael Collins (1996)&#39;, 318)] rdd_title_ratingmean_rating_count: [(&#39;Mallrats (1995)&#39;, (3.4444444444444446, 54))] rdd_title_rating_rating_count_gt_100: [(&#39;Butch Cassidy and the Sundance Kid (1969)&#39;, (3.949074074074074, 216))] ##################################### 25 highly rated movies: [(&#39;Close Shave, A (1995)&#39;, (4.491071428571429, 112)), (&amp;quot;Schindler&#39;s List (1993)&amp;quot;, (4.466442953020135, 298)), (&#39;Wrong Trousers, The (1993)&#39;, (4.466101694915254, 118)), (&#39;Casablanca (1942)&#39;, (4.45679012345679, 243)), (&#39;Shawshank Redemption, The (1994)&#39;, (4.445229681978798, 283)), (&#39;Rear Window (1954)&#39;, (4.3875598086124405, 209)), (&#39;Usual Suspects, The (1995)&#39;, (4.385767790262173, 267)), (&#39;Star Wars (1977)&#39;, (4.3584905660377355, 583)), (&#39;12 Angry Men (1957)&#39;, (4.344, 125)), (&#39;Citizen Kane (1941)&#39;, (4.292929292929293, 198)), (&#39;To Kill a Mockingbird (1962)&#39;, (4.292237442922374, 219)), (&amp;quot;One Flew Over the Cuckoo&#39;s Nest (1975)&amp;quot;, (4.291666666666667, 264)), (&#39;Silence of the Lambs, The (1991)&#39;, (4.28974358974359, 390)), (&#39;North by Northwest (1959)&#39;, (4.284916201117318, 179)), (&#39;Godfather, The (1972)&#39;, (4.283292978208232, 413)), (&#39;Secrets &amp;amp; Lies (1996)&#39;, (4.265432098765432, 162)), (&#39;Good Will Hunting (1997)&#39;, (4.262626262626263, 198)), (&#39;Manchurian Candidate, The (1962)&#39;, (4.259541984732825, 131)), (&#39;Dr. Strangelove or: How I Learned to Stop Worrying and Love the Bomb (1963)&#39;, (4.252577319587629, 194)), (&#39;Raiders of the Lost Ark (1981)&#39;, (4.252380952380952, 420)), (&#39;Vertigo (1958)&#39;, (4.251396648044692, 179)), (&#39;Titanic (1997)&#39;, (4.2457142857142856, 350)), (&#39;Lawrence of Arabia (1962)&#39;, (4.23121387283237, 173)), (&#39;Maltese Falcon, The (1941)&#39;, (4.2101449275362315, 138)), (&#39;Empire Strikes Back, The (1980)&#39;, (4.204359673024523, 367))] #####################################  We have talked about RDDs till now as they are very powerful.
You can use RDDs to work with non-relational databases too.
They let you do a lot of things that you couldn’t do with SparkSQL?
Yes, you can use SQL with Spark too which I am going to talk about now.
Spark DataFrames   Spark has provided DataFrame API for us Data Scientists to work with relational data. Here is the documentation for the adventurous folks.
Remember that in the background it still is all RDDs and that is why the starting part of this post focussed on RDDs.
I will start with some common functionalities you will need to work with Spark DataFrames. Would look a lot like Pandas with some syntax changes.
1. Reading the File ratings = spark.read.load(&amp;#34;/FileStore/tables/u.data&amp;#34;,format=&amp;#34;csv&amp;#34;, sep=&amp;#34;\t&amp;#34;, inferSchema=&amp;#34;true&amp;#34;, header=&amp;#34;false&amp;#34;) 2. Show File We have two ways to show files using Spark Dataframes.
ratings.show()   display(ratings)   I prefer display as it looks a lot nicer and clean.
3. Change Column names Good functionality. Always required. Don’t forget the * in front of the list.
ratings = ratings.toDF(*[&amp;#39;user_id&amp;#39;, &amp;#39;movie_id&amp;#39;, &amp;#39;rating&amp;#39;, &amp;#39;unix_timestamp&amp;#39;]) display(ratings)   4. Some Basic Stats print(ratings.count()) #Row Count print(len(ratings.columns)) #Column Count --------------------------------------------------------- 100000 4 We can also see the dataframe statistics using:
display(ratings.describe())   5. Select a few columns display(ratings.select(&amp;#39;user_id&amp;#39;,&amp;#39;movie_id&amp;#39;))   6. Filter Filter a dataframe using multiple conditions:
display(ratings.filter((ratings.rating==5) &amp;amp; (ratings.user_id==253)))   7. Groupby We can use groupby function with a spark dataframe too. Pretty much same as a pandas groupby with the exception that you will need to import pyspark.sql.functions
from pyspark.sql import functions as F display(ratings.groupBy(&amp;#34;user_id&amp;#34;).agg(F.count(&amp;#34;user_id&amp;#34;),F.mean(&amp;#34;rating&amp;#34;))) Here we have found the count of ratings and average rating from each user_id
  8. Sort display(ratings.sort(&amp;#34;user_id&amp;#34;))   We can also do a descending sort using F.desc function as below.
# descending Sort from pyspark.sql import functions as F display(ratings.sort(F.desc(&amp;#34;user_id&amp;#34;)))   Joins/Merging with Spark Dataframes I was not able to find a pandas equivalent of merge with Spark DataFrames but we can use SQL with dataframes and thus we can merge dataframes using SQL.
Let us try to run some SQL on Ratings.
We first register the ratings df to a temporary table ratings_table on which we can run sql operations.
As you can see the result of the SQL select statement is again a Spark Dataframe.
ratings.registerTempTable(&amp;#39;ratings_table&amp;#39;) newDF = sqlContext.sql(&amp;#39;select * from ratings_table where rating&amp;gt;4&amp;#39;) display(newDF)   Let us now add one more Spark Dataframe to the mix to see if we can use join using the SQL queries:
#get one more dataframe to join movies = spark.read.load(&amp;#34;/FileStore/tables/u.item&amp;#34;,format=&amp;#34;csv&amp;#34;, sep=&amp;#34;|&amp;#34;, inferSchema=&amp;#34;true&amp;#34;, header=&amp;#34;false&amp;#34;) # change column names movies = movies.toDF(*[&amp;#34;movie_id&amp;#34;,&amp;#34;movie_title&amp;#34;,&amp;#34;release_date&amp;#34;,&amp;#34;video_release_date&amp;#34;,&amp;#34;IMDb_URL&amp;#34;,&amp;#34;unknown&amp;#34;,&amp;#34;Action&amp;#34;,&amp;#34;Adventure&amp;#34;,&amp;#34;Animation &amp;#34;,&amp;#34;Children&amp;#34;,&amp;#34;Comedy&amp;#34;,&amp;#34;Crime&amp;#34;,&amp;#34;Documentary&amp;#34;,&amp;#34;Drama&amp;#34;,&amp;#34;Fantasy&amp;#34;,&amp;#34;Film_Noir&amp;#34;,&amp;#34;Horror&amp;#34;,&amp;#34;Musical&amp;#34;,&amp;#34;Mystery&amp;#34;,&amp;#34;Romance&amp;#34;,&amp;#34;Sci_Fi&amp;#34;,&amp;#34;Thriller&amp;#34;,&amp;#34;War&amp;#34;,&amp;#34;Western&amp;#34;]) display(movies)   Now let us try joining the tables on movie_id to get the name of the movie in the ratings table.
movies.registerTempTable(&amp;#39;movies_table&amp;#39;) display(sqlContext.sql(&amp;#39;select ratings_table.*,movies_table.movie_title from ratings_table left join movies_table on movies_table.movie_id = ratings_table.movie_id&amp;#39;))   Let us try to do what we were doing earlier with the RDDs. Finding the top 25 most rated movies:
mostrateddf = sqlContext.sql(&amp;#39;select movie_id,movie_title, count(user_id) as num_ratings from (select ratings_table.*,movies_table.movie_title from ratings_table left join movies_table on movies_table.movie_id = ratings_table.movie_id)A group by movie_id,movie_title order by num_ratings desc &amp;#39;) display(mostrateddf)   And finding the top 25 highest rated movies having more than 100 votes:
highrateddf = sqlContext.sql(&amp;#39;select movie_id,movie_title, avg(rating) as avg_rating,count(movie_id) as num_ratings from (select ratings_table.*,movies_table.movie_title from ratings_table left join movies_table on movies_table.movie_id = ratings_table.movie_id)A group by movie_id,movie_title having num_ratings&amp;gt;100 order by avg_rating desc &amp;#39;) display(highrateddf)   I have used GROUP BY, HAVING, AND ORDER BY clauses as well as aliases in the above query. That shows that you can do pretty much complex stuff using sqlContext.sql
A Small Note About Display You can also use display command to display charts in your notebooks.
  You can see more options when you select Plot Options.
  Converting from Spark Dataframe to RDD and vice versa: Sometimes you may want to convert to RDD from a spark Dataframe or vice versa so that you can have the best of both worlds.
To convert from DF to RDD, you can simply do :
highratedrdd =highrateddf.rdd highratedrdd.take(2)   To go from an RDD to a dataframe:
from pyspark.sql import Row # creating a RDD first data = [(&amp;#39;A&amp;#39;,1),(&amp;#39;B&amp;#39;,2),(&amp;#39;C&amp;#39;,3),(&amp;#39;D&amp;#39;,4)] rdd = sc.parallelize(data) # map the schema using Row. rdd_new = rdd.map(lambda x: Row(key=x[0], value=int(x[1]))) # Convert the rdd to Dataframe rdd_as_df = sqlContext.createDataFrame(rdd_new) display(rdd_as_df)   RDD provides you with more control at the cost of time and coding effort. While Dataframes provide you with familiar coding platform. And now you can move back and forth between these two.
Conclusion   This was a big post and congratulations if you reached the end.
Spark has provided us with an interface where we could use transformations and actions on our data. Spark also has the Dataframe API to ease the transition of Data scientists to Big Data.
Hopefully, I’ve covered the basics well enough to pique your interest and help you get started with Spark.
You can find all the code at the GitHub repository.
Also, if you want to learn more about Spark and Spark DataFrames, I would like to call out an excellent course on Big Data Essentials which is part of the Big Data Specialization provided by Yandex.
I am going to be writing more of such posts in the future too. Let me know what you think about the series. Follow me up at Medium or Subscribe to my blog.
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>To all Data Scientists - The one Graph Algorithm you need to know</title>
      <link>https://mlwhiz.com/blog/2018/12/07/connected_components/</link>
      <pubDate>Fri, 07 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2018/12/07/connected_components/</guid>
      
      
      <media:content type="image/jpeg" medium="image" width="700" height="400"
      url="https://mlwhiz.comhttps://upload.wikimedia.org/wikipedia/commons/8/85/Pseudoforest.svg"></media:content>
      

      
      <description>Graphs provide us with a very useful data structure. They can help us to find structure within our data. With the advent of Machine learning and big data we need to get as much information as possible about our data. Learning a little bit of graph theory can certainly help us with that.
Here is a Graph Analytics for Big Data course on Coursera by UCSanDiego which I highly recommend to learn the basics of graph theory.</description>

      <content:encoded>  
        
        <![CDATA[  Graphs provide us with a very useful data structure. They can help us to find structure within our data. With the advent of Machine learning and big data we need to get as much information as possible about our data. Learning a little bit of graph theory can certainly help us with that.
Here is a Graph Analytics for Big Data course on Coursera by UCSanDiego which I highly recommend to learn the basics of graph theory. You can start for free with the 7-day Free Trial.
One of the algorithms I am going to focus in the current post is called Connected Components. Why it is important. We all know clustering.
You can think of Connected Components in very layman&amp;rsquo;s terms as sort of a hard clustering algorithm which finds clusters/islands in related/connected data. As a concrete example: Say you have data about roads joining any two cities in the world. And you need to find out all the continents in the world and which city they contain.
How will you achieve that? Come on give some thought.
To put a Retail Perspective: Lets say, we have a lot of customers using a lot of accounts. One way in which we can use the Connected components algorithm is to find out distinct families in our dataset. We can assume edges(roads) between CustomerIDs based on same credit card usage, or same address or same mobile number etc. Once we have those connections, we can then run the connected component algorithm on the same to create individual clusters to which we can then assign a family ID. We can use these family IDs to provide personalized recommendations based on a family needs. We can also use this family ID to fuel our classification algorithms by creating grouped features based on family.
In Finance Perspective: Another use case would be to capture fraud using these family IDs. If an account has done fraud in past, it is highly probable that the connected accounts are also susceptible to fraud.
So enough of use cases. Lets start with a simple graph class written in Python to start up our exploits with code.
This post will revolve more around code from here onwards.
&amp;#34;&amp;#34;&amp;#34; A Python Class A simple Python graph class, demonstrating the essential facts and functionalities of graphs. Taken from https://www.python-course.eu/graphs_python.php Changed the implementation a little bit to include weighted edges &amp;#34;&amp;#34;&amp;#34; class Graph(object): def __init__(self, graph_dict=None): &amp;#34;&amp;#34;&amp;#34; initializes a graph object If no dictionary or None is given, an empty dictionary will be used &amp;#34;&amp;#34;&amp;#34; if graph_dict == None: graph_dict = {} self.__graph_dict = graph_dict def vertices(self): &amp;#34;&amp;#34;&amp;#34; returns the vertices of a graph &amp;#34;&amp;#34;&amp;#34; return list(self.__graph_dict.keys()) def edges(self): &amp;#34;&amp;#34;&amp;#34; returns the edges of a graph &amp;#34;&amp;#34;&amp;#34; return self.__generate_edges() def add_vertex(self, vertex): &amp;#34;&amp;#34;&amp;#34; If the vertex &amp;#34;vertex&amp;#34; is not in self.__graph_dict, a key &amp;#34;vertex&amp;#34; with an empty dict as a value is added to the dictionary. Otherwise nothing has to be done. &amp;#34;&amp;#34;&amp;#34; if vertex not in self.__graph_dict: self.__graph_dict[vertex] = {} def add_edge(self, edge,weight=1): &amp;#34;&amp;#34;&amp;#34; assumes that edge is of type set, tuple or list &amp;#34;&amp;#34;&amp;#34; edge = set(edge) (vertex1, vertex2) = tuple(edge) if vertex1 in self.__graph_dict: self.__graph_dict[vertex1][vertex2] = weight else: self.__graph_dict[vertex1] = {vertex2:weight} if vertex2 in self.__graph_dict: self.__graph_dict[vertex2][vertex1] = weight else: self.__graph_dict[vertex2] = {vertex1:weight} def __generate_edges(self): &amp;#34;&amp;#34;&amp;#34; A static method generating the edges of the graph &amp;#34;graph&amp;#34;. Edges are represented as sets with one (a loop back to the vertex) or two vertices &amp;#34;&amp;#34;&amp;#34; edges = [] for vertex in self.__graph_dict: for neighbour,weight in self.__graph_dict[vertex].iteritems(): if (neighbour, vertex, weight) not in edges: edges.append([vertex, neighbour, weight]) return edges def __str__(self): res = &amp;#34;vertices: &amp;#34; for k in self.__graph_dict: res &#43;= str(k) &#43; &amp;#34; &amp;#34; res &#43;= &amp;#34;\nedges: &amp;#34; for edge in self.__generate_edges(): res &#43;= str(edge) &#43; &amp;#34; &amp;#34; return res def adj_mat(self): return self.__graph_dict You can certainly play with our new graph class.Here we try to build some graphs.
g = { &amp;#34;a&amp;#34; : {&amp;#34;d&amp;#34;:2}, &amp;#34;b&amp;#34; : {&amp;#34;c&amp;#34;:2}, &amp;#34;c&amp;#34; : {&amp;#34;b&amp;#34;:5, &amp;#34;d&amp;#34;:3, &amp;#34;e&amp;#34;:5} } graph = Graph(g) print(&amp;#34;Vertices of graph:&amp;#34;) print(graph.vertices()) print(&amp;#34;Edges of graph:&amp;#34;) print(graph.edges()) print(&amp;#34;Add vertex:&amp;#34;) graph.add_vertex(&amp;#34;z&amp;#34;) print(&amp;#34;Vertices of graph:&amp;#34;) print(graph.vertices()) print(&amp;#34;Add an edge:&amp;#34;) graph.add_edge({&amp;#34;a&amp;#34;,&amp;#34;z&amp;#34;}) print(&amp;#34;Vertices of graph:&amp;#34;) print(graph.vertices()) print(&amp;#34;Edges of graph:&amp;#34;) print(graph.edges()) print(&amp;#39;Adding an edge {&amp;#34;x&amp;#34;,&amp;#34;y&amp;#34;} with new vertices:&amp;#39;) graph.add_edge({&amp;#34;x&amp;#34;,&amp;#34;y&amp;#34;}) print(&amp;#34;Vertices of graph:&amp;#34;) print(graph.vertices()) print(&amp;#34;Edges of graph:&amp;#34;) print(graph.edges()) Vertices of graph: [&#39;a&#39;, &#39;c&#39;, &#39;b&#39;] Edges of graph: [[&#39;a&#39;, &#39;d&#39;, 2], [&#39;c&#39;, &#39;b&#39;, 5], [&#39;c&#39;, &#39;e&#39;, 5], [&#39;c&#39;, &#39;d&#39;, 3], [&#39;b&#39;, &#39;c&#39;, 2]] Add vertex: Vertices of graph: [&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;z&#39;] Add an edge: Vertices of graph: [&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;z&#39;] Edges of graph: [[&#39;a&#39;, &#39;z&#39;, 1], [&#39;a&#39;, &#39;d&#39;, 2], [&#39;c&#39;, &#39;b&#39;, 5], [&#39;c&#39;, &#39;e&#39;, 5], [&#39;c&#39;, &#39;d&#39;, 3], [&#39;b&#39;, &#39;c&#39;, 2], [&#39;z&#39;, &#39;a&#39;, 1]] Adding an edge {&#34;x&#34;,&#34;y&#34;} with new vertices: Vertices of graph: [&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;y&#39;, &#39;x&#39;, &#39;z&#39;] Edges of graph: [[&#39;a&#39;, &#39;z&#39;, 1], [&#39;a&#39;, &#39;d&#39;, 2], [&#39;c&#39;, &#39;b&#39;, 5], [&#39;c&#39;, &#39;e&#39;, 5], [&#39;c&#39;, &#39;d&#39;, 3], [&#39;b&#39;, &#39;c&#39;, 2], [&#39;y&#39;, &#39;x&#39;, 1], [&#39;x&#39;, &#39;y&#39;, 1], [&#39;z&#39;, &#39;a&#39;, 1]]  Lets do something interesting now.
We will use the above graph class for our understanding purpose. There are many Modules in python which we can use to do whatever I am going to do next,but to understand the methods we will write everything from scratch. Lets start with an example graph which we can use for our purpose.
  g = {&amp;#39;Frankfurt&amp;#39;: {&amp;#39;Mannheim&amp;#39;:85, &amp;#39;Wurzburg&amp;#39;:217, &amp;#39;Kassel&amp;#39;:173}, &amp;#39;Mannheim&amp;#39;: {&amp;#39;Frankfurt&amp;#39;:85, &amp;#39;Karlsruhe&amp;#39;:80}, &amp;#39;Karlsruhe&amp;#39;: {&amp;#39;Augsburg&amp;#39;:250, &amp;#39;Mannheim&amp;#39;:80}, &amp;#39;Augsburg&amp;#39;: {&amp;#39;Karlsruhe&amp;#39;:250, &amp;#39;Munchen&amp;#39;:84}, &amp;#39;Wurzburg&amp;#39;: {&amp;#39;Erfurt&amp;#39;:186, &amp;#39;Numberg&amp;#39;:103,&amp;#39;Frankfurt&amp;#39;:217}, &amp;#39;Erfurt&amp;#39;: {&amp;#39;Wurzburg&amp;#39;:186}, &amp;#39;Numberg&amp;#39;: {&amp;#39;Wurzburg&amp;#39;:103, &amp;#39;Stuttgart&amp;#39;:183,&amp;#39;Munchen&amp;#39;:167}, &amp;#39;Munchen&amp;#39;: {&amp;#39;Numberg&amp;#39;:167, &amp;#39;Augsburg&amp;#39;:84,&amp;#39;Kassel&amp;#39;:502}, &amp;#39;Kassel&amp;#39;: {&amp;#39;Frankfurt&amp;#39;:173, &amp;#39;Munchen&amp;#39;:502}, &amp;#39;Stuttgart&amp;#39;: {&amp;#39;Numberg&amp;#39;:183} } graph = Graph(g) print(&amp;#34;Vertices of graph:&amp;#34;) print(graph.vertices()) print(&amp;#34;Edges of graph:&amp;#34;) print(graph.edges()) Vertices of graph: [&#39;Mannheim&#39;, &#39;Erfurt&#39;, &#39;Munchen&#39;, &#39;Numberg&#39;, &#39;Stuttgart&#39;, &#39;Augsburg&#39;, &#39;Kassel&#39;, &#39;Frankfurt&#39;, &#39;Wurzburg&#39;, &#39;Karlsruhe&#39;] Edges of graph: [[&#39;Mannheim&#39;, &#39;Frankfurt&#39;, 85], [&#39;Mannheim&#39;, &#39;Karlsruhe&#39;, 80], [&#39;Erfurt&#39;, &#39;Wurzburg&#39;, 186], [&#39;Munchen&#39;, &#39;Numberg&#39;, 167], [&#39;Munchen&#39;, &#39;Augsburg&#39;, 84], [&#39;Munchen&#39;, &#39;Kassel&#39;, 502], [&#39;Numberg&#39;, &#39;Stuttgart&#39;, 183], [&#39;Numberg&#39;, &#39;Wurzburg&#39;, 103], [&#39;Numberg&#39;, &#39;Munchen&#39;, 167], [&#39;Stuttgart&#39;, &#39;Numberg&#39;, 183], [&#39;Augsburg&#39;, &#39;Munchen&#39;, 84], [&#39;Augsburg&#39;, &#39;Karlsruhe&#39;, 250], [&#39;Kassel&#39;, &#39;Munchen&#39;, 502], [&#39;Kassel&#39;, &#39;Frankfurt&#39;, 173], [&#39;Frankfurt&#39;, &#39;Mannheim&#39;, 85], [&#39;Frankfurt&#39;, &#39;Wurzburg&#39;, 217], [&#39;Frankfurt&#39;, &#39;Kassel&#39;, 173], [&#39;Wurzburg&#39;, &#39;Numberg&#39;, 103], [&#39;Wurzburg&#39;, &#39;Erfurt&#39;, 186], [&#39;Wurzburg&#39;, &#39;Frankfurt&#39;, 217], [&#39;Karlsruhe&#39;, &#39;Mannheim&#39;, 80], [&#39;Karlsruhe&#39;, &#39;Augsburg&#39;, 250]]  Lets say we are given a graph with the cities of Germany and respective distance between them. You want to find out how to go from Frankfurt (The starting node) to Munchen. There might be many ways in which you can traverse the graph but you need to find how many cities you will need to visit on a minimum to go from frankfurt to Munchen) This problem is analogous to finding out distance between nodes in an unweighted graph.
The algorithm that we use here is called as Breadth First Search.
def min_num_edges_between_nodes(graph,start_node): distance = 0 shortest_path = [] queue = [start_node] #FIFO levels = {} levels[start_node] = 0 shortest_paths = {} shortest_paths[start_node] = &amp;#34;:&amp;#34; visited = [start_node] while len(queue)!=0: start = queue.pop(0) neighbours = graph[start] for neighbour,_ in neighbours.iteritems(): if neighbour not in visited: queue.append(neighbour) visited.append(neighbour) levels[neighbour] = levels[start]&#43;1 shortest_paths[neighbour] = shortest_paths[start] &#43;&amp;#34;-&amp;gt;&amp;#34;&#43; start return levels, shortest_paths What we do in the above piece of code is create a queue and traverse it based on levels. We start with Frankfurt as starting node. We loop through its neighbouring cities(Menheim, Wurzburg and Kassel) and push them into the queue. We keep track of what level they are at and also the path through which we reached them. Since we are popping a first element of a queue we are sure we will visit cities in the order of their level.
Checkout this good post about BFS to understand more about queues and BFS.
min_num_edges_between_nodes(g,&amp;#39;Frankfurt&amp;#39;) ({&#39;Augsburg&#39;: 3, &#39;Erfurt&#39;: 2, &#39;Frankfurt&#39;: 0, &#39;Karlsruhe&#39;: 2, &#39;Kassel&#39;: 1, &#39;Mannheim&#39;: 1, &#39;Munchen&#39;: 2, &#39;Numberg&#39;: 2, &#39;Stuttgart&#39;: 3, &#39;Wurzburg&#39;: 1}, {&#39;Augsburg&#39;: &#39;:-Frankfurt-Mannheim-Karlsruhe&#39;, &#39;Erfurt&#39;: &#39;:-Frankfurt-Wurzburg&#39;, &#39;Frankfurt&#39;: &#39;:&#39;, &#39;Karlsruhe&#39;: &#39;:-Frankfurt-Mannheim&#39;, &#39;Kassel&#39;: &#39;:-Frankfurt&#39;, &#39;Mannheim&#39;: &#39;:-Frankfurt&#39;, &#39;Munchen&#39;: &#39;:-Frankfurt-Kassel&#39;, &#39;Numberg&#39;: &#39;:-Frankfurt-Wurzburg&#39;, &#39;Stuttgart&#39;: &#39;:-Frankfurt-Wurzburg-Numberg&#39;, &#39;Wurzburg&#39;: &#39;:-Frankfurt&#39;})  I did this example to show how BFS algorithm works. We can extend this algorithm to find out connected components in an unconnected graph. Lets say we need to find groups of unconnected vertices in the graph.
For example: the below graph has 3 unconnected sub-graphs. Can we find what nodes belong to a particular subgraph?
  #We add another countries in the loop graph = Graph(g) graph.add_edge((&amp;#34;Mumbai&amp;#34;, &amp;#34;Delhi&amp;#34;),400) graph.add_edge((&amp;#34;Delhi&amp;#34;, &amp;#34;Kolkata&amp;#34;),500) graph.add_edge((&amp;#34;Kolkata&amp;#34;, &amp;#34;Bangalore&amp;#34;),600) graph.add_edge((&amp;#34;TX&amp;#34;, &amp;#34;NY&amp;#34;),1200) graph.add_edge((&amp;#34;ALB&amp;#34;, &amp;#34;NY&amp;#34;),800) g = graph.adj_mat() def bfs_connected_components(graph): connected_components = [] nodes = graph.keys() while len(nodes)!=0: start_node = nodes.pop() queue = [start_node] #FIFO visited = [start_node] while len(queue)!=0: start = queue[0] queue.remove(start) neighbours = graph[start] for neighbour,_ in neighbours.iteritems(): if neighbour not in visited: queue.append(neighbour) visited.append(neighbour) nodes.remove(neighbour) connected_components.append(visited) return connected_components print bfs_connected_components(g) The above code is similar to the previous BFS code. We keep all the vertices of the graph in the nodes list. We take a node from the nodes list and start BFS on it. as we visit a node we remove that node from the nodes list. Whenever the BFS completes we start again with another node in the nodes list until the nodes list is empty.
[[&#39;Kassel&#39;, &#39;Munchen&#39;, &#39;Frankfurt&#39;, &#39;Numberg&#39;, &#39;Augsburg&#39;, &#39;Mannheim&#39;, &#39;Wurzburg&#39;, &#39;Stuttgart&#39;, &#39;Karlsruhe&#39;, &#39;Erfurt&#39;], [&#39;Bangalore&#39;, &#39;Kolkata&#39;, &#39;Delhi&#39;, &#39;Mumbai&#39;], [&#39;NY&#39;, &#39;ALB&#39;, &#39;TX&#39;]]  As you can see we are able to find distinct components in our data. Just by using Edges and Vertices. This algorithm could be run on different data to satisfy any use case I presented above.
But Normally using Connected Components for a retail case will involve a lot of data and you will need to scale this algorithm.
Connected Components in PySpark Below is an implementation from this paper on Connected Components in MapReduce and Beyond from Google Research. Read the PPT to understand the implementation better. Some ready to use code for you.
def create_edges(line): a = [int(x) for x in line.split(&amp;#34; &amp;#34;)] edges_list=[] for i in range(0, len(a)-1): for j in range(i&#43;1 ,len(a)): edges_list.append((a[i],a[j])) edges_list.append((a[j],a[i])) return edges_list # adj_list.txt is a txt file containing adjacency list of the graph. adjacency_list = sc.textFile(&amp;#34;adj_list.txt&amp;#34;) edges_rdd = adjacency_list.flatMap(lambda line : create_edges(line)).distinct() def largeStarInit(record): a, b = record yield (a,b) yield (b,a) def largeStar(record): a, b = record t_list = list(b) t_list.append(a) list_min = min(t_list) for x in b: if a &amp;lt; x: yield (x,list_min) def smallStarInit(record): a, b = record if b&amp;lt;=a: yield (a,b) else: yield (b,a) def smallStar(record): a, b = record t_list = list(b) t_list.append(a) list_min = min(t_list) for x in t_list: if x!=list_min: yield (x,list_min) #Handle case for single nodes def single_vertex(line): a = [int(x) for x in line.split(&amp;#34; &amp;#34;)] edges_list=[] if len(a)==1: edges_list.append((a[0],a[0])) return edges_list iteration_num =0 while 1==1: if iteration_num==0: print &amp;#34;iter&amp;#34;, iteration_num large_star_rdd = edges_rdd.groupByKey().flatMap(lambda x : largeStar(x)) small_star_rdd = large_star_rdd.flatMap(lambda x : smallStarInit(x)).groupByKey().flatMap(lambda x : smallStar(x)).distinct() iteration_num &#43;= 1 else: print &amp;#34;iter&amp;#34;, iteration_num large_star_rdd = small_star_rdd.flatMap(lambda x: largeStarInit(x)).groupByKey().flatMap(lambda x : largeStar(x)).distinct() small_star_rdd = large_star_rdd.flatMap(lambda x : smallStarInit(x)).groupByKey().flatMap(lambda x : smallStar(x)).distinct() iteration_num &#43;= 1 #check Convergence changes = (large_star_rdd.subtract(small_star_rdd).union(small_star_rdd.subtract(large_star_rdd))).collect() if len(changes) == 0 : break single_vertex_rdd = adjacency_list.flatMap(lambda line : single_vertex(line)).distinct() answer = single_vertex_rdd.collect() &#43; large_star_rdd.collect() print answer[:10] Or Use GraphFrames in PySpark To Install graphframes:
I ran on command line: pyspark &amp;ndash;packages graphframes:graphframes:0.5.0-spark2.1-s_2.11 which opened up my notebook and installed graphframes after i try to import in my notebook.
The string to be formatted as : graphframes:(latest version)-spark(your spark version)-s_(your scala version).
Checkout this guide on how to use GraphFrames for more information.
from graphframes import * def vertices(line): vert = [int(x) for x in line.split(&amp;#34; &amp;#34;)] return vert vertices = adjacency_list.flatMap(lambda x: vertices(x)).distinct().collect() vertices = sqlContext.createDataFrame([[x] for x in vertices], [&amp;#34;id&amp;#34;]) def create_edges(line): a = [int(x) for x in line.split(&amp;#34; &amp;#34;)] edges_list=[] if len(a)==1: edges_list.append((a[0],a[0])) for i in range(0, len(a)-1): for j in range(i&#43;1 ,len(a)): edges_list.append((a[i],a[j])) edges_list.append((a[j],a[i])) return edges_list edges = adjacency_list.flatMap(lambda x: create_edges(x)).distinct().collect() edges = sqlContext.createDataFrame(edges, [&amp;#34;src&amp;#34;, &amp;#34;dst&amp;#34;]) g = GraphFrame(vertices, edges) sc.setCheckpointDir(&amp;#34;.&amp;#34;) # graphframes uses the same paper we referenced apparently cc = g.connectedComponents() print cc.show() The GraphFrames library implements the CC algorithm as well as a variety of other graph algorithms.
The above post was a lot of code but hope it was helpful. It took me a lot of time to implement the algorithm so wanted to make it easy for the folks.
If you want to read up more on Graph Algorithms here is an Graph Analytics for Big Data course on Coursera by UCSanDiego which I highly recommend to learn the basics of graph theory.
References  Graphs in Python A Gentle Intoduction to Graph Theory Blog Graph Analytics for Big Data course on Coursera by UCSanDiego  ]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Top Data Science Resources on the Internet right now</title>
      <link>https://mlwhiz.com/blog/2017/03/26/top_data_science_resources_on_the_internet_right_now/</link>
      <pubDate>Sun, 26 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2017/03/26/top_data_science_resources_on_the_internet_right_now/</guid>
      
      

      
      <description>I have been looking to create this list for a while now. There are many people on quora who ask me how I started in the data science field. And so I wanted to create this reference.
To be frank, when I first started learning it all looked very utopian and out of the world. The Andrew Ng course felt like black magic. And it still doesn&amp;amp;rsquo;t cease to amaze me.</description>

      <content:encoded>  
        
        <![CDATA[  I have been looking to create this list for a while now. There are many people on quora who ask me how I started in the data science field. And so I wanted to create this reference.
To be frank, when I first started learning it all looked very utopian and out of the world. The Andrew Ng course felt like black magic. And it still doesn&amp;rsquo;t cease to amaze me. After all, we are predicting the future. Take the case of Nate Silver - What else can you call his success if not Black Magic?
But it is not magic. And this is a way an aspiring guy could take to become a self-trained data scientist. Follow in order. I have tried to include everything that comes to my mind. So here goes:
1. Stat 110: Introduction to Probability: Joe Blitzstein - Harvard University The one stat course you gotta take. If not for the content then for Prof. Blitzstein sense of humor. I took this course to enhance my understanding of probability distributions and statistics, but this course taught me a lot more than that. Apart from Learning to think conditionally, this also taught me how to explain difficult concepts with a story.
This was a Hard Class but most definitely fun. The focus was not only on getting Mathematical proofs but also on understanding the intuition behind them and how intuition can help in deriving them more easily. Sometimes the same proof was done in different ways to facilitate learning of a concept.
One of the things I liked most about this course is the focus on concrete examples while explaining abstract concepts. The inclusion of ** Gambler’s Ruin Problem, Matching Problem, Birthday Problem, Monty Hall, Simpsons Paradox, St. Petersberg Paradox ** etc. made this course much much more exciting than a normal Statistics Course.
It will help you understand Discrete (Bernoulli, Binomial, Hypergeometric, Geometric, Negative Binomial, FS, Poisson) and Continuous (Uniform, Normal, expo, Beta, Gamma) Distributions and the stories behind them. Something that I was always afraid of.
He got a textbook out based on this course which is clearly a great text:
 2. Data Science CS109: - Again by Professor Blitzstein. Again an awesome course. Watch it after Stat110 as you will be able to understand everything much better with a thorough grinding in Stat110 concepts. You will learn about Python Libraries like Numpy,Pandas for data science, along with a thorough intuitive grinding for various Machine learning Algorithms. Course description from Website:
Learning from data in order to gain useful predictions and insights. This course introduces methods for five key facets of an investigation: data wrangling, cleaning, and sampling to get a suitable data set; data management to be able to access big data quickly and reliably; exploratory data analysis to generate hypotheses and intuition; prediction based on statistical methods such as regression and classification; and communication of results through visualization, stories, and interpretable summaries.  3. CS229: Andrew Ng After doing these two above courses you will gain the status of what I would like to call a &amp;ldquo;Beginner&amp;rdquo;. Congrats!!!. You know stuff, you know how to implement stuff. Yet you do not fully understand all the math and grind that goes behind all this.
Here comes the Game Changer machine learning course. Contains the maths behind many of the Machine Learning algorithms. I will put this course as the one course you gotta take as this course motivated me into getting in this field and Andrew Ng is a great instructor. Also this was the first course that I took.
Also recently Andrew Ng Released a new Book. You can get the Draft chapters by subcribing on his website here.
You are done with the three musketeers of the trade. You know Python, you understand Statistics and you have gotten the taste of the math behind ML approaches. Now it is time for the new kid on the block. D&amp;rsquo;artagnan. This kid has skills. While the three musketeers are masters in their trade, this guy brings qualities that adds a new freshness to our data science journey. Here comes Big Data for you.
4. Intro to Hadoop &amp;amp; Mapreduce - Udacity Let us first focus on the literal elephant in the room - Hadoop. Short and Easy Course. Taught the Fundamentals of Hadoop streaming with Python. Taken by Cloudera on Udacity. I am doing much more advanced stuff with python and Mapreduce now but this is one of the courses that laid the foundation there.
Once you are done through this course you would have gained quite a basic understanding of concepts and you would have installed a Hadoop VM in your own machine. You would also have solved the Basic Wordcount Problem. Read this amazing Blog Post from Michael Noll: Writing An Hadoop MapReduce Program In Python - Michael G. Noll. Just read the basic mapreduce codes. Don&amp;rsquo;t use Iterators and Generators yet. This has been a starting point for many of us Hadoop developers.
Now try to solve these two problems from the CS109 Harvard course from 2013:
A. First, grab the file word_list.txt from here. This contains a list of six-letter words. To keep things simple, all of the words consist of lower-case letters only.Write a mapreduce job that finds all anagrams in word_list.txt.
B. For the next problem, download the file baseball_friends.csv. Each row of this csv file contains the following:
 A person&amp;rsquo;s name The team that person is rooting for &amp;ndash; either &amp;ldquo;Cardinals&amp;rdquo; or &amp;ldquo;Red Sox&amp;rdquo; A list of that person&amp;rsquo;s friends, which could have arbitrary length  For example: The first line tells us that Aaden is a Red Sox friend and he has 65 friends, who are all listed here. For this problem, it&amp;rsquo;s safe to assume that all of the names are unique and that the friendship structure is symmetric (i.e. if Alannah shows up in Aaden&amp;rsquo;s friends list, then Aaden will show up in Alannah&amp;rsquo;s friends list). Write an mr job that lists each person&amp;rsquo;s name, their favorite team, the number of Red Sox fans they are friends with, and the number of Cardinals fans they are friends with.
Try to do this yourself. Don&amp;rsquo;t use the mrjob (pronounced Mr. Job) way that they use in the CS109 2013 class. Use the proper Hadoop Streaming way as taught in the Udacity class as it is much more customizable in the long run.
If you are done with these, you can safely call yourself as someone who could &amp;ldquo;think in Mapreduce&amp;rdquo; as how people like to call it.Try to do groupby, filter and joins using Hadoop. You can read up some good tricks from my blog:
Hadoop Mapreduce Streaming Tricks and Techniques
If you are someone who likes learning from a book you can get: 
5. Spark - In memory Big Data tool. Now comes the next part of your learning process. This should be undertaken after a little bit of experience with Hadoop. Spark will provide you with the speed and tools that Hadoop couldn&amp;rsquo;t.
Now Spark is used for data preparation as well as Machine learning purposes. I would encourage you to take a look at the series of courses on edX provided by Berkeley instructors. This course delivers on what it says. It teaches Spark. Total beginners will have difficulty following the course as the course progresses very fast. That said anyone with a decent understanding of how big data works will be OK.
Data Science and Engineering with Apache® Spark™
I have written a little bit about Basic data processing with Spark here. Take a look: Learning Spark using Python: Basics and Applications
Also take a look at some of the projects I did as part of course at github
If you would like a book to read: 
If you don&amp;rsquo;t go through the courses, try solving the same two problems above that you solved by Hadoop using Spark too. Otherwise the problem sets in the courses are more than enough.
6. Understand Linux Shell: Shell is a big friend for data scientists. It allows you to do simple data related tasks in the terminal itself. I couldn&amp;rsquo;t emphasize how much time shell saves for me everyday.
Read these tutorials by me for doing that:
Shell Basics every Data Scientist Should know -Part I Shell Basics every Data Scientist Should know - Part II(AWK)
If you would like a course you can go for this course on edX.
If you want a book, go for:
 Congrats you are an &amp;ldquo;Hacker&amp;rdquo; now. You have got all the main tools in your belt to be a data scientist. On to more advanced topics. From here it depends on you what you want to learn. You may want to take a totally different approach than what I took going from here. There is no particular order. &amp;ldquo;All Roads lead to Rome&amp;rdquo; as long as you are running.
7. Learn Statistical Inference and Bayesian Statistics I took the previous version of the specialization which was a single course taught by Mine Çetinkaya-Rundel. She is a great instrucor and explains the fundamentals of Statistical inference nicely. A must take course. You will learn about hypothesis testing, confidence intervals, and statistical inference methods for numerical and categorical data. You can also use these books:
  8. Deep Learning Intro - Making neural nets uncool again. An awesome Deep learning class from Kaggle Master Jeremy Howard. Entertaining and enlightening at the same time.
Advanced - A series of notes from the Stanford CS class CS231n: Convolutional Neural Networks for Visual Recognition.
Bonus - A free online book by Michael Nielsen.
Advanced Math Book - A math intensive book by Yoshua Bengio &amp;amp; Ian Goodfellow
9. Algorithms, Graph Algorithms, Recommendation Systems, Pagerank and More This course used to be there on Coursera but now only video links on youtube available. You can learn from this book too: 
Apart from that if you want to learn about Python and the basic intricacies of the language you can take the Computer Science Mini Specialization from RICE university too. This is a series of 6 short but good courses. I worked on these courses as Data science will require you to do a lot of programming. And the best way to learn programming is by doing programming. The lectures are good but the problems and assignments are awesome. If you work on this you will learn Object Oriented Programming,Graph algorithms and games in Python. Pretty cool stuff.
10. Advanced Maths: Couldn&amp;rsquo;t write enough of the importance of Math. But here are a few awesome resources that you can go for.
Linear Algebra By Gilbert Strang - A Great Class by a great Teacher. I Would definitely recommend this class to anyone who wants to learn LA.
Multivariate Calculus - MIT OCW
Convex Optimization - a MOOC on optimization from Stanford, by Steven Boyd, an authority on the subject.
The Machine learning field is evolving and new advancements are made every day. That&amp;rsquo;s why I didn&amp;rsquo;t put a third tier. The maximum I can call myself is a &amp;ldquo;Hacker&amp;rdquo; and my learning continues. Hope you do the same.
Hope you like this list. Please provide your inputs in comments on more learning resources as you see fit.
Till then. Ciao!!!
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Learning Spark using Python: Basics and Applications</title>
      <link>https://mlwhiz.com/blog/2015/09/07/spark_basics_explain/</link>
      <pubDate>Mon, 07 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2015/09/07/spark_basics_explain/</guid>
      
      

      
      <description>I generally have a use case for Hadoop in my daily job. It has made my life easier in a sense that I am able to get results which I was not able to see with SQL queries. But still I find it painfully slow. I have to write procedural programs while I work. As in merge these two datasets and then filter and then merge another dataset and then filter using some condition and yada-yada.</description>

      <content:encoded>  
        
        <![CDATA[  I generally have a use case for Hadoop in my daily job. It has made my life easier in a sense that I am able to get results which I was not able to see with SQL queries. But still I find it painfully slow. I have to write procedural programs while I work. As in merge these two datasets and then filter and then merge another dataset and then filter using some condition and yada-yada. You get the gist. And in hadoop its painstakingly boring to do this. You have to write more than maybe 3 Mapreduce Jobs. One job will read the data line by line and write to the disk.
There is a lot of data movement that happens in between that further affects the speed. Another thing I hate is that there is no straight way to pass files to mappers and reducers and that generally adds up another mapreduce job to the whole sequence.
And that is just procedural tasks. To implement an iterative algorithm even after geting the whole logic of parallelization is again a challenge. There would be a lot of mapreduce tasks, a shell based driver program and a lot of unique thinking to bring everything together. And the running times are like crazy. Though sometimes it has its benefits:
  That makes me think about the whole way Hadoop is implemented. While at the time Hadoop appeared the RAM was costly. Now that is not the case. We already have 64GB machines in our Hadoop cluster. So is it really a good idea to not use a larger chunk of memory and read line by line. Also can we have something that allows us to keep a particular piece of data in the memory, So that the next time our program needs it it doesnt have to read it again and waste time. Wouldnt it be better if we have some variable that lets us keep the state our iterative algorithm is in.
The Solution? And here is where Spark comes to rescue. Now working on Spark is very different from Hadoop but when you start using it you find that it makes things so much easier. You still do have to think in the mapreduce way sort of but the way the map and reduce steps are done are a little bit different.
So lets first get Spark on our System (But keep in mind that for running spark in production environments you will need whole clusters set up. A liberty which you may or may not have at present)
The best way that I found to install Spark is following the Apache Spark installation guidelines with the Apache Spark eDx course. It lets you get Spark in your system and work with Spark with iPython notebooks. Something I prefer a lot and find the best way to code in Python.
The installation instructions can be found HERE. You may have to login in to an edX account to follow these instructions, but it is worth it.
So once you have gone through all the steps mentioned there and installed spark using these instructions, you would see something like this in your browser.
  Ahh! so you have got Spark up and running now. That&amp;rsquo;s actually like half the process. I like to learn by examples so let&amp;rsquo;s get done with the &amp;ldquo;Hello World&amp;rdquo; of Distributed computing: The WordCount Program.
lines = sc.textFile(&amp;#34;shakespeare.txt&amp;#34;) # Distribute the data - Create a RDD counts = (lines.flatMap(lambda x: x.split(&amp;#39; &amp;#39;)) # Create a list with all words .map(lambda x: (x, 1)) # Create tuple (word,1) .reduceByKey(lambda x,y : x &#43; y)) # reduce by key i.e. the word output = counts.take(10) # get the output on local for (word, count) in output: # print output print(&amp;#34;%s: %i&amp;#34; % (word, count))   So that is a small example. Pretty small code when you compare it with Hadoop. And most of the work gets done in the second command. Don&amp;rsquo;t worry if you are not able to follow this yet as I need to tell you about the things that make Spark work.
But before we get into Spark basics, Let us refresh some of our python Basics. Understanding Spark becomes a lot easier if you have used Lambda functions in Python.
For those of you who haven&amp;rsquo;t used it, below is a brief intro.
Lambda Functions in Python Map Map is used to map a function to a array or a list. Say you want to apply some function to every element in a list. You can do this by simply using a for loop but python lambda functions let you do this in a single line in Python.
my_list = [1,2,3,4,5,6,7,8,9,10] # Lets say I want to square each term in my_list. squared_list = map(lambda x:x**2,my_list) print squared_list [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
In the above example you could think of map as a function which takes two arguments - A function and a list. It then applies the function to every element of the list. What lambda allows you to do is write an inline function. In here the part &amp;ldquo;lambda x:x**2&amp;rdquo; defines a function that takes x as input and returns x^2.
You could have also provided a proper function in place of lambda. For Example:
def squared(x): return x**2 &amp;lt;br&amp;gt;my_list = [1,2,3,4,5,6,7,8,9,10] # Lets say I want to square each term in my_list. squared_list = map(squared,my_list) print squared_list [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
The same result, but the lambda expressions make the code compact and a lot more readable.
Filter The other function that is used extensively is the filter function. This function takes two arguments - A condition and the list to filter. If you want to filter your list using some condition you use filter.
my_list = [1,2,3,4,5,6,7,8,9,10] # Lets say I want only the even numbers in my list. filtered_list = filter(lambda x:x%2==0,my_list) print filtered_list [2, 4, 6, 8, 10]
Reduce The next function is the reduce function. This function will be the workhorse in Spark. This function takes two arguments - a function to reduce that takes two arguments, and a list over which the reduce function is to be applied.
my_list = [1,2,3,4,5] # Lets say I want to sum all elements in my list. sum_list = reduce(lambda x,y:x&#43;y,my_list) print sum_list 15
Here the lambda function takes in two values x, y and returns their sum. Intuitively you can think that the reduce function works as:
Reduce function first sends 1,2 ; the lambda function returns 3 Reduce function then sends 3,3 ; the lambda function returns 6 Reduce function then sends 6,4 ; the lambda function returns 10 Reduce function finally sends 10,5 ; the lambda function returns 15  A condition on the lambda function we use in reduce is that it must be commutative that is a &#43; b = b &#43; a and associative that is (a &#43; b) &#43; c == a &#43; (b &#43; c). In the above case we used sum which is commutative as well as associative. Other functions that we could have used are max, min, multiplication etc.
Moving Again to Spark As we have now got the fundamentals of Python Functional Programming out of the way, lets again head to Spark.
But first let us delve a little bit into how spark works. Spark actually consists of two things a driver and workers. Workers normally do all the work and the driver makes them do that work.
An RDD is defined a parallelized data structure that gets distributed across the worker nodes. In our wordcount example, in the first line
lines = sc.textFile(&amp;quot;data/cs100/lab1/shakespeare.txt&amp;quot;)  We took a text file and distributed it across worker nodes so that they can work on it in parallel. We could also parallelize lists using the function
sc.parallelize  For example:
data = [1,2,3,4,5,6,7,8,9,10] new_rdd = sc.parallelize(data,4) new_rdd ParallelCollectionRDD[15] at parallelize at PythonRDD.scala:392
In Spark we classify the operations into two Basic Types: Transformations and Actions.
 Transformations : Create new datasets from existing RDDs
 Actions : Mechanism to get results out of Spark
  Understanding Transformations So lets say you have got your data in the form of an RDD. To requote your data is now accesible b all the worker machines. You want to do some transformations on the data now. You may want to filter, Apply some function etc. In Spark this is done using Transformation functions. Spark provides many transformation functions. You can see a comprehensive list here. Some of the main ones that I use frequently are:
1. Map: Applies a given function to an RDD. Note that the syntax is a little bit different from python, but it necessarily does the same thing. Don&amp;rsquo;t worry about collet yet. For now just think of it as a function that collects the data in squared_rdd back to a list.
data = [1,2,3,4,5,6,7,8,9,10] rdd = sc.parallelize(data,4) squared_rdd = rdd.map(lambda x:x**2) squared_rdd.collect() [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
2. Filter: Again no surprises here. Takes as input a condition and keeps only those elements that fulfill that condition.
data = [1,2,3,4,5,6,7,8,9,10] rdd = sc.parallelize(data,4) filtered_rdd = rdd.filter(lambda x:x%2==0) filtered_rdd.collect() [2, 4, 6, 8, 10]
3. Distinct: Returns only distinct elements in an RDD
data = [1,2,2,2,2,3,3,3,3,4,5,6,7,7,7,8,8,8,9,10] rdd = sc.parallelize(data,4) distinct_rdd = rdd.distinct() distinct_rdd.collect() [8, 4, 1, 5, 9, 2, 10, 6, 3, 7]
4. Flatmap: Similar to map, but each input item can be mapped to 0 or more output items
data = [1,2,3,4] rdd = sc.parallelize(data,4) flat_rdd = rdd.flatMap(lambda x:[x,x**3]) flat_rdd.collect() [1, 1, 2, 8, 3, 27, 4, 64]
5. Reduce By Key: The analogue to the reduce in Hadoop Mapreduce. Now Spark cannot provide the value if it just worked with Lists. In Spark there is a concept of pair RDDs that makes it a lot more flexible. Lets assume we have a data in which we have product, its category and its selling price. We can still parallelize the data.
data = [(&amp;#39;Apple&amp;#39;,&amp;#39;Fruit&amp;#39;,200),(&amp;#39;Banana&amp;#39;,&amp;#39;Fruit&amp;#39;,24),(&amp;#39;Tomato&amp;#39;,&amp;#39;Fruit&amp;#39;,56),(&amp;#39;Potato&amp;#39;,&amp;#39;Vegetable&amp;#39;,103),(&amp;#39;Carrot&amp;#39;,&amp;#39;Vegetable&amp;#39;,34)] rdd = sc.parallelize(data,4) Right now our RDD rdd holds tuples. Now we want to find out the total sum of revenue that we got from each category. To do that we have to transform our rdd to a pair rdd so that it only contatins key-value pairs/tuples.
category_price_rdd = rdd.map(lambda x: (x[1],x[2])) category_price_rdd.collect() [(&amp;lsquo;Fruit&amp;rsquo;, 200), (&amp;lsquo;Fruit&amp;rsquo;, 24), (&amp;lsquo;Fruit&amp;rsquo;, 56), (&amp;lsquo;Vegetable&amp;rsquo;, 103), (&amp;lsquo;Vegetable&amp;rsquo;, 34)]
Here we used the map function to get it in the format we wanted. When working with textfile, the rdd that gets formed has got a lot of strings. We use map to convert it into a format that we want.
So now our category_price_rdd contains the product category and the price at which the prouct sold. Now we want to reduce on the key and sum the prices. We can do this by:
category_total_price_rdd = category_price_rdd.reduceByKey(lambda x,y:x&#43;y) category_total_price_rdd.collect() [(&amp;lsquo;Vegetable&amp;rsquo;, 137), (&amp;lsquo;Fruit&amp;rsquo;, 280)]
6. Group By Key: Similar to reduce by key but does not reduce just puts all the elements in an iterator. For example if we wanted to keep as key the category and as the value all the products we would use this function.
data = [(&amp;#39;Apple&amp;#39;,&amp;#39;Fruit&amp;#39;,200),(&amp;#39;Banana&amp;#39;,&amp;#39;Fruit&amp;#39;,24),(&amp;#39;Tomato&amp;#39;,&amp;#39;Fruit&amp;#39;,56),(&amp;#39;Potato&amp;#39;,&amp;#39;Vegetable&amp;#39;,103),(&amp;#39;Carrot&amp;#39;,&amp;#39;Vegetable&amp;#39;,34)] rdd = sc.parallelize(data,4) category_product_rdd = rdd.map(lambda x: (x[1],x[0])) category_product_rdd.collect() [(&amp;lsquo;Fruit&amp;rsquo;,&amp;lsquo;Apple&amp;rsquo;),(&amp;lsquo;Fruit&amp;rsquo;,&amp;lsquo;Banana&amp;rsquo;),(&amp;lsquo;Fruit&amp;rsquo;,&amp;lsquo;Tomato&amp;rsquo;),(&amp;lsquo;Vegetable&amp;rsquo;,&amp;lsquo;Potato&amp;rsquo;),(&amp;lsquo;Vegetable&amp;rsquo;,&amp;lsquo;Carrot&amp;rsquo;)]
grouped_products_by_category_rdd = category_product_rdd.groupByKey() findata = grouped_products_by_category_rdd.collect() for data in findata: print data[0],list(data[1]) Vegetable [&amp;lsquo;Potato&amp;rsquo;, &amp;lsquo;Carrot&amp;rsquo;]
Fruit [&amp;lsquo;Apple&amp;rsquo;, &amp;lsquo;Banana&amp;rsquo;, &amp;lsquo;Tomato&amp;rsquo;]
Here the grouped by function worked and it returned the category and the list of products in that category.
Understanding Actions Now you have filtered your data, mapped some functions on it. Done your computation. Now you want to get the data on your local machine or save it to a file. You will have to use actions for that. A comprehensive list of actions is provided HERE
Some of the most common actions that I tend to use are:
1. Collect: We have already used this actio many times. It takes the whole rdd and brings it back to the driver program.
2. Reduce: Aggregate the elements of the dataset using a function func (which takes two arguments and returns one). The function should be commutative and associative so that it can be computed correctly in parallel.
rdd = sc.parallelize([1,2,3,4,5]) rdd.reduce(lambda x,y : x&#43;y) 15
3.take: Return an list with the first n elements of the dataset.
rdd = sc.parallelize([1,2,3,4,5]) rdd.take(3) [1, 2, 3]
4. takeOrdered: Return the first n elements of the RDD using either their natural order or a custom comparator.
rdd = sc.parallelize([5,3,12,23]) rdd.takeOrdered(3,lambda s:-1*s) # descending order [23, 12, 5]
rdd = sc.parallelize([(5,23),(3,34),(12,344),(23,29)]) rdd.takeOrdered(3,lambda s:-1*s[1]) # descending order [(12, 344), (3, 34), (23, 29)]
So now lets take a look at the Wordcount Again
Understanding The WordCount Example Now we sort of understand the transformations and the actions provided to us by Spark. It should not be difficult to understand the work count program now. Lets go through the program niw line by line.
The first lines creates a RDD and distributeds to the workers.
lines = sc.textFile(&amp;quot;data/cs100/lab1/shakespeare.txt&amp;quot;)  This RDD lines contains a list of strings that are actually the line in file. This RDD is of the form:
[&#39;word1 word2 word3&#39;,&#39;word4 word3 word2&#39;]  This next line is actually the workhorse function in the whole script.
counts = (lines.flatMap(lambda x: x.split(&#39; &#39;)) .map(lambda x: (x, 1)) .reduceByKey(lambda x,y : x &#43; y))  It contains a series of transformations that we do to the lines RDD. First of all we do a flatmap transformation. The flatmap transformation takes as input the lines and gives words as output. So after the flatmap transformation the RDD is of the form:
[&#39;word1&#39;,&#39;word2&#39;,&#39;word3&#39;,&#39;word4&#39;,&#39;word3&#39;,&#39;word2&#39;]  Next we do a map transformation on the flatmap output which converts the rdd to :
[(&#39;word1&#39;,1),(&#39;word2&#39;,1),(&#39;word3&#39;,1),(&#39;word4&#39;,1),(&#39;word3&#39;,1),(&#39;word2&#39;,1)]  Finally we do a reduceByKey transformation which counts the number of time each word appeared. After which the rdd approaches the final desirable form.
[(&#39;word1&#39;,1),(&#39;word2&#39;,2),(&#39;word3&#39;,2),(&#39;word4&#39;,1)]  This next line is an action that takes the first 10 elements of the resulting RDD locally.
output = counts.take(10)  This line just prints the output
for (word, count) in output: print(&amp;quot;%s: %i&amp;quot; % (word, count))  Getting Serious So till now we have talked about the Wordcount example and the basic transformations and actions that you could use in Spark. But we don&amp;rsquo;t do wordcount in real life. We have to work on bigger problems which are much more complex. Worry not! whatever we have learned till now will let us do that and more.
Lets work with a concrete example: I will work on an example in which Greg Rada Worked on Movielens Data with Pandas (BTW a great resource to learn Pandas). This example takes care of every sort of transformation that you may like to do with this data.
So lets first talk about the dataset. The movielens dataset contains a lot of files but we are going to be working with 3 files only:
1) Users: This file name is kept as &amp;ldquo;u.user&amp;rdquo;, The columns in this file are:
[&#39;user_id&#39;, &#39;age&#39;, &#39;sex&#39;, &#39;occupation&#39;, &#39;zip_code&#39;]  2) Ratings: This file name is kept as &amp;ldquo;u.data&amp;rdquo;, The columns in this file are:
[&#39;user_id&#39;, &#39;movie_id&#39;, &#39;rating&#39;, &#39;unix_timestamp&#39;]  3) Movies: This file name is kept as &amp;ldquo;u.item&amp;rdquo;, The columns in this file are:
[&#39;movie_id&#39;, &#39;title&#39;, &#39;release_date&#39;, &#39;video_release_date&#39;, &#39;imdb_url&#39;, and 18 more columns.....]  ##What are the 25 most rated movies? First of all lets load the data in different rdds. And see what the data contains.
userRDD = sc.textFile(&amp;#34;/vagrant/ml-100k/u.user&amp;#34;) ratingRDD = sc.textFile(&amp;#34;/vagrant/ml-100k/u.data&amp;#34;) movieRDD = sc.textFile(&amp;#34;/vagrant/ml-100k/u.item&amp;#34;) print &amp;#34;userRDD:&amp;#34;,userRDD.take(1) print &amp;#34;ratingRDD:&amp;#34;,ratingRDD.take(1) print &amp;#34;movieRDD:&amp;#34;,movieRDD.take(1)   Seeing the data we note that to answer this question we will need to use the ratingRdd. But the ratingRDD does not have movie name. So we would have to merge movieRDD and ratingRDD. So lets see how we would do that in Spark. Lets first do it step by step.Read the comments.
# Create a RDD from RatingRDD that only contains the two columns of interest i.e. movie_id,rating. RDD_movid_rating = ratingRDD.map(lambda x : (x.split(&amp;#34;\t&amp;#34;)[1],x.split(&amp;#34;\t&amp;#34;)[2])) print &amp;#34;RDD_movid_rating:&amp;#34;,RDD_movid_rating.take(4) # Create a RDD from MovieRDD that only contains the two columns of interest i.e. movie_id,title. RDD_movid_title = movieRDD.map(lambda x : (x.split(&amp;#34;|&amp;#34;)[0],x.split(&amp;#34;|&amp;#34;)[1])) print &amp;#34;RDD_movid_title:&amp;#34;,RDD_movid_title.take(2) # merge these two pair RDDs based on movie_id. For this we will use the transformation leftOuterJoin() rdd_movid_title_rating = RDD_movid_rating.leftOuterJoin(RDD_movid_title) print &amp;#34;rdd_movid_title_rating:&amp;#34;,rdd_movid_title_rating.take(1) # use the RDD in previous step to create (movie,1) tuple pair RDD rdd_title_rating = rdd_movid_title_rating.map(lambda x: (x[1][1],1 )) print &amp;#34;rdd_title_rating:&amp;#34;,rdd_title_rating.take(2) # Use the reduceByKey transformation to reduce on the basis of movie_title rdd_title_ratingcnt = rdd_title_rating.reduceByKey(lambda x,y: x&#43;y) print &amp;#34;rdd_title_ratingcnt:&amp;#34;,rdd_title_ratingcnt.take(2) # Get the final answer by using takeOrdered Transformation print &amp;#34;#####################################&amp;#34; print &amp;#34;25 most rated movies:&amp;#34;,rdd_title_ratingcnt.takeOrdered(25,lambda x:-x[1]) print &amp;#34;#####################################&amp;#34;   We could have done all this in a single command using the below command but the code is a little messy now. I did this to show that you can do things sequentially with Spark and you could bypass the process of variable creation.
print (((ratingRDD.map(lambda x : (x.split(&amp;#34;\t&amp;#34;)[1],x.split(&amp;#34;\t&amp;#34;)[2]))). leftOuterJoin(movieRDD.map(lambda x : (x.split(&amp;#34;|&amp;#34;)[0],x.split(&amp;#34;|&amp;#34;)[1])))). map(lambda x: (x[1][1],1)). reduceByKey(lambda x,y: x&#43;y). takeOrdered(25,lambda x:-x[1])) &amp;lt;div style=&amp;#34;margin-top: 9px; margin-bottom: 10px;&amp;#34;&amp;gt; &amp;lt;center&amp;gt;&amp;lt;img src=&amp;#34;/images/result_rating_cnt_25_2.png&amp;#34;&amp;gt;&amp;lt;/center&amp;gt; &amp;lt;/div&amp;gt; ##Which movies are most highly rated? Now we want to find the most highly rated 25 movvies using the same dataset. We actually want only those movies which have been rated atleast 100 times. Lets do this using Spark:
# We already have the RDD rdd_movid_title_rating: [(u&amp;#39;429&amp;#39;, (u&amp;#39;5&amp;#39;, u&amp;#39;Day the Earth Stood Still, The (1951)&amp;#39;))] # We create an RDD that contains sum of all the ratings for a particular movie rdd_title_ratingsum = (rdd_movid_title_rating. map(lambda x: (x[1][1],int(x[1][0]))). reduceByKey(lambda x,y:x&#43;y)) print &amp;#34;rdd_title_ratingsum:&amp;#34;,rdd_title_ratingsum.take(2) # Merge this data with the RDD rdd_title_ratingcnt we created in the last step # And use Map function to divide ratingsum by rating count. rdd_title_ratingmean_rating_count = (rdd_title_ratingsum. leftOuterJoin(rdd_title_ratingcnt). map(lambda x:(x[0],(float(x[1][0])/x[1][1],x[1][1])))) print &amp;#34;rdd_title_ratingmean_rating_count:&amp;#34;,rdd_title_ratingmean_rating_count.take(1) # We could use take ordered here only but we want to only get the movies which have count # of ratings more than or equal to 100 so lets filter the data RDD. rdd_title_rating_rating_count_gt_100 = (rdd_title_ratingmean_rating_count. filter(lambda x: x[1][1]&amp;gt;=100)) print &amp;#34;rdd_title_rating_rating_count_gt_100:&amp;#34;,rdd_title_rating_rating_count_gt_100.take(1) # Get the final answer by using takeOrdered Transformation print &amp;#34;#####################################&amp;#34; print &amp;#34;25 highly rated movies:&amp;#34;, print rdd_title_rating_rating_count_gt_100.takeOrdered(25,lambda x:-x[1][0]) print &amp;#34;#####################################&amp;#34;   Conclusion So Spark has Already provided an interface where we could apply transformations sequentially much easily than Hadoop. And it is fast. While in hadoop things are a pain to do sequentially, the infrastructure that Spark provides seem to fit naturally into the analytics use case.
Hopefully I&amp;rsquo;ve covered the basics well enough to pique your interest and help you get started with Spark. If I&amp;rsquo;ve missed something critical, feel free to let me know on Twitter or in the comments - I&amp;rsquo;d love constructive feedback.
You can find the Jupyter notebook HERE
One of the newest and best resources that you can keep an eye on is the Introduction to Big Data course in the Big Data Specialization from UCSanDiego
Look out for these two books to learn more about Spark.
  The first one of these is a bestseller. It presents 9 case studies of data analysis applications in various domains. The topics are diverse and the authors always use real world datasets. Beside learning Spark and a data science you will also have the opportunity to gain insight about topics like taxi traffic in NYC, deforestation or neuroscience. The second one is more of a reference that takes the reader on a tour of the Spark fundamentals, explaining the RDD data model in detail, after which it dives into the main functionality of Spark: Spark SQL, Spark Streaming, MLLib, SparkML, and GraphX. Later on, it covers the operational aspects of setting up a standalone Spark cluster, as well as running it on YARN and Mesos.
 ]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Hadoop Mapreduce Streaming Tricks and Techniques</title>
      <link>https://mlwhiz.com/blog/2015/05/09/hadoop_mapreduce_streaming_tricks_and_technique/</link>
      <pubDate>Sat, 09 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2015/05/09/hadoop_mapreduce_streaming_tricks_and_technique/</guid>
      
      

      
      <description>I have been using Hadoop a lot now a days and thought about writing some of the novel techniques that a user could use to get the most out of the Hadoop Ecosystem.
Using Shell Scripts to run your Programs I am not a fan of large bash commands. The ones where you have to specify the whole path of the jar files and the such. You can effectively organize your workflow by using shell scripts.</description>

      <content:encoded>  
        
        <![CDATA[  I have been using Hadoop a lot now a days and thought about writing some of the novel techniques that a user could use to get the most out of the Hadoop Ecosystem.
Using Shell Scripts to run your Programs I am not a fan of large bash commands. The ones where you have to specify the whole path of the jar files and the such. You can effectively organize your workflow by using shell scripts. Now Shell scripts are not as formidable as they sound. We wont be doing programming perse using these shell scripts(Though they are pretty good at that too), we will just use them to store commands that we need to use sequentially.
Below is a sample of the shell script I use to run my Mapreduce Codes.
#!/bin/bash #Defining program variables IP=&amp;#34;/data/input&amp;#34; OP=&amp;#34;/data/output&amp;#34; HADOOP_JAR_PATH=&amp;#34;/opt/cloudera/parcels/CDH/lib/hadoop-0.20-mapreduce/contrib/streaming/hadoop-streaming-2.0.0-mr1-cdh4.5.0.jar&amp;#34; MAPPER=&amp;#34;test_m.py&amp;#34; REDUCER=&amp;#34;test_r.py&amp;#34; hadoop fs -rmr -skipTrash&amp;amp;nbsp;$OP hadoop jar&amp;amp;nbsp;$HADOOP_JAR_PATH \ -file&amp;amp;nbsp;$MAPPER -mapper &amp;#34;python test_m.py&amp;#34; \ -file&amp;amp;nbsp;$REDUCER -reducer &amp;#34;python test_r.py&amp;#34; \ -input&amp;amp;nbsp;$IP -output&amp;amp;nbsp;$OP I generally save them as test_s.sh and whenever i need to run them i simply type sh test_s.sh. This helps in three ways.  It helps me to store hadoop commands in a manageable way.   It is easy to run the mapreduce code using the shell script.   If the code fails, I do not have to manually delete the output directory 
  The simplification of anything is always sensational.  Gilbert K. Chesterton  Using Distributed Cache to provide mapper with a dictionary Often times it happens that you want that your Hadoop Mapreduce program is able to access some static file. This static file could be a dictionary, could be parameters for the program or could be anything. What distributed cache does is that it provides this file to all the mapper nodes so that you can use that file in any way across all your mappers. Now this concept although simple would help you to think about Mapreduce in a whole new light. Lets start with an example. Supppose you have to create a sample Mapreduce program that reads a big file containing the information about all the characters in Game of Thrones stored as &amp;rdquo;/data/characters/&amp;rdquo;:   Cust_ID User_Name House     1 Daenerys Targaryen Targaryen   2 Tyrion Lannister Lannister   3 Cersei Lannister Lannister  4 Robert Baratheon Baratheon  5 Robb Stark Stark    
But you dont want to use the dead characters in the file for the analysis you want to do. You want to count the number of living characters in Game of Thrones grouped by their House. (I know its easy!!!!!) One thing you could do is include an if statement in your Mapper Code which checks if the persons ID is 4 then exclude it from the mapper and such. But the problem is that you would have to do it again and again for the same analysis as characters die like flies when it comes to George RR Martin.(Also where is the fun in that) So you create a file which contains the Ids of all the dead characters at &amp;rdquo;/data/dead_characters.txt&amp;rdquo;:
  Died     4   5     Whenever you have to run the analysis you can just add to this file and you wont have to change anything in the code. Also sometimes this file would be long and you would not want to clutter your code with IDs and such.
So How Would we do it. Let&amp;rsquo;s go in a step by step way around this. We will create a shell script, a mapper script and a reducer script for this task.
1) Shell Script #!/bin/bash #Defining program variables DC=&amp;#34;/data/dead_characters.txt&amp;#34; IP=&amp;#34;/data/characters&amp;#34; OP=&amp;#34;/data/output&amp;#34; HADOOP_JAR_PATH=&amp;#34;/opt/cloudera/parcels/CDH/lib/hadoop-0.20-mapreduce/contrib/streaming/hadoop-streaming-2.0.0-mr1-cdh4.5.0.jar&amp;#34; MAPPER=&amp;#34;got_living_m.py&amp;#34; REDUCER=&amp;#34;got_living_r.py&amp;#34; hadoop jar&amp;amp;nbsp;$HADOOP_JAR_PATH \ -file&amp;amp;nbsp;$MAPPER -mapper &amp;#34;python got_living_m.py&amp;#34; \ -file&amp;amp;nbsp;$REDUCER -reducer &amp;#34;python got_living_r.py&amp;#34; \ -cacheFile&amp;amp;nbsp;$DC#ref \ -input&amp;amp;nbsp;$IP -output&amp;amp;nbsp;$OP Note how we use the &amp;rdquo;-cacheFile&amp;rdquo; option here. We have specified that we will refer to the file that has been provided in the Distributed cache as #ref.
Next is our Mapper Script.
2) Mapper Script import sys dead_ids = set() def read_cache(): for line in open(&amp;#39;ref&amp;#39;): id = line.strip() dead_ids.add(id) read_cache() for line in sys.stdin: rec = line.strip().split(&amp;#34;|&amp;#34;) # Split using Delimiter &amp;#34;|&amp;#34; id = rec[0] house = rec[2] if id not in dead_ids: print &amp;#34;%s\t%s&amp;#34; % (house,1) And our Reducer Script.
3) Reducer Script import sys current_key = None key = None count = 0 for line in sys.stdin: line = line.strip() rec = line.split(&amp;#39;\t&amp;#39;) key = rec[0] value = int(rec[1]) if current_key == key: count &#43;= value else: if current_key: print &amp;#34;%s:%s&amp;#34; %(key,str(count))	current_key = key count = value if current_key == key: print &amp;#34;%s:%s&amp;#34; %(key,str(count)) This was a simple program and the output will be just what you expected and not very exciting. But the Technique itself solves a variety of common problems. You can use it to pass any big dictionary to your Mapreduce Program. Atleast thats what I use this feature mostly for. Hope You liked it. Will try to expand this post with more tricks.
The codes for this post are posted at github here.
Other Great Learning Resources For Hadoop:   Michael Noll&amp;rsquo;s Hadoop Mapreduce Tutorial   Apache&amp;rsquo;s Hadoop Streaming Documentation  
Also I like these books a lot. Must have for a Hadooper&amp;hellip;.
  The first book is a guide for using Hadoop as well as spark with Python. While the second one contains a detailed overview of all the things in Hadoop. Its the definitive guide.
 ]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Learning pyspark – Installation – Part 1</title>
      <link>https://mlwhiz.com/blog/2014/09/28/learning_pyspark/</link>
      <pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2014/09/28/learning_pyspark/</guid>
      
      

      
      <description>This is part one of a learning series of pyspark, which is a python binding to the spark program written in Scala.
The installation is pretty simple. These steps were done on Mac OS Mavericks but should work for Linux too. Here are the steps for the installation:
1. Download the Binaries: Spark : http://spark.apache.org/downloads.html Scala : http://www.scala-lang.org/download/ Dont use Latest Version of Scala, Use Scala 2.10.x 2. Add these lines to your .</description>

      <content:encoded>  
        
        <![CDATA[  This is part one of a learning series of pyspark, which is a python binding to the spark program written in Scala.
The installation is pretty simple. These steps were done on Mac OS Mavericks but should work for Linux too. Here are the steps for the installation:
1. Download the Binaries: Spark : http://spark.apache.org/downloads.html Scala : http://www.scala-lang.org/download/ Dont use Latest Version of Scala, Use Scala 2.10.x 2. Add these lines to your .bash_profile: export SCALA_HOME=your_path_to_scala export SPARK_HOME=your_path_to_spark 3. Build Spark(This will take time): brew install sbt cd $SPARK_HOME sbt/sbt assembly 4. Start the Pyspark Shell: $SPARK_HOME/bin/pyspark And Voila. You are running pyspark on your Machine
To check that everything is properly installed, Lets run a simple program:
test = sc.parallelize([1,2,3]) test.count() This should return 3. So Now Just Run Hadoop On your Machine and then run pyspark Using:
cd /usr/local/hadoop/ bin/start-all.sh jps $SPARK_HOME/bin/pyspark  ]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Hadoop, Mapreduce and More – Part 1</title>
      <link>https://mlwhiz.com/blog/2014/09/27/hadoop_mapreduce/</link>
      <pubDate>Sat, 27 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2014/09/27/hadoop_mapreduce/</guid>
      
      

      
      <description>It has been some time since I was stalling learning Hadoop. Finally got some free time and realized that Hadoop may not be so difficult after all. What I understood finally is that Hadoop is basically comprised of 3 elements:
 A File System Map – Reduce Its many individual Components.  Let’s go through each of them one by one.
1. Hadoop as a File System: One of the main things that Hadoop provides is cheap data storage.</description>

      <content:encoded>  
        
        <![CDATA[  It has been some time since I was stalling learning Hadoop. Finally got some free time and realized that Hadoop may not be so difficult after all. What I understood finally is that Hadoop is basically comprised of 3 elements:
 A File System Map – Reduce Its many individual Components.  Let’s go through each of them one by one.
1. Hadoop as a File System: One of the main things that Hadoop provides is cheap data storage. What happens intrinsically is that the Hadoop system takes a file, cuts it into chunks and keeps those chunks at different places in a cluster. Suppose you have a big big file in your local system and you want that file to be:
 On the cloud for easy access Processable in human time  The one thing you can look forward to is Hadoop.
Assuming that you have got hadoop installed on the amazon cluster you are working on.
Start the Hadoop Cluster: You need to run the following commands to start the hadoop cluster(Based on location of hadoop installation directory):
cd /usr/local/hadoop/ bin/start-all.sh jps Adding File to HDFS: Every command in Hadoop starts with hadoop fs and the rest of it works like the UNIX syntax. To add a file “purchases.txt” to the hdfs system:
hadoop fs -put purchases.txt /usr/purchases.txt 2. Hadoop for Map-Reduce: MapReduce is a programming model and an associated implementation for processing and generating large data sets with a parallel, distributed algorithm on a cluster.
While Hadoop is implemented in Java, you can use almost any language to do map-reduce in hadoop using hadoop streaming. Suppose you have a big file containing the Name of store and sales of store each hour. And you want to find out the sales per store using map-reduce. Lets Write a sample code for that:
InputFile
A,300,12:00 B,234,1:00 C,234,2:00 D,123,3:00 A,123,1:00 B,346,2:00  Mapper.py
import sys def mapper(): # The Mapper takes inputs from stdin and prints out store name and value for line in sys.stdin: data = line.strip().split(&amp;#34;,&amp;#34;) storeName,Value,time=data print &amp;#34;{0},{1}&amp;#34;.format(storeName,Value) Reducer.py
import sys def reducer(): # The reducer takes inputs from mapper and prints out aggregated store name and value salesTotal = 0 oldKey = None for line in sys.stdin: data = line.strip().split(&amp;#34;,&amp;#34;) #Adding a little bit of Defensive programming if len(data) != 2: continue curKey,curVal = data if oldKey adn oldKey != curKey: print &amp;#34;{0},{1}&amp;#34;.format(oldKey,salesTotal) salesTotal=0 oldKey=curKey salesTotal &#43;= curVal if oldkey!=None: print &amp;#34;{0},{1}&amp;#34;.format(oldKey,salesTotal) Running the program on shell using pipes
textfile.txt | ./mapper.py | sort | ./reducer.py Running the program on mapreduce using Hadoop Streaming
hadoop jar contrib/streaming/hadoop-*streaming*.jar / -file mapper.py -mapper mapper.py / -file reducer.py -reducer reducer.py / -input /inputfile -output /outputfile 3. Hadoop Components: Now if you have been following Hadoop you might have heard about Apache, Cloudera, HortonWorks etc. All of these are Hadoop vendors who provide Hadoop Along with its components. I will talk about the main component of Hadoop here – Hive. So what exactly is Hive: Hive is a SQL like interface to map-reduce queries. So if you don’t understand all the hocus-pocus of map-reduce but know SQL, you can do map-reduce via Hive. Seems Promising? It is. While the syntax is mainly SQL, it is still a little different and there are some quirks that we need to understand to work with Hive. First of all lets open hive command prompt: For that you just have to type “hive”, and voila you are in. Here are some general commands
show databases # -- See all Databases use database # -- Use a particular Database show tables # -- See all tables in a particular Database describe table  Creating an external table:
CREATE EXTERNAL TABLE IF NOT EXISTS BXDataSet (ISBN STRING,BookTitle STRING, ImageURLL STRING) ROW FORMAT DELIMITED FIELDS TERMINATED BY ‘;’ STORED AS TEXTFILE; LOAD DATA INPATH ‘/user/book.csv’ OVERWRITE INTO TABLE BXDataSet; The query commands work the same way as in SQL. You can do all the group by and hive will automatically convert it in map-reduce:
select * from tablename; Stay Tuned for Part 2 – Where we will talk about another components of Hadoop – PIG To learn more about hadoop in the meantime these are the books I recommend:
  ]]>
        
      </content:encoded>
      
      
      
    </item>
    
  </channel>
</rss>