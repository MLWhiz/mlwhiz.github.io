<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:content="http://purl.org/rss/1.0/modules/content" xmlns:media="http://search.yahoo.com/mrss/" >

  
  <channel>
    <title>Pandas on MLWhiz</title>
    <link>https://mlwhiz.com/tags/pandas/</link>
    <description>Recent content in Pandas on MLWhiz</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 27 Oct 2016 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://mlwhiz.com/tags/pandas/atom.xml" rel="self" type="application/rss+xml" />
    

    

    <item>
      <title>Pandas For All - Some Basic Pandas Functions</title>
      <link>https://mlwhiz.com/blog/2016/10/27/baby_panda/</link>
      <pubDate>Thu, 27 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2016/10/27/baby_panda/</guid>
      
      

      
      <description>It has been quite a few days I have been working with Pandas and apparently I feel I have gotten quite good at it. (Quite a Braggard I know) So thought about adding a post about Pandas usage here. I intend to make this post quite practical and since I find the pandas syntax quite self explanatory, I won&amp;amp;rsquo;t be explaining much of the codes. Just the use cases and the code to achieve them.</description>

      <content:encoded>  
        
        <![CDATA[  It has been quite a few days I have been working with Pandas and apparently I feel I have gotten quite good at it. (Quite a Braggard I know) So thought about adding a post about Pandas usage here. I intend to make this post quite practical and since I find the pandas syntax quite self explanatory, I won&amp;rsquo;t be explaining much of the codes. Just the use cases and the code to achieve them.
1. Import Pandas We Start by importing the libraries that we will need to use.
import pandas as pd 2. Read a Datasource: # Read from csv data files # With Header df = pd.read_csv(&amp;#34;/Users/ragarw5/Downloads/SalesJan2009.csv&amp;#34;) # Without Header. sep param to provide the delimiter df = pd.read_csv(&amp;#34;/Users/ragarw5/Downloads/SalesJan2009.csv&amp;#34;, header=None, sep= &amp;#34;,&amp;#34;) # Reading from SQL Datasource import MySQLdb from pandas import DataFrame from pandas.io.sql import read_sql db = MySQLdb.connect(host=&amp;#34;localhost&amp;#34;, # your host, usually localhost user=&amp;#34;root&amp;#34;, # your username passwd=&amp;#34;password&amp;#34;, # your password db=&amp;#34;dbname&amp;#34;) # name of the data base query = &amp;#34;SELECT * FROM tablename&amp;#34; data = read_sql(query, db) # Reading from ExcelFile data = pd.read_excel(filename) For now, we will be working with the file at http://samplecsvs.s3.amazonaws.com/SalesJan2009.csv. The Sales Jan 2009 file contains some “sanitized” sales transactions during the month of January. If you want to work along you can download this file from that location.
df = pd.read_csv(&amp;#34;/Users/ragarw5/Downloads/SalesJan2009.csv&amp;#34;) 3. See few rows of data: # top 5 rows df.head() # top 50 rows df.head(50) # last 5 rows df.tail() # last 50 rows df.tail(50) 4. Getting Column Names in a list: columnnames = df.columns 5. Specifying user defined Column Names: Sometimes you want to change the column names:
df.columns = [&amp;#39;Transdate&amp;#39;, &amp;#39;Product&amp;#39;, &amp;#39;Price&amp;#39;, &amp;#39;PaymentType&amp;#39;, &amp;#39;Name&amp;#39;, &amp;#39;City&amp;#39;, &amp;#39;State&amp;#39;, &amp;#39;Country&amp;#39;, &amp;#39;AccountCreated&amp;#39;, &amp;#39;LastLogin&amp;#39;, &amp;#39;Latitude&amp;#39;, &amp;#39;Longitude&amp;#39;] 6. Subsetting specific columns: Sometimes you only need to work with specific columns in a dataframe only. You can subset the columns in the dataframe using
newDf = df[[&amp;#39;Product&amp;#39;, &amp;#39;Price&amp;#39;, &amp;#39;PaymentType&amp;#39;, &amp;#39;Name&amp;#39;, &amp;#39;City&amp;#39;, &amp;#39;State&amp;#39;, &amp;#39;Country&amp;#39;]] 7. Seeing column types: newDf.dtypes 8. Change type of a column First thing i try is this.
newDf[&amp;#39;Price&amp;#39;] = newDf[&amp;#39;Price&amp;#39;].astype(&amp;#39;int&amp;#39;) It gives error : ValueError: invalid literal for long() with base 10: &amp;lsquo;13,000&amp;rsquo;. That is you cannot cast a string with &amp;ldquo;,&amp;rdquo; to an int. To do that we first have to get rid of the comma. For that we use a particular lambda-apply functionality which lets us apply functions to each row in the data.
newDf[&amp;#39;Price&amp;#39;] = newDf.apply(lambda x: int(x[&amp;#39;Price&amp;#39;].replace(&amp;#39;,&amp;#39;, &amp;#39;&amp;#39;)),axis=1)  9. Simple Dataframe Statistics: # To get statistics of numerical columns newDf.describe() # To get maximum value of a column. When you take a single column you can think of it as a list and apply functions you would apply to a list max(newDf[&amp;#39;Price&amp;#39;]) # no of rows in dataframe len(newDf) # Shape of Dataframe newDf.shape 10. Creating a new column: # Create a column Address containing City,State and Country. Simply concat the columns. newDf[&amp;#39;Address&amp;#39;] = newDf[&amp;#39;City&amp;#39;] &#43;&amp;#34;,&amp;#34;&#43; newDf[&amp;#39;State&amp;#39;] &#43;&amp;#34;,&amp;#34;&#43; newDf[&amp;#39;Country&amp;#39;] # I like to use a function defined approach with lambda-apply as it gives me more flexibility and more options. Like if i want to create a column which is 1 if the price is greater than 1200 and 0 otherwise. def gt(x): if x&amp;gt;1200: return 1 else: return 0 newDf[&amp;#39;Pricegt1200&amp;#39;] = newDf.apply(lambda x: gt(x[&amp;#39;Price&amp;#39;]),axis=1) 11. Subset a DataFrame: # Single condition: dataframe with all entries priced greater than 1500 df_gt_1500 = newDf[newDf[&amp;#39;Price&amp;#39;]&amp;gt;1500] # Multiple conditions: AND - dataframe with all entries priced greater than 1500 and from London And_df = newDf[(newDf[&amp;#39;Price&amp;#39;]&amp;gt;1500) &amp;amp; (newDf[&amp;#39;City&amp;#39;]==&amp;#39;London&amp;#39;)] # Multiple conditions: OR - dataframe with all entries priced greater than 1500 or from London Or_df = newDf[(newDf[&amp;#39;Price&amp;#39;]&amp;gt;1500) | (newDf[&amp;#39;City&amp;#39;]==&amp;#39;London&amp;#39;)] # Multiple conditions: NOT - dataframe with all entries priced greater than 1500 or from London have to be excluded Not_df = newDf[~((newDf[&amp;#39;Price&amp;#39;]&amp;gt;1500) | (newDf[&amp;#39;City&amp;#39;]==&amp;#39;London&amp;#39;))] 12. Change the Column at particular places or impute: # In the state column the state is abbreviated as &amp;#39;TX&amp;#39;. We want the whole name &amp;#39;Texas&amp;#39; in there newDf.loc[newDf[&amp;#39;State&amp;#39;]==&amp;#39;TX&amp;#39;,&amp;#39;State&amp;#39;] = &amp;#39;Texas&amp;#39; # When City is Monaco State is not given. You want to impute &amp;#39;Monaco State&amp;#39; as state also. newDf.loc[newDf[&amp;#39;City&amp;#39;]==&amp;#39;Monaco&amp;#39;,&amp;#39;State&amp;#39;] = &amp;#39;Monaco State&amp;#39; 13. GroupBy: One of the most used functionality. One simple example
# Find out the sum of transactions by a state. reset_index() is a function that resets the index of a dataframe. I apply this function ALWAYS whenever I do a groupby and you might think of it as a default syntax for groupby operations import numpy as np newDf.groupby([&amp;#39;State&amp;#39;]).aggregate(np.sum).reset_index() # You might get a few extra columns that you dont need. Just subset the columns in the dataframe. You could just chain the commands to subset for the columns you need. newDf.groupby([&amp;#39;State&amp;#39;]).aggregate(np.sum).reset_index()[[&amp;#39;State&amp;#39;,&amp;#39;Price&amp;#39;]] # Find minimum transaction in each state newDf.groupby([&amp;#39;State&amp;#39;]).aggregate(np.min).reset_index()[[&amp;#39;State&amp;#39;,&amp;#39;Price&amp;#39;]] # You might want to groupby more than one column newDf.groupby([&amp;#39;State&amp;#39;,&amp;#39;City&amp;#39;]).aggregate(np.sum).reset_index()[[&amp;#39;State&amp;#39;,&amp;#39;City&amp;#39;,&amp;#39;Price&amp;#39;]] 14. Concat: You have two datarames df1 and df2 you need to concat. Means append one below the other you can do it using:
pd.concat([df1,df2]) 15. Merge: #Suppose in the start, you had two dataframes. One which contains city and price information: City_Price = newwDf[[&amp;#39;City&amp;#39;,&amp;#39;Price&amp;#39;]] #And another which contains &amp;#39;City&amp;#39; and &amp;#39;State&amp;#39; insformation City_State = newDf[[&amp;#39;City&amp;#39;,&amp;#39;State&amp;#39;]].drop_duplicates(keep=False).reset_index() #You need to merge these datatframes on basis of city. You need to do: City_Price_State_df = pd.merge(City_Price,City_State,on=[&amp;#39;City&amp;#39;],how=&amp;#39;left&amp;#39;) 16. Save a Dataframe to external File: # To Csv file newDf.to_csv(&amp;#34;NewDfData.csv&amp;#34;,index=False) # To Excel File from pandas import ExcelWriter writer = ExcelWriter(&amp;#39;NewDfData.xlsx&amp;#39;) newDf.to_excel(writer,&amp;#39;Sheet1&amp;#39;) writer.save() 17. Pushing Pandas Df to a sql database: from pandas.io import sql import MySQLdb db = MySQLdb.connect(host=&amp;#34;localhost&amp;#34;, # your host, usually localhost user=&amp;#34;root&amp;#34;, # your username passwd=&amp;#34;password&amp;#34;, # your password db=&amp;#34;dbname&amp;#34;) # name of the data base newDf.to_sql(con = db, name=&amp;#39;tablename&amp;#39;,if_exists=&amp;#39;append&amp;#39;,flavor=&amp;#39;mysql&amp;#39;, chunksize=10000,index=False) Hope you found this post useful and worth your time. I tried to make this as simple as possible but You may always ask me or see the documentation for doubts.
If you have any more ideas on how to use Pandas or other usecases, please suggest in the comments section.
Till then ciao!!
References  Intro to Pandas By Greg Rada What I have written is in a condensed form, If you want to get a detailed description visit Greg Rada&amp;rsquo;s 3 posts series. Pandas Documentation  ]]>
        
      </content:encoded>
      
      
      
    </item>
    
  </channel>
</rss>