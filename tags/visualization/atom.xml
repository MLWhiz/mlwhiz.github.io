<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:content="http://purl.org/rss/1.0/modules/content" xmlns:media="http://search.yahoo.com/mrss/" >

  
  <channel>
    <title>Visualization on MLWhiz</title>
    <link>https://mlwhiz.com/tags/visualization/</link>
    <description>Recent content in Visualization on MLWhiz</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 05 May 2019 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://mlwhiz.com/tags/visualization/atom.xml" rel="self" type="application/rss+xml" />
    

    

    <item>
      <title>Python’s One Liner graph creation library with animations Hans Rosling Style</title>
      <link>https://mlwhiz.com/blog/2019/05/05/plotly_express/</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2019/05/05/plotly_express/</guid>
      
      
      <media:content type="image/png" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/plotly_ex/visualization.png"></media:content>
      

      
      <description>I distinctly remember the time when Seaborn came. I was really so fed up with Matplotlib. To create even simple graphs I had to run through so many StackOverflow threads.
The time I could have spent in thinking good ideas for presenting my data was being spent in handling Matplotlib. And it was frustrating.
Seaborn is much better than Matplotlib, yet it also demands a lot of code for a simple “good looking” graph.</description>

      <content:encoded>  
        
        <![CDATA[    I distinctly remember the time when Seaborn came. I was really so fed up with Matplotlib. To create even simple graphs I had to run through so many StackOverflow threads.
The time I could have spent in thinking good ideas for presenting my data was being spent in handling Matplotlib. And it was frustrating.
Seaborn is much better than Matplotlib, yet it also demands a lot of code for a simple “good looking” graph.
When Plotly came it tried to solve that problem. And when added with Pandas, plotly is a great tool.
Just using the iplot function, you can do so much with Plotly.
But still, it is not very intuitive. At least not for me.
I still didn’t switch to Plotly just because I had spent enough time with Seaborn to do things “quickly” enough and I didn’t want to spend any more time learning a new visualization library. I had created my own functions in Seaborn to create the visualizations I most needed. Yet it was still a workaround. I had given up hope of having anything better.
Comes Plotly Express in the picture. And is it awesome?
According to the creators of Plotly Express (who also created Plotly obviously), Plotly Express is to Plotly what Seaborn is to Matplotlib. &amp;gt; # A terse, consistent, high-level wrapper around Plotly.py for rapid data exploration and figure generation.
I just had to try it out.
And have the creators made it easy to start experimenting with it?
One-liners to do everything you want? ✅
Standardized functions? Learn to create a scatterplot and you have pretty much learned this tool — ✅
Interactive graphs? ✅
Animations? Racing Bar plots, Scatter plots with time, Maps ✅
Free and Open Source? ✅
Just a sneak peek of what we will be able to create(and more) by the end of this post. Using a single line of code.
  Ok enough of the talk, let’s get to it.
First the Dataset — Interesting, Depressing and Inspiring all at once We will be working with the Suicide dataset I took from Kaggle. This dataset is compiled from data taken from the UN, World Bank and World Health Organization. The dataset was accumulated with the inspiration for Suicide Prevention. I am always up for such good use of data.
You can find all the code for this post and run it yourself in this Kaggle Kernel
First I will do some data Cleaning to add continent information and Country ISO codes as they will be helpful later:
import pandas as pd import numpy as np import plotly_express as px # Suicide Data suicides = pd.read_csv(&amp;#34;../input/suicide-rates-overview-1985-to-2016/master.csv&amp;#34;) del suicides[&amp;#39;HDI for year&amp;#39;] del suicides[&amp;#39;country-year&amp;#39;] # Country ISO Codes iso_country_map = pd.read_csv(&amp;#34;../input/countries-iso-codes/wikipedia-iso-country-codes.csv&amp;#34;) iso_country_map = iso_country_map.rename(columns = {&amp;#39;English short name lower case&amp;#39;:&amp;#34;country&amp;#34;}) # Load Country Continents file concap =pd.read_csv(&amp;#34;../input/country-to-continent/countryContinent.csv&amp;#34;, encoding=&amp;#39;iso-8859-1&amp;#39;)[[&amp;#39;code_3&amp;#39;, &amp;#39;continent&amp;#39;, &amp;#39;sub_region&amp;#39;]] concap = concap.rename(columns = {&amp;#39;code_3&amp;#39;:&amp;#34;Alpha-3 code&amp;#34;}) correct_names = {&amp;#39;Cabo Verde&amp;#39;: &amp;#39;Cape Verde&amp;#39;, &amp;#39;Macau&amp;#39;: &amp;#39;Macao&amp;#39;, &amp;#39;Republic of Korea&amp;#39;: &amp;#34;Korea, Democratic People&amp;#39;s Republic of&amp;#34; , &amp;#39;Russian Federation&amp;#39;: &amp;#39;Russia&amp;#39;, &amp;#39;Saint Vincent and Grenadines&amp;#39;:&amp;#39;Saint Vincent and the Grenadines&amp;#39; , &amp;#39;United States&amp;#39;: &amp;#39;United States Of America&amp;#39;} def correct_country(x): if x in correct_names: return correct_names[x] else: return x suicides[&amp;#39;country&amp;#39;] = suicides[&amp;#39;country&amp;#39;].apply(lambda x : correct_country(x)) suicides = pd.merge(suicides,iso_country_map,on=&amp;#39;country&amp;#39;,how=&amp;#39;left&amp;#39;) suicides = pd.merge(suicides,concap,on=&amp;#39;Alpha-3 code&amp;#39;,how=&amp;#39;left&amp;#39;) suicides[&amp;#39;gdp&amp;#39;] = suicides[&amp;#39;gdp_per_capita ($)&amp;#39;]*suicides[&amp;#39;population&amp;#39;] Let us look at the suicides data:
  I will also group the data by continents. Honestly, I am doing this only to show the power of the library as the main objective of this post will still be to create awesome visualizations.
suicides_gby_Continent = suicides.groupby([&amp;#39;continent&amp;#39;,&amp;#39;sex&amp;#39;,&amp;#39;year&amp;#39;]).aggregate(np.sum).reset_index() suicides_gby_Continent[&amp;#39;gdp_per_capita ($)&amp;#39;] = suicides_gby_Continent[&amp;#39;gdp&amp;#39;]/suicides_gby_Continent[&amp;#39;population&amp;#39;] suicides_gby_Continent[&amp;#39;suicides/100k pop&amp;#39;] = suicides_gby_Continent[&amp;#39;suicides_no&amp;#39;]*1000/suicides_gby_Continent[&amp;#39;population&amp;#39;] # 2016 data is not full suicides_gby_Continent=suicides_gby_Continent[suicides_gby_Continent[&amp;#39;year&amp;#39;]!=2016] suicides_gby_Continent.head() The final data we created:
  Simplicity of use We are ready to visualize our data. Comes Plotly Express time. I can install it just by a simple:
pip install plotly_express and import it as:
import plotly_express as px Now let us create a simple scatter plot with it.
suicides_gby_Continent_2007 = suicides_gby_Continent[suicides_gby_Continent[&amp;#39;year&amp;#39;]==2007] px.scatter(suicides_gby_Continent_2007,x = &amp;#39;suicides/100k pop&amp;#39;, y = &amp;#39;gdp_per_capita ($)&amp;#39;)   Not very inspiring. Right. Let us make it better step by step. Lets color the points by Continent.
px.scatter(suicides_gby_Continent_2007,x = &amp;#39;suicides/100k pop&amp;#39;, y = &amp;#39;gdp_per_capita ($)&amp;#39;,color=&amp;#39;continent&amp;#39;)   Better but not inspiring. YET.
The points look so small. Right. Let us increase the point size. How? What could the parameter be….
px.scatter(suicides_gby_Continent_2007,x = &amp;#39;suicides/100k pop&amp;#39;, y = &amp;#39;gdp_per_capita ($)&amp;#39;,color=&amp;#39;ContinentName&amp;#39;,size =&amp;#39;suicides/100k pop&amp;#39;)   Can you see there are two points for every continent? They are for male and female. Let me show that in the graph. We can show this distinction using a couple of ways. We can use different symbol or use different facets for male and female.
Let me show them both.
px.scatter(suicides_gby_Continent_2007,x = &amp;#39;suicides/100k pop&amp;#39;, y = &amp;#39;gdp_per_capita ($)&amp;#39;, size = &amp;#39;suicides/100k pop&amp;#39;, color=&amp;#39;ContinentName&amp;#39;,symbol=&amp;#39;sex&amp;#39;)   We could also create a faceted plot.
px.scatter(suicides_gby_Continent_2007,x = &amp;#39;suicides/100k pop&amp;#39;, y = &amp;#39;gdp_per_capita ($)&amp;#39;, size = &amp;#39;suicides/100k pop&amp;#39;, color=&amp;#39;continent&amp;#39;,facet_col=&amp;#39;sex&amp;#39;)   The triangles are for male and the circles are for females in the symbol chart. We are already starting to see some good info from the chart. For example:
 There is a significant difference between the suicide rates of Male vs Females at least in 2007 data.
 European Males were highly susceptible to Suicide in 2007?
 The income disparity doesn’t seem to play a big role in suicide rates. Asia has a lower GDP per capita and a lower suicide rate than Europe.
 There doesn’t seem to be income disparity amongst males and females.
  Still not inspiring? Umm. Let us add some animation. That shouldn’t have to be hard. I will just add some more parameters,
 animation_frame which specifies what will be our animation dimension.
 range of x and y values using range_y and range_x
 text which labels all points with continents. Helps in visualizing data better
  px.scatter(suicides_gby_Continent,x = &amp;#39;suicides/100k pop&amp;#39;, y = &amp;#39;gdp_per_capita ($)&amp;#39;,color=&amp;#39;continent&amp;#39;, size=&amp;#39;suicides/100k pop&amp;#39;,symbol=&amp;#39;sex&amp;#39;,animation_frame=&amp;#39;year&amp;#39;, animation_group=&amp;#39;continent&amp;#39;,range_x = [0,0.6], range_y = [0,70000],text=&amp;#39;continent&amp;#39;)   Wait for the gif plot to show.
In the Jupyter notebook, you will be able to stop the visualization, hover over the points, just look at a particular continent and do so much more with interactions.
So much information with a single command. We can see that:
 From 1991–2001 European Males had a pretty bad Suicide rate.
 Oceania even after having a pretty high GDP per capita, it is still susceptible to suicides.
 Africa has lower suicide rates as compared to other countries.
 For the Americas, the suicide rates have been increasing gradually.
  All of my above observations would warrant more analysis. But that is the point of having so much information on a single graph. It will help you to come up with a lot of hypotheses.
The above style of the plot is known as Hans Rosling plot named after its founder.
Here I would ask you to see this presentation from Hans Rosling where he uses Gapminder data to explain how income and lifespan emerged in the world through years. See it. It&amp;rsquo;s great.

Function Standardization So till now, we have learned about scatter plots. So much time to just learn a single class of charts. In the start of my post, I told you that this library has a sort of standardized functions.
Let us specifically look at European data as we saw that European males have a high Suicide rate.
european_suicide_data = suicides[suicides[&amp;#39;continent&amp;#39;] ==&amp;#39;Europe&amp;#39;] european_suicide_data_gby = european_suicide_data.groupby([&amp;#39;age&amp;#39;,&amp;#39;sex&amp;#39;,&amp;#39;year&amp;#39;]).aggregate(np.sum).reset_index() european_suicide_data_gby[&amp;#39;suicides/100k pop&amp;#39;] = european_suicide_data_gby[&amp;#39;suicides_no&amp;#39;]*1000/european_suicide_data_gby[&amp;#39;population&amp;#39;] # A single line to create an animated Bar chart too. px.bar(european_suicide_data_gby,x=&amp;#39;age&amp;#39;,y=&amp;#39;suicides/100k pop&amp;#39;,facet_col=&amp;#39;sex&amp;#39;,animation_frame=&amp;#39;year&amp;#39;, animation_group=&amp;#39;age&amp;#39;, category_orders={&amp;#39;age&amp;#39;:[&amp;#39;5-14 years&amp;#39;, &amp;#39;15-24 years&amp;#39;, &amp;#39;25-34 years&amp;#39;, &amp;#39;35-54 years&amp;#39;, &amp;#39;55-74 years&amp;#39;, &amp;#39;75&#43; years&amp;#39;]},range_y=[0,1]) Just like that, we have learned about animating our bar plots too. In the function above I provide a category_order for the axes to force the order of categories since they are ordinal. Rest all is still the same.
We can see that from 1991 to 2001 the suicide rate of 75&#43; males was very high. That might have increased the overall suicide rate for males.
Want to see how the suicide rates decrease in a country using a map? That is why we got the ISO-codes for the country in the data.
How many lines should that take? You guessed right. One.
suicides_map = suicides.groupby([&amp;#39;year&amp;#39;,&amp;#39;country&amp;#39;,&amp;#39;Alpha-3 code&amp;#39;]).aggregate(np.sum).reset_index()[[&amp;#39;country&amp;#39;,&amp;#39;Alpha-3 code&amp;#39;,&amp;#39;suicides_no&amp;#39;,&amp;#39;population&amp;#39;,&amp;#39;year&amp;#39;]] suicides_map[&amp;#34;suicides/100k pop&amp;#34;]=suicides_map[&amp;#34;suicides_no&amp;#34;]*1000/suicides_map[&amp;#34;population&amp;#34;] px.choropleth(suicides_map, locations=&amp;#34;Alpha-3 code&amp;#34;, color=&amp;#34;suicides/100k pop&amp;#34;, hover_name=&amp;#34;country&amp;#34;, animation_frame=&amp;#34;year&amp;#34;, color_continuous_scale=px.colors.sequential.Plasma) The plot above shows how suicide rates have changed over time in different countries and based on the info we get from the plot the coding effort required is minimal. We can see that:
 A lot of countries are missing
 Africa has very few countries in data
 Almost all of Asia is also missing.
  We can get quite a good understanding of our data just by seeing the above graphs.
Animations on the time axis also add up a lot of value as we are able to see all our data using a single graph.
This can help us in finding hidden patterns in the data. And you have to agree, it looks cool too.
Conclusion This was just a preview of Plotly Express. You can do a lot of other things using this library.
The main thing I liked about this library is the way it has tried to simplify graph creation. And how the graphs look cool out of the box.
Just think of the lengths one would have to go to to create the same graphs in Seaborn or Matplotlib or even Plotly. And you will be able to appreciate the power the library provides even more.
There is a bit of lack of documentation for this project by Plotly, but I found that the functions are pretty much well documented. On that note, you can see function definitions using Shift&#43;Tab in Jupyter.
Also as per its announcement article: “Plotly Express is totally free: with its permissive open-source MIT license, you can use it however you like (yes, even in commercial products!).”
So there is no excuse left now to put off that visual. Just get to it…
You can find all the code for this post and run it yourself in this Kaggle Kernel
If you want to learn about best strategies for creating Visualizations, I would like to call out an excellent course about Data Visualization and applied plotting from the University of Michigan which is a part of a pretty good Data Science Specialization with Python in itself. Do check it out
I am going to be writing more beginner friendly posts in the future too. Follow me up at Medium or Subscribe to my blog to be informed about them. As always, I welcome feedback and constructive criticism and can be reached on Twitter @mlwhiz
]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>3 Awesome Visualization Techniques for every dataset</title>
      <link>https://mlwhiz.com/blog/2019/04/19/awesome_seaborn_visuals/</link>
      <pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2019/04/19/awesome_seaborn_visuals/</guid>
      
      
      <media:content type="image/jpeg" medium="image" width="700" height="400"
      url="https://mlwhiz.com/images/visualizations/football.jpeg"></media:content>
      

      
      <description>Visualizations are awesome. However, a good visualization is annoyingly hard to make.
Moreover, it takes time and effort when it comes to present these visualizations to a bigger audience.
We all know how to make Bar-Plots, Scatter Plots, and Histograms, yet we don&amp;amp;rsquo;t pay much attention to beautify them.
This hurts us - our credibility with peers and managers. You won&amp;amp;rsquo;t feel it now, but it happens.</description>

      <content:encoded>  
        
        <![CDATA[    Visualizations are awesome. However, a good visualization is annoyingly hard to make.
Moreover, it takes time and effort when it comes to present these visualizations to a bigger audience.
We all know how to make Bar-Plots, Scatter Plots, and Histograms, yet we don&amp;rsquo;t pay much attention to beautify them.
This hurts us - our credibility with peers and managers. You won&amp;rsquo;t feel it now, but it happens.
Also, I find it essential to reuse my code. Every time I visit a new dataset do I need to start again? Some reusable ideas of graphs that can help us to find information about the data FAST.
In this post, I am also going to talk about 3 cool visual tools:
 Categorical Correlation with Graphs, Pairplots, Swarmplots and Graph Annotations using Seaborn.  In short, this post is about useful and presentable graphs.
I will be using data from FIFA 19 complete player dataset on kaggle - Detailed attributes for every player registered in the latest edition of FIFA 19 database.
Since the Dataset has many columns, we will only focus on a subset of categorical and continuous columns.
import numpy as np import pandas as pd import seaborn as sns import matplotlib.pyplot as plt %matplotlib inline # We dont Probably need the Gridlines. Do we? If yes comment this line sns.set(style=&amp;#34;ticks&amp;#34;) player_df = pd.read_csv(&amp;#34;../input/data.csv&amp;#34;) numcols = [ &amp;#39;Overall&amp;#39;, &amp;#39;Potential&amp;#39;, &amp;#39;Crossing&amp;#39;,&amp;#39;Finishing&amp;#39;, &amp;#39;ShortPassing&amp;#39;, &amp;#39;Dribbling&amp;#39;,&amp;#39;LongPassing&amp;#39;, &amp;#39;BallControl&amp;#39;, &amp;#39;Acceleration&amp;#39;, &amp;#39;SprintSpeed&amp;#39;, &amp;#39;Agility&amp;#39;, &amp;#39;Stamina&amp;#39;, &amp;#39;Value&amp;#39;,&amp;#39;Wage&amp;#39;] catcols = [&amp;#39;Name&amp;#39;,&amp;#39;Club&amp;#39;,&amp;#39;Nationality&amp;#39;,&amp;#39;Preferred Foot&amp;#39;,&amp;#39;Position&amp;#39;,&amp;#39;Body Type&amp;#39;] # Subset the columns player_df = player_df[numcols&#43; catcols] # Few rows of data player_df.head(5)   Player Data    This is a nicely formatted data, yet we need to do some preprocessing to the Wage and Value columns(as they are in Euro and contain strings) to make them numeric for our subsequent analysis.
def wage_split(x): try: return int(x.split(&amp;#34;K&amp;#34;)[0][1:]) except: return 0 player_df[&amp;#39;Wage&amp;#39;] = player_df[&amp;#39;Wage&amp;#39;].apply(lambda x : wage_split(x)) def value_split(x): try: if &amp;#39;M&amp;#39; in x: return float(x.split(&amp;#34;M&amp;#34;)[0][1:]) elif &amp;#39;K&amp;#39; in x: return float(x.split(&amp;#34;K&amp;#34;)[0][1:])/1000 except: return 0 player_df[&amp;#39;Value&amp;#39;] = player_df[&amp;#39;Value&amp;#39;].apply(lambda x : value_split(x)) Categorical Correlation with Graphs: In Simple terms, Correlation is a measure of how two variables move together.
For example, In the real world, Income and Spend are positively correlated. If one increases the other also increases.
Academic Performance and Video Games Usage is negatively correlated. Increase in one predicts a decrease in another.
So if our predictor variable is positively or negatively correlated with our target variable, it is valuable.
I feel that Correlations among different variables are a pretty good thing to do when we try to understand our data.
We can create a pretty good correlation plot using Seaborn easily.
corr = player_df.corr() g = sns.heatmap(corr, vmax=.3, center=0, square=True, linewidths=.5, cbar_kws={&amp;#34;shrink&amp;#34;: .5}, annot=True, fmt=&amp;#39;.2f&amp;#39;, cmap=&amp;#39;coolwarm&amp;#39;) sns.despine() g.figure.set_size_inches(14,10) plt.show()   Where did all the categorical variables go?    But do you notice any problem?
Yes, this graph only calculates Correlation between Numerical columns. What if my target variable is Club or Position?
I want to be able to get a correlation among three different cases, and we use the following metrics of correlation to calculate these:
1. Numerical Variables We already have this in the form of Pearson&amp;rsquo;s Correlation which is a measure of how two variables move together. This Ranges from [-1,1]
2. Categorical Variables We will use Cramer&amp;rsquo;s V for categorical-categorical cases. It is the intercorrelation of two discrete variables and used with variables having two or more levels. It is a symmetrical measure as in the order of variable does not matter. Cramer(A,B) == Cramer(B,A).
For Example: In our dataset, Club and Nationality must be somehow correlated.
Let us check this using a stacked graph which is an excellent way to understand distribution between categorical vs. categorical variables. Note that we use a subset of data since there are a lot of nationalities and club in this data.
We keep only the best teams(Kept FC Porto just for more diversity in the sample)and the most common nationalities.
  Note that Club preference says quite a bit about Nationality: knowing the former helps a lot in predicting the latter.
We can see that if a player belongs to England, it is more probable that he plays in Chelsea or Manchester United and not in FC Barcelona or Bayern Munchen or Porto.
So there is some information present here. Cramer&amp;rsquo;s V captures the same information.
If all clubs have the same proportion of players from every nationality, Cramer&amp;rsquo;s V is 0.
If Every club prefers a single nationality Cramer&amp;rsquo;s V ==1, for example, all England player play in Manchester United, All Germans in Bayern Munchen and so on.
In all other cases, it ranges from [0,1]
3. Numerical and Categorical variables We will use the Correlation Ratio for categorical-continuous cases.
Without getting into too much Maths, it is a measure of Dispersion.
 Given a number can we find out which category it belongs to?
 For Example:
Suppose we have two columns from our dataset: SprintSpeed and Position:
 GK: 58(De Gea),52(T. Courtois), 58(M. Neuer), 43(G. Buffon) CB: 68(D. Godin), 59(V. Kompany), 73(S. Umtiti), 75(M. Benatia) ST: 91(C.Ronaldo), 94(G. Bale), 80(S.Aguero), 76(R. Lewandowski)  As you can see these numbers are pretty predictive of the bucket they fall into and thus high Correlation Ratio.
If I know the sprint speed is more than 85, I can definitely say this player plays at ST.
This ratio also ranges from [0,1]
The code to do this is taken from the dython package. I won&amp;rsquo;t write too much into code which you can anyway find in my Kaggle Kernel. The final result looks something like:
player_df = player_df.fillna(0) results = associations(player_df,nominal_columns=catcols,return_results=True)   Categorical vs. Categorical, Categorical vs. Numeric, Numeric vs. Numeric. Much more interesting    Isn&amp;rsquo;t it Beautiful?
We can understand so much about Football just by looking at this data. For Example:
 The position of a player is highly correlated with dribbling ability. You won&amp;rsquo;t play Messi at the back. Right?
 Value is more highly correlated with passing and ball control than dribbling. The rule is to pass the ball always. Neymar I am looking at you.
 Club and Wage have high Correlation. To be expected.
 Body Type and Preferred Foot is correlated highly. Does that mean if you are Lean, you are most likely left-footed? Doesn&amp;rsquo;t make much sense. One can investigate further.
  Moreover, so much info we could find with this simple graph which was not visible in the typical correlation plot without Categorical Variables.
I leave it here at that. One can look more into the chart and find more meaningful results, but the point is that this makes life so much easier to find patterns.
Pairplots While I talked a lot about correlation, it is a fickle metric.
To understand what I mean let us see one example.
Anscombe&amp;rsquo;s quartet comprises four datasets that have nearly identical Correlation of 1, yet have very different distributions and appear very different when graphed.
  Anscombe Quartet - Correlations can be fickle.    Thus sometimes it becomes crucial to plot correlated data. And see the distributions individually.
Now we have many columns in our dataset. Graphing them all would be so much effort.
No, it is a single line of code.
filtered_player_df = player_df[(player_df[&amp;#39;Club&amp;#39;].isin([&amp;#39;FC Barcelona&amp;#39;, &amp;#39;Paris Saint-Germain&amp;#39;, &amp;#39;Manchester United&amp;#39;, &amp;#39;Manchester City&amp;#39;, &amp;#39;Chelsea&amp;#39;, &amp;#39;Real Madrid&amp;#39;,&amp;#39;FC Porto&amp;#39;,&amp;#39;FC Bayern München&amp;#39;])) &amp;amp; (player_df[&amp;#39;Nationality&amp;#39;].isin([&amp;#39;England&amp;#39;, &amp;#39;Brazil&amp;#39;, &amp;#39;Argentina&amp;#39;, &amp;#39;Brazil&amp;#39;, &amp;#39;Italy&amp;#39;,&amp;#39;Spain&amp;#39;,&amp;#39;Germany&amp;#39;])) ] # Single line to create pairplot g = sns.pairplot(filtered_player_df[[&amp;#39;Value&amp;#39;,&amp;#39;SprintSpeed&amp;#39;,&amp;#39;Potential&amp;#39;,&amp;#39;Wage&amp;#39;]])   Pretty Good. We can see so much in this graph.
 Wage and Value are highly correlated.
 Most of the other values are correlated too. However, the trend of potential vs. value is unusual. We can see how the value increases exponentially as we reach a particular potential threshold. This information can be helpful in modeling. Can use some transformation on Potential to make it more correlated?
  Caveat: No categorical columns.
Can we do better? We always can.
g = sns.pairplot(filtered_player_df[[&amp;#39;Value&amp;#39;,&amp;#39;SprintSpeed&amp;#39;,&amp;#39;Potential&amp;#39;,&amp;#39;Wage&amp;#39;,&amp;#39;Club&amp;#39;]],hue = &amp;#39;Club&amp;#39;)   So much more info. Just by adding the hue parameter as a categorical variable Club.
 Porto&amp;rsquo;s Wage distribution is too much towards the lower side. I don&amp;rsquo;t see that steep distribution in value of Porto players. Porto&amp;rsquo;s players would always be looking out for an opportunity. See how a lot of pink points(Chelsea) form sort of a cluster on Potential vs. wage graph. Chelsea has a lot of high potential players with lower wages. Needs more attention.  I already know some of the points on the Wage/Value Subplot.
The blue point for wage 500k is Messi. Also, the orange point having more value than Messi is Neymar.
Although this hack still doesn&amp;rsquo;t solve the Categorical problem, I have something cool to look into categorical variables distribution. Though individually.
SwarmPlots How to see the relationship between categorical and numerical data?
Enter into picture Swarmplots, just like their name. A swarm of points plotted for each category with a little dispersion on the y-axis to make them easier to see.
They are my current favorite for plotting such relationships.
g = sns.swarmplot(y = &amp;#34;Club&amp;#34;, x = &amp;#39;Wage&amp;#39;, data = filtered_player_df, # Decrease the size of the points to avoid crowding  size = 7) # remove the top and right line in graph sns.despine() g.figure.set_size_inches(14,10) plt.show()   Swarmplot...    Why don&amp;rsquo;t I use Boxplots? Where are the median values? Can I plot that? Obviously. Overlay a bar plot on top, and we have a great looking graph.
g = sns.boxplot(y = &amp;#34;Club&amp;#34;, x = &amp;#39;Wage&amp;#39;, data = filtered_player_df, whis=np.inf) g = sns.swarmplot(y = &amp;#34;Club&amp;#34;, x = &amp;#39;Wage&amp;#39;, data = filtered_player_df, # Decrease the size of the points to avoid crowding  size = 7,color = &amp;#39;black&amp;#39;) # remove the top and right line in graph sns.despine() g.figure.set_size_inches(12,8) plt.show()   Swarmplot&#43;Boxplot, Interesting    Pretty good. We can see the individual points on the graph, see some statistics and understand the wage difference categorically.
The far right point is Messi. However, I should not have to tell you that in a text below the chart. Right?
This graph is going to go in a presentation. Your boss says. I want to write Messi on this graph. Comes into picture annotations.
max_wage = filtered_player_df.Wage.max() max_wage_player = filtered_player_df[(player_df[&amp;#39;Wage&amp;#39;] == max_wage)][&amp;#39;Name&amp;#39;].values[0] g = sns.boxplot(y = &amp;#34;Club&amp;#34;, x = &amp;#39;Wage&amp;#39;, data = filtered_player_df, whis=np.inf) g = sns.swarmplot(y = &amp;#34;Club&amp;#34;, x = &amp;#39;Wage&amp;#39;, data = filtered_player_df, # Decrease the size of the points to avoid crowding  size = 7,color=&amp;#39;black&amp;#39;) # remove the top and right line in graph sns.despine() # Annotate. xy for coordinate. max_wage is x and 0 is y. In this plot y ranges from 0 to 7 for each level # xytext for coordinates of where I want to put my text plt.annotate(s = max_wage_player, xy = (max_wage,0), xytext = (500,1), # Shrink the arrow to avoid occlusion arrowprops = {&amp;#39;facecolor&amp;#39;:&amp;#39;gray&amp;#39;, &amp;#39;width&amp;#39;: 3, &amp;#39;shrink&amp;#39;: 0.03}, backgroundcolor = &amp;#39;white&amp;#39;) g.figure.set_size_inches(12,8) plt.show()   Annotated, Statistical Info and point swarm. To the presentation, I go.     See Porto Down there. Competing with the giants with such a small wage budget. So many Highly paid players in Real and Barcelona. Manchester City has the highest median Wage. Manchester United and Chelsea believes in equality. Many players clustered in around the same wage scale. I am happy that while Neymar is more valued than Messi, Messi and Neymar have a huge Wage difference.  A semblance of normalcy in this crazy world.
So to recap, in this post, we talked about calculating and reading correlations between different variable types, plotting correlations between numerical data and Plotting categorical data with Numerical data using Swarmplots. I love how we can overlay chart elements on top of each other in Seaborn.
Also if you want to learn more about Visualizations, I would like to call out an excellent course about Data Visualization and applied plotting from the University of Michigan which is a part of a pretty good Data Science Specialization with Python in itself. Do check it out
If you liked this post, do look at my other post on Seaborn too where I have created some more straightforward reusable graphs. I am going to be writing more beginner friendly posts in the future too. Follow me up at Medium or Subscribe to my blog to be informed about them. As always, I welcome feedback and constructive criticism and can be reached on Twitter @mlwhiz
Code for this post in this kaggle kernel.
References:  The Search for Categorical Correlation Seaborn Swarmplot Documentation Seaborn Pairplot Documentation  ]]>
        
      </content:encoded>
      
      
      
    </item>
    

    <item>
      <title>Create basic graph visualizations with SeaBorn- The Most Awesome Python Library For Visualization yet</title>
      <link>https://mlwhiz.com/blog/2015/09/13/seaborn_visualizations/</link>
      <pubDate>Sun, 13 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>https://mlwhiz.com/blog/2015/09/13/seaborn_visualizations/</guid>
      
      

      
      <description>When it comes to data preparation and getting acquainted with data, the one step we normally skip is the data visualization. While a part of it could be attributed to the lack of good visualization tools for the platforms we use, most of us also get lazy at times.
Now as we know of it Python never had any good Visualization library. For most of our plotting needs, I would read up blogs, hack up with StackOverflow solutions and haggle with Matplotlib documentation each and every time I needed to make a simple graph.</description>

      <content:encoded>  
        
        <![CDATA[  When it comes to data preparation and getting acquainted with data, the one step we normally skip is the data visualization. While a part of it could be attributed to the lack of good visualization tools for the platforms we use, most of us also get lazy at times.
Now as we know of it Python never had any good Visualization library. For most of our plotting needs, I would read up blogs, hack up with StackOverflow solutions and haggle with Matplotlib documentation each and every time I needed to make a simple graph. This led me to think that a Blog post to create common Graph types in Python is in order. But being the procrastinator that I am it always got pushed to the back of my head.
One thing that helped me in pursuit of my data visualization needs in Python was this awesome course about Data Visualization and applied plotting from University of Michigan which is a part of a pretty good Data Science Specialization with Python in itself. Highly Recommended.
But, yesterday I got introduced to Seaborn and I must say I am quite impressed with it. It makes beautiful graphs that are in my opinion better than R&amp;rsquo;s ggplot2. Gives you enough options to customize and the best part is that it is so easy to learn.
So I am finally writing this blog post with a basic purpose of creating a code base that provides me with ready to use codes which could be put into analysis in a fairly straight-forward manner.
Right. So here Goes.
We Start by importing the libraries that we will need to use.
import matplotlib.pyplot as plt #sets up plotting under plt import seaborn as sns #sets up styles and gives us more plotting options import pandas as pd #lets us handle data as dataframes To create a use case for our graphs, we will be working with the Tips data that contains the following information.
tips = sns.load_dataset(&amp;#34;tips&amp;#34;) tips.head()   Scatterplot With Regression Line Now let us work on visualizing this data. We will use the regplot option in seaborn.
# We dont Probably need the Gridlines. Do we? If yes comment this line sns.set(style=&amp;#34;ticks&amp;#34;) # Here we create a matplotlib axes object. The extra parameters we use # &amp;#34;ci&amp;#34; to remove confidence interval # &amp;#34;marker&amp;#34; to have a x as marker. # &amp;#34;scatter_kws&amp;#34; to provide style info for the points.[s for size] # &amp;#34;line_kws&amp;#34; to provide style info for the line.[lw for line width] g = sns.regplot(x=&amp;#34;tip&amp;#34;, y=&amp;#34;total_bill&amp;#34;, data=tips, ci = False, scatter_kws={&amp;#34;color&amp;#34;:&amp;#34;darkred&amp;#34;,&amp;#34;alpha&amp;#34;:0.3,&amp;#34;s&amp;#34;:90}, line_kws={&amp;#34;color&amp;#34;:&amp;#34;g&amp;#34;,&amp;#34;alpha&amp;#34;:0.5,&amp;#34;lw&amp;#34;:4},marker=&amp;#34;x&amp;#34;) # remove the top and right line in graph sns.despine() # Set the size of the graph from here g.figure.set_size_inches(12,8) # Set the Title of the graph from here g.axes.set_title(&amp;#39;Total Bill vs. Tip&amp;#39;, fontsize=34,color=&amp;#34;r&amp;#34;,alpha=0.5) # Set the xlabel of the graph from here g.set_xlabel(&amp;#34;Tip&amp;#34;,size = 67,color=&amp;#34;r&amp;#34;,alpha=0.5) # Set the ylabel of the graph from here g.set_ylabel(&amp;#34;Total Bill&amp;#34;,size = 67,color=&amp;#34;r&amp;#34;,alpha=0.5) # Set the ticklabel size and color of the graph from here g.tick_params(labelsize=14,labelcolor=&amp;#34;black&amp;#34;)   Now that required a bit of a code but i feel that it looks much better than what either Matplotlib or ggPlot2 could have rendered. We got a lot of customization without too much code.
But that is not really what actually made me like Seaborn. The plot type that actually got my attention was lmplot, which lets us use regplot in a faceted mode.
# So this function creates a faceted plot. The plot is parameterized by the following: # col : divides the data points into days and creates that many plots # palette: deep, muted, pastel, bright, dark, and colorblind. change the colors in graph. Experiment with these # col_wrap: we want 2 graphs in a row? Yes.We do # scatter_kws: attributes for points # hue: Colors on a particular column. # size: controls the size of graph g = sns.lmplot(x=&amp;#34;tip&amp;#34;, y=&amp;#34;total_bill&amp;#34;,ci=None,data=tips, col=&amp;#34;day&amp;#34;, palette=&amp;#34;muted&amp;#34;,col_wrap=2,scatter_kws={&amp;#34;s&amp;#34;: 100,&amp;#34;alpha&amp;#34;:.5}, line_kws={&amp;#34;lw&amp;#34;:4,&amp;#34;alpha&amp;#34;:0.5},hue=&amp;#34;day&amp;#34;,x_jitter=1.0,y_jitter=1.0,size=6) # remove the top and right line in graph sns.despine() # Additional line to adjust some appearance issue plt.subplots_adjust(top=0.9) # Set the Title of the graph from here g.fig.suptitle(&amp;#39;Total Bill vs. Tip&amp;#39;, fontsize=34,color=&amp;#34;r&amp;#34;,alpha=0.5) # Set the xlabel of the graph from here g.set_xlabels(&amp;#34;Tip&amp;#34;,size = 50,color=&amp;#34;r&amp;#34;,alpha=0.5) # Set the ylabel of the graph from here g.set_ylabels(&amp;#34;Total Bill&amp;#34;,size = 50,color=&amp;#34;r&amp;#34;,alpha=0.5) # Set the ticklabel size and color of the graph from here titles = [&amp;#39;Thursday&amp;#39;,&amp;#39;Friday&amp;#39;,&amp;#39;Saturday&amp;#39;,&amp;#39;Sunday&amp;#39;] for ax,title in zip(g.axes.flat,titles): ax.tick_params(labelsize=14,labelcolor=&amp;#34;black&amp;#34;)   A side Note on Palettes:
You can build your own color palettes using color_palette() function. color_palette() will accept the name of any seaborn palette or matplotlib colormap(except jet, which you should never use). It can also take a list of colors specified in any valid matplotlib format (RGB tuples, hex color codes, or HTML color names). The return value is always a list of RGB tuples. This allows you to use your own color palettes in graph.   Barplots sns.set(style=&amp;#34;ticks&amp;#34;) flatui = [&amp;#34;#9b59b6&amp;#34;, &amp;#34;#3498db&amp;#34;, &amp;#34;#95a5a6&amp;#34;, &amp;#34;#e74c3c&amp;#34;, &amp;#34;#34495e&amp;#34;, &amp;#34;#2ecc71&amp;#34;] # This Function takes as input a custom palette g = sns.barplot(x=&amp;#34;sex&amp;#34;, y=&amp;#34;tip&amp;#34;, hue=&amp;#34;day&amp;#34;, palette=sns.color_palette(flatui),data=tips,ci=None) # remove the top and right line in graph sns.despine() # Set the size of the graph from here g.figure.set_size_inches(12,7) # Set the Title of the graph from here g.axes.set_title(&amp;#39;Do We tend to \nTip high on Weekends?&amp;#39;, fontsize=34,color=&amp;#34;b&amp;#34;,alpha=0.3) # Set the xlabel of the graph from here g.set_xlabel(&amp;#34;Gender&amp;#34;,size = 67,color=&amp;#34;g&amp;#34;,alpha=0.5) # Set the ylabel of the graph from here g.set_ylabel(&amp;#34;Mean Tips&amp;#34;,size = 67,color=&amp;#34;r&amp;#34;,alpha=0.5) # Set the ticklabel size and color of the graph from here g.tick_params(labelsize=14,labelcolor=&amp;#34;black&amp;#34;)   Histograms and Distribution Diagrams They form another part of my workflow. Lets plot the normal Histogram using seaborn. For this we will use the distplot function. This function combines the matplotlib hist function (with automatic calculation of a good default bin size) with the seaborn kdeplot() function. It can also fit scipy.stats distributions and plot the estimated PDF over the data.
# Create a list of 1000 Normal RVs x = np.random.normal(size=1000) sns.set_context(&amp;#34;poster&amp;#34;) sns.set_style(&amp;#34;ticks&amp;#34;) # This Function creates a normed Histogram by default. # If we use the parameter kde=False and norm_hist=False then # we will be using a count histogram g=sns.distplot(x, kde_kws={&amp;#34;color&amp;#34;:&amp;#34;g&amp;#34;,&amp;#34;lw&amp;#34;:4,&amp;#34;label&amp;#34;:&amp;#34;KDE Estim&amp;#34;,&amp;#34;alpha&amp;#34;:0.5}, hist_kws={&amp;#34;color&amp;#34;:&amp;#34;r&amp;#34;,&amp;#34;alpha&amp;#34;:0.3,&amp;#34;label&amp;#34;:&amp;#34;Freq&amp;#34;}) # remove the top and right line in graph sns.despine() # Set the size of the graph from here g.figure.set_size_inches(12,7) # Set the Title of the graph from here g.axes.set_title(&amp;#39;Normal Simulation&amp;#39;, fontsize=34,color=&amp;#34;b&amp;#34;,alpha=0.3) # Set the xlabel of the graph from here g.set_xlabel(&amp;#34;X&amp;#34;,size = 67,color=&amp;#34;g&amp;#34;,alpha=0.5) # Set the ylabel of the graph from here g.set_ylabel(&amp;#34;Density&amp;#34;,size = 67,color=&amp;#34;r&amp;#34;,alpha=0.5) # Set the ticklabel size and color of the graph from here g.tick_params(labelsize=14,labelcolor=&amp;#34;black&amp;#34;)   import scipy.stats as stats a = 1.5 b = 1.5 x = np.arange(0.01, 1, 0.01) y = stats.beta.rvs(a,b,size=10000) y_act = stats.beta.pdf(x,a,b) g=sns.distplot(y,kde=False,norm_hist=True, kde_kws={&amp;#34;color&amp;#34;:&amp;#34;g&amp;#34;,&amp;#34;lw&amp;#34;:4,&amp;#34;label&amp;#34;:&amp;#34;KDE Estim&amp;#34;,&amp;#34;alpha&amp;#34;:0.5}, hist_kws={&amp;#34;color&amp;#34;:&amp;#34;r&amp;#34;,&amp;#34;alpha&amp;#34;:0.3,&amp;#34;label&amp;#34;:&amp;#34;Freq&amp;#34;}) # Note that we plotted on the graph using plt matlabplot function plt.plot(x,y_act) # remove the top and right line in graph sns.despine() # Set the size of the graph from here g.figure.set_size_inches(12,7) # Set the Title of the graph from here g.axes.set_title((&amp;#34;Beta Simulation vs. Calculated Beta Density\nFor a=%s,b=%s&amp;#34;) %(a,b),fontsize=34,color=&amp;#34;b&amp;#34;,alpha=0.3) # Set the xlabel of the graph from here g.set_xlabel(&amp;#34;X&amp;#34;,size = 67,color=&amp;#34;g&amp;#34;,alpha=0.5) # Set the ylabel of the graph from here g.set_ylabel(&amp;#34;Density&amp;#34;,size = 67,color=&amp;#34;r&amp;#34;,alpha=0.5) # Set the ticklabel size and color of the graph from here g.tick_params(labelsize=14,labelcolor=&amp;#34;black&amp;#34;)   PairPlots You need to see how variables vary with one another. What is the distribution of variables in the dataset. This is the graph to use with the pairplot function. Very helpful And Seaborn males it a joy to use. We will use Iris Dataset here for this example.
iris = sns.load_dataset(&amp;#34;iris&amp;#34;) iris.head()   # Create a Pairplot g = sns.pairplot(iris,hue=&amp;#34;species&amp;#34;,palette=&amp;#34;muted&amp;#34;,size=5, vars=[&amp;#34;sepal_width&amp;#34;, &amp;#34;sepal_length&amp;#34;],kind=&amp;#39;reg&amp;#39;,markers=[&amp;#39;o&amp;#39;,&amp;#39;x&amp;#39;,&amp;#39;&#43;&amp;#39;]) # To change the size of the scatterpoints in graph g = g.map_offdiag(plt.scatter, s=35,alpha=0.5) # remove the top and right line in graph sns.despine() # Additional line to adjust some appearance issue plt.subplots_adjust(top=0.9) # Set the Title of the graph from here g.fig.suptitle(&amp;#39;Relation between Sepal Width and Sepal Length&amp;#39;, fontsize=34,color=&amp;#34;b&amp;#34;,alpha=0.3)   Hope you found this post useful and worth your time. You can find the iPython notebook at github
I tried to make this as simple as possible but You may always ask me or see the documentation for doubts.
If you have any more ideas on how to use Seaborn or which graphs should i add here, please suggest in the comments section.
I will definitely try to add to this post as I start using more visualizations and encounter other libraries as good as seaborn.
Also since this is my first visualization post on this blog, I would like to call out a good course about Data Visualization and applied plotting from University of Michigan which is a part of a pretty good Data Science Specialization with Python in itself. Do check it out.
]]>
        
      </content:encoded>
      
      
      
    </item>
    
  </channel>
</rss>